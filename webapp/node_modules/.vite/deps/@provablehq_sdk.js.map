{
  "version": 3,
  "sources": ["../../../../../node_modules/core-js/internals/global-this.js", "../../../../../node_modules/core-js/internals/fails.js", "../../../../../node_modules/core-js/internals/descriptors.js", "../../../../../node_modules/core-js/internals/function-bind-native.js", "../../../../../node_modules/core-js/internals/function-call.js", "../../../../../node_modules/core-js/internals/object-property-is-enumerable.js", "../../../../../node_modules/core-js/internals/create-property-descriptor.js", "../../../../../node_modules/core-js/internals/function-uncurry-this.js", "../../../../../node_modules/core-js/internals/classof-raw.js", "../../../../../node_modules/core-js/internals/indexed-object.js", "../../../../../node_modules/core-js/internals/is-null-or-undefined.js", "../../../../../node_modules/core-js/internals/require-object-coercible.js", "../../../../../node_modules/core-js/internals/to-indexed-object.js", "../../../../../node_modules/core-js/internals/is-callable.js", "../../../../../node_modules/core-js/internals/is-object.js", "../../../../../node_modules/core-js/internals/get-built-in.js", "../../../../../node_modules/core-js/internals/object-is-prototype-of.js", "../../../../../node_modules/core-js/internals/environment-user-agent.js", "../../../../../node_modules/core-js/internals/environment-v8-version.js", "../../../../../node_modules/core-js/internals/symbol-constructor-detection.js", "../../../../../node_modules/core-js/internals/use-symbol-as-uid.js", "../../../../../node_modules/core-js/internals/is-symbol.js", "../../../../../node_modules/core-js/internals/try-to-string.js", "../../../../../node_modules/core-js/internals/a-callable.js", "../../../../../node_modules/core-js/internals/get-method.js", "../../../../../node_modules/core-js/internals/ordinary-to-primitive.js", "../../../../../node_modules/core-js/internals/is-pure.js", "../../../../../node_modules/core-js/internals/define-global-property.js", "../../../../../node_modules/core-js/internals/shared-store.js", "../../../../../node_modules/core-js/internals/shared.js", "../../../../../node_modules/core-js/internals/to-object.js", "../../../../../node_modules/core-js/internals/has-own-property.js", "../../../../../node_modules/core-js/internals/uid.js", "../../../../../node_modules/core-js/internals/well-known-symbol.js", "../../../../../node_modules/core-js/internals/to-primitive.js", "../../../../../node_modules/core-js/internals/to-property-key.js", "../../../../../node_modules/core-js/internals/document-create-element.js", "../../../../../node_modules/core-js/internals/ie8-dom-define.js", "../../../../../node_modules/core-js/internals/object-get-own-property-descriptor.js", "../../../../../node_modules/core-js/internals/v8-prototype-define-bug.js", "../../../../../node_modules/core-js/internals/an-object.js", "../../../../../node_modules/core-js/internals/object-define-property.js", "../../../../../node_modules/core-js/internals/create-non-enumerable-property.js", "../../../../../node_modules/core-js/internals/function-name.js", "../../../../../node_modules/core-js/internals/inspect-source.js", "../../../../../node_modules/core-js/internals/weak-map-basic-detection.js", "../../../../../node_modules/core-js/internals/shared-key.js", "../../../../../node_modules/core-js/internals/hidden-keys.js", "../../../../../node_modules/core-js/internals/internal-state.js", "../../../../../node_modules/core-js/internals/make-built-in.js", "../../../../../node_modules/core-js/internals/define-built-in.js", "../../../../../node_modules/core-js/internals/math-trunc.js", "../../../../../node_modules/core-js/internals/to-integer-or-infinity.js", "../../../../../node_modules/core-js/internals/to-absolute-index.js", "../../../../../node_modules/core-js/internals/to-length.js", "../../../../../node_modules/core-js/internals/length-of-array-like.js", "../../../../../node_modules/core-js/internals/array-includes.js", "../../../../../node_modules/core-js/internals/object-keys-internal.js", "../../../../../node_modules/core-js/internals/enum-bug-keys.js", "../../../../../node_modules/core-js/internals/object-get-own-property-names.js", "../../../../../node_modules/core-js/internals/object-get-own-property-symbols.js", "../../../../../node_modules/core-js/internals/own-keys.js", "../../../../../node_modules/core-js/internals/copy-constructor-properties.js", "../../../../../node_modules/core-js/internals/is-forced.js", "../../../../../node_modules/core-js/internals/export.js", "../../../../../node_modules/core-js/internals/native-raw-json.js", "../../../../../node_modules/core-js/internals/is-raw-json.js", "../../../../../node_modules/core-js/modules/esnext.json.is-raw-json.js", "../../../../../node_modules/core-js/internals/is-array.js", "../../../../../node_modules/core-js/internals/to-string-tag-support.js", "../../../../../node_modules/core-js/internals/classof.js", "../../../../../node_modules/core-js/internals/to-string.js", "../../../../../node_modules/core-js/internals/create-property.js", "../../../../../node_modules/core-js/internals/parse-json-string.js", "../../../../../node_modules/core-js/modules/esnext.json.parse.js", "../../../../../node_modules/core-js/internals/freezing.js", "../../../../../node_modules/core-js/internals/get-json-replacer-function.js", "../../../../../node_modules/core-js/modules/esnext.json.raw-json.js", "../../../../../node_modules/core-js/proposals/json-parse-with-source.js", "../../../../node_modules/@provablehq/sdk/src/utils.ts", "../../../../node_modules/@provablehq/sdk/src/network-client.ts", "../../../../node_modules/@provablehq/sdk/src/constants.ts", "../../../../node_modules/@provablehq/sdk/src/function-key-provider.ts", "../../../../node_modules/@provablehq/sdk/src/program-manager.ts", "../../../../node_modules/@provablehq/sdk/src/account.ts", "../../../../node_modules/@provablehq/sdk/src/offline-key-provider.ts", "../../../../node_modules/@provablehq/sdk/src/record-provider.ts", "../../../../node_modules/@provablehq/sdk/src/managed-worker.ts", "../../../../node_modules/@provablehq/sdk/src/browser.ts"],
  "sourcesContent": ["'use strict';\nvar check = function (it) {\n  return it && it.Math === Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nmodule.exports =\n  // eslint-disable-next-line es/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof global == 'object' && global) ||\n  check(typeof this == 'object' && this) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || Function('return this')();\n", "'use strict';\nmodule.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n", "'use strict';\nvar fails = require('../internals/fails');\n\n// Detect IE8's incomplete defineProperty implementation\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] !== 7;\n});\n", "'use strict';\nvar fails = require('../internals/fails');\n\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es/no-function-prototype-bind -- safe\n  var test = (function () { /* empty */ }).bind();\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return typeof test != 'function' || test.hasOwnProperty('prototype');\n});\n", "'use strict';\nvar NATIVE_BIND = require('../internals/function-bind-native');\n\nvar call = Function.prototype.call;\n// eslint-disable-next-line es/no-function-prototype-bind -- safe\nmodule.exports = NATIVE_BIND ? call.bind(call) : function () {\n  return call.apply(call, arguments);\n};\n", "'use strict';\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nexports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\n", "'use strict';\nmodule.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n", "'use strict';\nvar NATIVE_BIND = require('../internals/function-bind-native');\n\nvar FunctionPrototype = Function.prototype;\nvar call = FunctionPrototype.call;\n// eslint-disable-next-line es/no-function-prototype-bind -- safe\nvar uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);\n\nmodule.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {\n  return function () {\n    return call.apply(fn, arguments);\n  };\n};\n", "'use strict';\nvar uncurryThis = require('../internals/function-uncurry-this');\n\nvar toString = uncurryThis({}.toString);\nvar stringSlice = uncurryThis(''.slice);\n\nmodule.exports = function (it) {\n  return stringSlice(toString(it), 8, -1);\n};\n", "'use strict';\nvar uncurryThis = require('../internals/function-uncurry-this');\nvar fails = require('../internals/fails');\nvar classof = require('../internals/classof-raw');\n\nvar $Object = Object;\nvar split = uncurryThis(''.split);\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nmodule.exports = fails(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !$Object('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof(it) === 'String' ? split(it, '') : $Object(it);\n} : $Object;\n", "'use strict';\n// we can't use just `it == null` since of `document.all` special case\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec\nmodule.exports = function (it) {\n  return it === null || it === undefined;\n};\n", "'use strict';\nvar isNullOrUndefined = require('../internals/is-null-or-undefined');\n\nvar $TypeError = TypeError;\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nmodule.exports = function (it) {\n  if (isNullOrUndefined(it)) throw new $TypeError(\"Can't call method on \" + it);\n  return it;\n};\n", "'use strict';\n// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject = require('../internals/indexed-object');\nvar requireObjectCoercible = require('../internals/require-object-coercible');\n\nmodule.exports = function (it) {\n  return IndexedObject(requireObjectCoercible(it));\n};\n", "'use strict';\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\nvar documentAll = typeof document == 'object' && document.all;\n\n// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\n// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing\nmodule.exports = typeof documentAll == 'undefined' && documentAll !== undefined ? function (argument) {\n  return typeof argument == 'function' || argument === documentAll;\n} : function (argument) {\n  return typeof argument == 'function';\n};\n", "'use strict';\nvar isCallable = require('../internals/is-callable');\n\nmodule.exports = function (it) {\n  return typeof it == 'object' ? it !== null : isCallable(it);\n};\n", "'use strict';\nvar globalThis = require('../internals/global-this');\nvar isCallable = require('../internals/is-callable');\n\nvar aFunction = function (argument) {\n  return isCallable(argument) ? argument : undefined;\n};\n\nmodule.exports = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(globalThis[namespace]) : globalThis[namespace] && globalThis[namespace][method];\n};\n", "'use strict';\nvar uncurryThis = require('../internals/function-uncurry-this');\n\nmodule.exports = uncurryThis({}.isPrototypeOf);\n", "'use strict';\nvar globalThis = require('../internals/global-this');\n\nvar navigator = globalThis.navigator;\nvar userAgent = navigator && navigator.userAgent;\n\nmodule.exports = userAgent ? String(userAgent) : '';\n", "'use strict';\nvar globalThis = require('../internals/global-this');\nvar userAgent = require('../internals/environment-user-agent');\n\nvar process = globalThis.process;\nvar Deno = globalThis.Deno;\nvar versions = process && process.versions || Deno && Deno.version;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split('.');\n  // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n  // but their correct versions are not interesting for us\n  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && userAgent) {\n  match = userAgent.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent.match(/Chrome\\/(\\d+)/);\n    if (match) version = +match[1];\n  }\n}\n\nmodule.exports = version;\n", "'use strict';\n/* eslint-disable es/no-symbol -- required for testing */\nvar V8_VERSION = require('../internals/environment-v8-version');\nvar fails = require('../internals/fails');\nvar globalThis = require('../internals/global-this');\n\nvar $String = globalThis.String;\n\n// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing\nmodule.exports = !!Object.getOwnPropertySymbols && !fails(function () {\n  var symbol = Symbol('symbol detection');\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,\n  // of course, fail.\n  return !$String(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n});\n", "'use strict';\n/* eslint-disable es/no-symbol -- required for testing */\nvar NATIVE_SYMBOL = require('../internals/symbol-constructor-detection');\n\nmodule.exports = NATIVE_SYMBOL &&\n  !Symbol.sham &&\n  typeof Symbol.iterator == 'symbol';\n", "'use strict';\nvar getBuiltIn = require('../internals/get-built-in');\nvar isCallable = require('../internals/is-callable');\nvar isPrototypeOf = require('../internals/object-is-prototype-of');\nvar USE_SYMBOL_AS_UID = require('../internals/use-symbol-as-uid');\n\nvar $Object = Object;\n\nmodule.exports = USE_SYMBOL_AS_UID ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  var $Symbol = getBuiltIn('Symbol');\n  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));\n};\n", "'use strict';\nvar $String = String;\n\nmodule.exports = function (argument) {\n  try {\n    return $String(argument);\n  } catch (error) {\n    return 'Object';\n  }\n};\n", "'use strict';\nvar isCallable = require('../internals/is-callable');\nvar tryToString = require('../internals/try-to-string');\n\nvar $TypeError = TypeError;\n\n// `Assert: IsCallable(argument) is true`\nmodule.exports = function (argument) {\n  if (isCallable(argument)) return argument;\n  throw new $TypeError(tryToString(argument) + ' is not a function');\n};\n", "'use strict';\nvar aCallable = require('../internals/a-callable');\nvar isNullOrUndefined = require('../internals/is-null-or-undefined');\n\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nmodule.exports = function (V, P) {\n  var func = V[P];\n  return isNullOrUndefined(func) ? undefined : aCallable(func);\n};\n", "'use strict';\nvar call = require('../internals/function-call');\nvar isCallable = require('../internals/is-callable');\nvar isObject = require('../internals/is-object');\n\nvar $TypeError = TypeError;\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nmodule.exports = function (input, pref) {\n  var fn, val;\n  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;\n  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;\n  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;\n  throw new $TypeError(\"Can't convert object to primitive value\");\n};\n", "'use strict';\nmodule.exports = false;\n", "'use strict';\nvar globalThis = require('../internals/global-this');\n\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar defineProperty = Object.defineProperty;\n\nmodule.exports = function (key, value) {\n  try {\n    defineProperty(globalThis, key, { value: value, configurable: true, writable: true });\n  } catch (error) {\n    globalThis[key] = value;\n  } return value;\n};\n", "'use strict';\nvar IS_PURE = require('../internals/is-pure');\nvar globalThis = require('../internals/global-this');\nvar defineGlobalProperty = require('../internals/define-global-property');\n\nvar SHARED = '__core-js_shared__';\nvar store = module.exports = globalThis[SHARED] || defineGlobalProperty(SHARED, {});\n\n(store.versions || (store.versions = [])).push({\n  version: '3.41.0',\n  mode: IS_PURE ? 'pure' : 'global',\n  copyright: '© 2014-2025 Denis Pushkarev (zloirock.ru)',\n  license: 'https://github.com/zloirock/core-js/blob/v3.41.0/LICENSE',\n  source: 'https://github.com/zloirock/core-js'\n});\n", "'use strict';\nvar store = require('../internals/shared-store');\n\nmodule.exports = function (key, value) {\n  return store[key] || (store[key] = value || {});\n};\n", "'use strict';\nvar requireObjectCoercible = require('../internals/require-object-coercible');\n\nvar $Object = Object;\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nmodule.exports = function (argument) {\n  return $Object(requireObjectCoercible(argument));\n};\n", "'use strict';\nvar uncurryThis = require('../internals/function-uncurry-this');\nvar toObject = require('../internals/to-object');\n\nvar hasOwnProperty = uncurryThis({}.hasOwnProperty);\n\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es/no-object-hasown -- safe\nmodule.exports = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty(toObject(it), key);\n};\n", "'use strict';\nvar uncurryThis = require('../internals/function-uncurry-this');\n\nvar id = 0;\nvar postfix = Math.random();\nvar toString = uncurryThis(1.0.toString);\n\nmodule.exports = function (key) {\n  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);\n};\n", "'use strict';\nvar globalThis = require('../internals/global-this');\nvar shared = require('../internals/shared');\nvar hasOwn = require('../internals/has-own-property');\nvar uid = require('../internals/uid');\nvar NATIVE_SYMBOL = require('../internals/symbol-constructor-detection');\nvar USE_SYMBOL_AS_UID = require('../internals/use-symbol-as-uid');\n\nvar Symbol = globalThis.Symbol;\nvar WellKnownSymbolsStore = shared('wks');\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;\n\nmodule.exports = function (name) {\n  if (!hasOwn(WellKnownSymbolsStore, name)) {\n    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name)\n      ? Symbol[name]\n      : createWellKnownSymbol('Symbol.' + name);\n  } return WellKnownSymbolsStore[name];\n};\n", "'use strict';\nvar call = require('../internals/function-call');\nvar isObject = require('../internals/is-object');\nvar isSymbol = require('../internals/is-symbol');\nvar getMethod = require('../internals/get-method');\nvar ordinaryToPrimitive = require('../internals/ordinary-to-primitive');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar $TypeError = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol('toPrimitive');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nmodule.exports = function (input, pref) {\n  if (!isObject(input) || isSymbol(input)) return input;\n  var exoticToPrim = getMethod(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === undefined) pref = 'default';\n    result = call(exoticToPrim, input, pref);\n    if (!isObject(result) || isSymbol(result)) return result;\n    throw new $TypeError(\"Can't convert object to primitive value\");\n  }\n  if (pref === undefined) pref = 'number';\n  return ordinaryToPrimitive(input, pref);\n};\n", "'use strict';\nvar toPrimitive = require('../internals/to-primitive');\nvar isSymbol = require('../internals/is-symbol');\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nmodule.exports = function (argument) {\n  var key = toPrimitive(argument, 'string');\n  return isSymbol(key) ? key : key + '';\n};\n", "'use strict';\nvar globalThis = require('../internals/global-this');\nvar isObject = require('../internals/is-object');\n\nvar document = globalThis.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS = isObject(document) && isObject(document.createElement);\n\nmodule.exports = function (it) {\n  return EXISTS ? document.createElement(it) : {};\n};\n", "'use strict';\nvar DESCRIPTORS = require('../internals/descriptors');\nvar fails = require('../internals/fails');\nvar createElement = require('../internals/document-create-element');\n\n// Thanks to IE8 for its funny defineProperty\nmodule.exports = !DESCRIPTORS && !fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty(createElement('div'), 'a', {\n    get: function () { return 7; }\n  }).a !== 7;\n});\n", "'use strict';\nvar DESCRIPTORS = require('../internals/descriptors');\nvar call = require('../internals/function-call');\nvar propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\nvar toIndexedObject = require('../internals/to-indexed-object');\nvar toPropertyKey = require('../internals/to-property-key');\nvar hasOwn = require('../internals/has-own-property');\nvar IE8_DOM_DEFINE = require('../internals/ie8-dom-define');\n\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nexports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject(O);\n  P = toPropertyKey(P);\n  if (IE8_DOM_DEFINE) try {\n    return $getOwnPropertyDescriptor(O, P);\n  } catch (error) { /* empty */ }\n  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);\n};\n", "'use strict';\nvar DESCRIPTORS = require('../internals/descriptors');\nvar fails = require('../internals/fails');\n\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nmodule.exports = DESCRIPTORS && fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty(function () { /* empty */ }, 'prototype', {\n    value: 42,\n    writable: false\n  }).prototype !== 42;\n});\n", "'use strict';\nvar isObject = require('../internals/is-object');\n\nvar $String = String;\nvar $TypeError = TypeError;\n\n// `Assert: Type(argument) is Object`\nmodule.exports = function (argument) {\n  if (isObject(argument)) return argument;\n  throw new $TypeError($String(argument) + ' is not an object');\n};\n", "'use strict';\nvar DESCRIPTORS = require('../internals/descriptors');\nvar IE8_DOM_DEFINE = require('../internals/ie8-dom-define');\nvar V8_PROTOTYPE_DEFINE_BUG = require('../internals/v8-prototype-define-bug');\nvar anObject = require('../internals/an-object');\nvar toPropertyKey = require('../internals/to-property-key');\n\nvar $TypeError = TypeError;\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = 'enumerable';\nvar CONFIGURABLE = 'configurable';\nvar WRITABLE = 'writable';\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nexports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPropertyKey(P);\n  anObject(Attributes);\n  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n    var current = $getOwnPropertyDescriptor(O, P);\n    if (current && current[WRITABLE]) {\n      O[P] = Attributes.value;\n      Attributes = {\n        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],\n        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n        writable: false\n      };\n    }\n  } return $defineProperty(O, P, Attributes);\n} : $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPropertyKey(P);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw new $TypeError('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n", "'use strict';\nvar DESCRIPTORS = require('../internals/descriptors');\nvar definePropertyModule = require('../internals/object-define-property');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\n\nmodule.exports = DESCRIPTORS ? function (object, key, value) {\n  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n", "'use strict';\nvar DESCRIPTORS = require('../internals/descriptors');\nvar hasOwn = require('../internals/has-own-property');\n\nvar FunctionPrototype = Function.prototype;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;\n\nvar EXISTS = hasOwn(FunctionPrototype, 'name');\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));\n\nmodule.exports = {\n  EXISTS: EXISTS,\n  PROPER: PROPER,\n  CONFIGURABLE: CONFIGURABLE\n};\n", "'use strict';\nvar uncurryThis = require('../internals/function-uncurry-this');\nvar isCallable = require('../internals/is-callable');\nvar store = require('../internals/shared-store');\n\nvar functionToString = uncurryThis(Function.toString);\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable(store.inspectSource)) {\n  store.inspectSource = function (it) {\n    return functionToString(it);\n  };\n}\n\nmodule.exports = store.inspectSource;\n", "'use strict';\nvar globalThis = require('../internals/global-this');\nvar isCallable = require('../internals/is-callable');\n\nvar WeakMap = globalThis.WeakMap;\n\nmodule.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));\n", "'use strict';\nvar shared = require('../internals/shared');\nvar uid = require('../internals/uid');\n\nvar keys = shared('keys');\n\nmodule.exports = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n", "'use strict';\nmodule.exports = {};\n", "'use strict';\nvar NATIVE_WEAK_MAP = require('../internals/weak-map-basic-detection');\nvar globalThis = require('../internals/global-this');\nvar isObject = require('../internals/is-object');\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar hasOwn = require('../internals/has-own-property');\nvar shared = require('../internals/shared-store');\nvar sharedKey = require('../internals/shared-key');\nvar hiddenKeys = require('../internals/hidden-keys');\n\nvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\nvar TypeError = globalThis.TypeError;\nvar WeakMap = globalThis.WeakMap;\nvar set, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n      throw new TypeError('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP || shared.state) {\n  var store = shared.state || (shared.state = new WeakMap());\n  /* eslint-disable no-self-assign -- prototype methods protection */\n  store.get = store.get;\n  store.has = store.has;\n  store.set = store.set;\n  /* eslint-enable no-self-assign -- prototype methods protection */\n  set = function (it, metadata) {\n    if (store.has(it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    store.set(it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return store.get(it) || {};\n  };\n  has = function (it) {\n    return store.has(it);\n  };\n} else {\n  var STATE = sharedKey('state');\n  hiddenKeys[STATE] = true;\n  set = function (it, metadata) {\n    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return hasOwn(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return hasOwn(it, STATE);\n  };\n}\n\nmodule.exports = {\n  set: set,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n", "'use strict';\nvar uncurryThis = require('../internals/function-uncurry-this');\nvar fails = require('../internals/fails');\nvar isCallable = require('../internals/is-callable');\nvar hasOwn = require('../internals/has-own-property');\nvar DESCRIPTORS = require('../internals/descriptors');\nvar CONFIGURABLE_FUNCTION_NAME = require('../internals/function-name').CONFIGURABLE;\nvar inspectSource = require('../internals/inspect-source');\nvar InternalStateModule = require('../internals/internal-state');\n\nvar enforceInternalState = InternalStateModule.enforce;\nvar getInternalState = InternalStateModule.get;\nvar $String = String;\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar defineProperty = Object.defineProperty;\nvar stringSlice = uncurryThis(''.slice);\nvar replace = uncurryThis(''.replace);\nvar join = uncurryThis([].join);\n\nvar CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {\n  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;\n});\n\nvar TEMPLATE = String(String).split('String');\n\nvar makeBuiltIn = module.exports = function (value, name, options) {\n  if (stringSlice($String(name), 0, 7) === 'Symbol(') {\n    name = '[' + replace($String(name), /^Symbol\\(([^)]*)\\).*$/, '$1') + ']';\n  }\n  if (options && options.getter) name = 'get ' + name;\n  if (options && options.setter) name = 'set ' + name;\n  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {\n    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });\n    else value.name = name;\n  }\n  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {\n    defineProperty(value, 'length', { value: options.arity });\n  }\n  try {\n    if (options && hasOwn(options, 'constructor') && options.constructor) {\n      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });\n    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable\n    } else if (value.prototype) value.prototype = undefined;\n  } catch (error) { /* empty */ }\n  var state = enforceInternalState(value);\n  if (!hasOwn(state, 'source')) {\n    state.source = join(TEMPLATE, typeof name == 'string' ? name : '');\n  } return value;\n};\n\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n// eslint-disable-next-line no-extend-native -- required\nFunction.prototype.toString = makeBuiltIn(function toString() {\n  return isCallable(this) && getInternalState(this).source || inspectSource(this);\n}, 'toString');\n", "'use strict';\nvar isCallable = require('../internals/is-callable');\nvar definePropertyModule = require('../internals/object-define-property');\nvar makeBuiltIn = require('../internals/make-built-in');\nvar defineGlobalProperty = require('../internals/define-global-property');\n\nmodule.exports = function (O, key, value, options) {\n  if (!options) options = {};\n  var simple = options.enumerable;\n  var name = options.name !== undefined ? options.name : key;\n  if (isCallable(value)) makeBuiltIn(value, name, options);\n  if (options.global) {\n    if (simple) O[key] = value;\n    else defineGlobalProperty(key, value);\n  } else {\n    try {\n      if (!options.unsafe) delete O[key];\n      else if (O[key]) simple = true;\n    } catch (error) { /* empty */ }\n    if (simple) O[key] = value;\n    else definePropertyModule.f(O, key, {\n      value: value,\n      enumerable: false,\n      configurable: !options.nonConfigurable,\n      writable: !options.nonWritable\n    });\n  } return O;\n};\n", "'use strict';\nvar ceil = Math.ceil;\nvar floor = Math.floor;\n\n// `Math.trunc` method\n// https://tc39.es/ecma262/#sec-math.trunc\n// eslint-disable-next-line es/no-math-trunc -- safe\nmodule.exports = Math.trunc || function trunc(x) {\n  var n = +x;\n  return (n > 0 ? floor : ceil)(n);\n};\n", "'use strict';\nvar trunc = require('../internals/math-trunc');\n\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nmodule.exports = function (argument) {\n  var number = +argument;\n  // eslint-disable-next-line no-self-compare -- NaN check\n  return number !== number || number === 0 ? 0 : trunc(number);\n};\n", "'use strict';\nvar toIntegerOrInfinity = require('../internals/to-integer-or-infinity');\n\nvar max = Math.max;\nvar min = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nmodule.exports = function (index, length) {\n  var integer = toIntegerOrInfinity(index);\n  return integer < 0 ? max(integer + length, 0) : min(integer, length);\n};\n", "'use strict';\nvar toIntegerOrInfinity = require('../internals/to-integer-or-infinity');\n\nvar min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nmodule.exports = function (argument) {\n  var len = toIntegerOrInfinity(argument);\n  return len > 0 ? min(len, 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n", "'use strict';\nvar toLength = require('../internals/to-length');\n\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nmodule.exports = function (obj) {\n  return toLength(obj.length);\n};\n", "'use strict';\nvar toIndexedObject = require('../internals/to-indexed-object');\nvar toAbsoluteIndex = require('../internals/to-absolute-index');\nvar lengthOfArrayLike = require('../internals/length-of-array-like');\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject($this);\n    var length = lengthOfArrayLike(O);\n    if (length === 0) return !IS_INCLUDES && -1;\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el !== el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value !== value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod(false)\n};\n", "'use strict';\nvar uncurryThis = require('../internals/function-uncurry-this');\nvar hasOwn = require('../internals/has-own-property');\nvar toIndexedObject = require('../internals/to-indexed-object');\nvar indexOf = require('../internals/array-includes').indexOf;\nvar hiddenKeys = require('../internals/hidden-keys');\n\nvar push = uncurryThis([].push);\n\nmodule.exports = function (object, names) {\n  var O = toIndexedObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (hasOwn(O, key = names[i++])) {\n    ~indexOf(result, key) || push(result, key);\n  }\n  return result;\n};\n", "'use strict';\n// IE8- don't enum bug keys\nmodule.exports = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n", "'use strict';\nvar internalObjectKeys = require('../internals/object-keys-internal');\nvar enumBugKeys = require('../internals/enum-bug-keys');\n\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es/no-object-getownpropertynames -- safe\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n", "'use strict';\n// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe\nexports.f = Object.getOwnPropertySymbols;\n", "'use strict';\nvar getBuiltIn = require('../internals/get-built-in');\nvar uncurryThis = require('../internals/function-uncurry-this');\nvar getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');\nvar getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');\nvar anObject = require('../internals/an-object');\n\nvar concat = uncurryThis([].concat);\n\n// all object keys, includes non-enumerable and symbols\nmodule.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;\n};\n", "'use strict';\nvar hasOwn = require('../internals/has-own-property');\nvar ownKeys = require('../internals/own-keys');\nvar getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');\nvar definePropertyModule = require('../internals/object-define-property');\n\nmodule.exports = function (target, source, exceptions) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {\n      defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n    }\n  }\n};\n", "'use strict';\nvar fails = require('../internals/fails');\nvar isCallable = require('../internals/is-callable');\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value === POLYFILL ? true\n    : value === NATIVE ? false\n    : isCallable(detection) ? fails(detection)\n    : !!detection;\n};\n\nvar normalize = isForced.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced.data = {};\nvar NATIVE = isForced.NATIVE = 'N';\nvar POLYFILL = isForced.POLYFILL = 'P';\n\nmodule.exports = isForced;\n", "'use strict';\nvar globalThis = require('../internals/global-this');\nvar getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar defineBuiltIn = require('../internals/define-built-in');\nvar defineGlobalProperty = require('../internals/define-global-property');\nvar copyConstructorProperties = require('../internals/copy-constructor-properties');\nvar isForced = require('../internals/is-forced');\n\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/\nmodule.exports = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = globalThis;\n  } else if (STATIC) {\n    target = globalThis[TARGET] || defineGlobalProperty(TARGET, {});\n  } else {\n    target = globalThis[TARGET] && globalThis[TARGET].prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.dontCallGetSet) {\n      descriptor = getOwnPropertyDescriptor(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty == typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty(sourceProperty, 'sham', true);\n    }\n    defineBuiltIn(target, key, sourceProperty, options);\n  }\n};\n", "'use strict';\n/* eslint-disable es/no-json -- safe */\nvar fails = require('../internals/fails');\n\nmodule.exports = !fails(function () {\n  var unsafeInt = '9007199254740993';\n  // eslint-disable-next-line es/no-nonstandard-json-properties -- feature detection\n  var raw = JSON.rawJSON(unsafeInt);\n  // eslint-disable-next-line es/no-nonstandard-json-properties -- feature detection\n  return !JSON.isRawJSON(raw) || JSON.stringify(raw) !== unsafeInt;\n});\n", "'use strict';\nvar isObject = require('../internals/is-object');\nvar getInternalState = require('../internals/internal-state').get;\n\nmodule.exports = function isRawJSON(O) {\n  if (!isObject(O)) return false;\n  var state = getInternalState(O);\n  return !!state && state.type === 'RawJSON';\n};\n", "'use strict';\nvar $ = require('../internals/export');\nvar NATIVE_RAW_JSON = require('../internals/native-raw-json');\nvar isRawJSON = require('../internals/is-raw-json');\n\n// `JSON.parse` method\n// https://tc39.es/proposal-json-parse-with-source/#sec-json.israwjson\n// https://github.com/tc39/proposal-json-parse-with-source\n$({ target: 'JSON', stat: true, forced: !NATIVE_RAW_JSON }, {\n  isRawJSON: isRawJSON\n});\n", "'use strict';\nvar classof = require('../internals/classof-raw');\n\n// `IsArray` abstract operation\n// https://tc39.es/ecma262/#sec-isarray\n// eslint-disable-next-line es/no-array-isarray -- safe\nmodule.exports = Array.isArray || function isArray(argument) {\n  return classof(argument) === 'Array';\n};\n", "'use strict';\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar test = {};\n\ntest[TO_STRING_TAG] = 'z';\n\nmodule.exports = String(test) === '[object z]';\n", "'use strict';\nvar TO_STRING_TAG_SUPPORT = require('../internals/to-string-tag-support');\nvar isCallable = require('../internals/is-callable');\nvar classofRaw = require('../internals/classof-raw');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar $Object = Object;\n\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) === 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nmodule.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) === 'Object' && isCallable(O.callee) ? 'Arguments' : result;\n};\n", "'use strict';\nvar classof = require('../internals/classof');\n\nvar $String = String;\n\nmodule.exports = function (argument) {\n  if (classof(argument) === 'Symbol') throw new TypeError('Cannot convert a Symbol value to a string');\n  return $String(argument);\n};\n", "'use strict';\nvar DESCRIPTORS = require('../internals/descriptors');\nvar definePropertyModule = require('../internals/object-define-property');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\n\nmodule.exports = function (object, key, value) {\n  if (DESCRIPTORS) definePropertyModule.f(object, key, createPropertyDescriptor(0, value));\n  else object[key] = value;\n};\n", "'use strict';\nvar uncurryThis = require('../internals/function-uncurry-this');\nvar hasOwn = require('../internals/has-own-property');\n\nvar $SyntaxError = SyntaxError;\nvar $parseInt = parseInt;\nvar fromCharCode = String.fromCharCode;\nvar at = uncurryThis(''.charAt);\nvar slice = uncurryThis(''.slice);\nvar exec = uncurryThis(/./.exec);\n\nvar codePoints = {\n  '\\\\\"': '\"',\n  '\\\\\\\\': '\\\\',\n  '\\\\/': '/',\n  '\\\\b': '\\b',\n  '\\\\f': '\\f',\n  '\\\\n': '\\n',\n  '\\\\r': '\\r',\n  '\\\\t': '\\t'\n};\n\nvar IS_4_HEX_DIGITS = /^[\\da-f]{4}$/i;\n// eslint-disable-next-line regexp/no-control-character -- safe\nvar IS_C0_CONTROL_CODE = /^[\\u0000-\\u001F]$/;\n\nmodule.exports = function (source, i) {\n  var unterminated = true;\n  var value = '';\n  while (i < source.length) {\n    var chr = at(source, i);\n    if (chr === '\\\\') {\n      var twoChars = slice(source, i, i + 2);\n      if (hasOwn(codePoints, twoChars)) {\n        value += codePoints[twoChars];\n        i += 2;\n      } else if (twoChars === '\\\\u') {\n        i += 2;\n        var fourHexDigits = slice(source, i, i + 4);\n        if (!exec(IS_4_HEX_DIGITS, fourHexDigits)) throw new $SyntaxError('Bad Unicode escape at: ' + i);\n        value += fromCharCode($parseInt(fourHexDigits, 16));\n        i += 4;\n      } else throw new $SyntaxError('Unknown escape sequence: \"' + twoChars + '\"');\n    } else if (chr === '\"') {\n      unterminated = false;\n      i++;\n      break;\n    } else {\n      if (exec(IS_C0_CONTROL_CODE, chr)) throw new $SyntaxError('Bad control character in string literal at: ' + i);\n      value += chr;\n      i++;\n    }\n  }\n  if (unterminated) throw new $SyntaxError('Unterminated string at: ' + i);\n  return { value: value, end: i };\n};\n", "'use strict';\nvar $ = require('../internals/export');\nvar DESCRIPTORS = require('../internals/descriptors');\nvar globalThis = require('../internals/global-this');\nvar getBuiltIn = require('../internals/get-built-in');\nvar uncurryThis = require('../internals/function-uncurry-this');\nvar call = require('../internals/function-call');\nvar isCallable = require('../internals/is-callable');\nvar isObject = require('../internals/is-object');\nvar isArray = require('../internals/is-array');\nvar hasOwn = require('../internals/has-own-property');\nvar toString = require('../internals/to-string');\nvar lengthOfArrayLike = require('../internals/length-of-array-like');\nvar createProperty = require('../internals/create-property');\nvar fails = require('../internals/fails');\nvar parseJSONString = require('../internals/parse-json-string');\nvar NATIVE_SYMBOL = require('../internals/symbol-constructor-detection');\n\nvar JSON = globalThis.JSON;\nvar Number = globalThis.Number;\nvar SyntaxError = globalThis.SyntaxError;\nvar nativeParse = JSON && JSON.parse;\nvar enumerableOwnProperties = getBuiltIn('Object', 'keys');\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar at = uncurryThis(''.charAt);\nvar slice = uncurryThis(''.slice);\nvar exec = uncurryThis(/./.exec);\nvar push = uncurryThis([].push);\n\nvar IS_DIGIT = /^\\d$/;\nvar IS_NON_ZERO_DIGIT = /^[1-9]$/;\nvar IS_NUMBER_START = /^[\\d-]$/;\nvar IS_WHITESPACE = /^[\\t\\n\\r ]$/;\n\nvar PRIMITIVE = 0;\nvar OBJECT = 1;\n\nvar $parse = function (source, reviver) {\n  source = toString(source);\n  var context = new Context(source, 0, '');\n  var root = context.parse();\n  var value = root.value;\n  var endIndex = context.skip(IS_WHITESPACE, root.end);\n  if (endIndex < source.length) {\n    throw new SyntaxError('Unexpected extra character: \"' + at(source, endIndex) + '\" after the parsed data at: ' + endIndex);\n  }\n  return isCallable(reviver) ? internalize({ '': value }, '', reviver, root) : value;\n};\n\nvar internalize = function (holder, name, reviver, node) {\n  var val = holder[name];\n  var unmodified = node && val === node.value;\n  var context = unmodified && typeof node.source == 'string' ? { source: node.source } : {};\n  var elementRecordsLen, keys, len, i, P;\n  if (isObject(val)) {\n    var nodeIsArray = isArray(val);\n    var nodes = unmodified ? node.nodes : nodeIsArray ? [] : {};\n    if (nodeIsArray) {\n      elementRecordsLen = nodes.length;\n      len = lengthOfArrayLike(val);\n      for (i = 0; i < len; i++) {\n        internalizeProperty(val, i, internalize(val, '' + i, reviver, i < elementRecordsLen ? nodes[i] : undefined));\n      }\n    } else {\n      keys = enumerableOwnProperties(val);\n      len = lengthOfArrayLike(keys);\n      for (i = 0; i < len; i++) {\n        P = keys[i];\n        internalizeProperty(val, P, internalize(val, P, reviver, hasOwn(nodes, P) ? nodes[P] : undefined));\n      }\n    }\n  }\n  return call(reviver, holder, name, val, context);\n};\n\nvar internalizeProperty = function (object, key, value) {\n  if (DESCRIPTORS) {\n    var descriptor = getOwnPropertyDescriptor(object, key);\n    if (descriptor && !descriptor.configurable) return;\n  }\n  if (value === undefined) delete object[key];\n  else createProperty(object, key, value);\n};\n\nvar Node = function (value, end, source, nodes) {\n  this.value = value;\n  this.end = end;\n  this.source = source;\n  this.nodes = nodes;\n};\n\nvar Context = function (source, index) {\n  this.source = source;\n  this.index = index;\n};\n\n// https://www.json.org/json-en.html\nContext.prototype = {\n  fork: function (nextIndex) {\n    return new Context(this.source, nextIndex);\n  },\n  parse: function () {\n    var source = this.source;\n    var i = this.skip(IS_WHITESPACE, this.index);\n    var fork = this.fork(i);\n    var chr = at(source, i);\n    if (exec(IS_NUMBER_START, chr)) return fork.number();\n    switch (chr) {\n      case '{':\n        return fork.object();\n      case '[':\n        return fork.array();\n      case '\"':\n        return fork.string();\n      case 't':\n        return fork.keyword(true);\n      case 'f':\n        return fork.keyword(false);\n      case 'n':\n        return fork.keyword(null);\n    } throw new SyntaxError('Unexpected character: \"' + chr + '\" at: ' + i);\n  },\n  node: function (type, value, start, end, nodes) {\n    return new Node(value, end, type ? null : slice(this.source, start, end), nodes);\n  },\n  object: function () {\n    var source = this.source;\n    var i = this.index + 1;\n    var expectKeypair = false;\n    var object = {};\n    var nodes = {};\n    while (i < source.length) {\n      i = this.until(['\"', '}'], i);\n      if (at(source, i) === '}' && !expectKeypair) {\n        i++;\n        break;\n      }\n      // Parsing the key\n      var result = this.fork(i).string();\n      var key = result.value;\n      i = result.end;\n      i = this.until([':'], i) + 1;\n      // Parsing value\n      i = this.skip(IS_WHITESPACE, i);\n      result = this.fork(i).parse();\n      createProperty(nodes, key, result);\n      createProperty(object, key, result.value);\n      i = this.until([',', '}'], result.end);\n      var chr = at(source, i);\n      if (chr === ',') {\n        expectKeypair = true;\n        i++;\n      } else if (chr === '}') {\n        i++;\n        break;\n      }\n    }\n    return this.node(OBJECT, object, this.index, i, nodes);\n  },\n  array: function () {\n    var source = this.source;\n    var i = this.index + 1;\n    var expectElement = false;\n    var array = [];\n    var nodes = [];\n    while (i < source.length) {\n      i = this.skip(IS_WHITESPACE, i);\n      if (at(source, i) === ']' && !expectElement) {\n        i++;\n        break;\n      }\n      var result = this.fork(i).parse();\n      push(nodes, result);\n      push(array, result.value);\n      i = this.until([',', ']'], result.end);\n      if (at(source, i) === ',') {\n        expectElement = true;\n        i++;\n      } else if (at(source, i) === ']') {\n        i++;\n        break;\n      }\n    }\n    return this.node(OBJECT, array, this.index, i, nodes);\n  },\n  string: function () {\n    var index = this.index;\n    var parsed = parseJSONString(this.source, this.index + 1);\n    return this.node(PRIMITIVE, parsed.value, index, parsed.end);\n  },\n  number: function () {\n    var source = this.source;\n    var startIndex = this.index;\n    var i = startIndex;\n    if (at(source, i) === '-') i++;\n    if (at(source, i) === '0') i++;\n    else if (exec(IS_NON_ZERO_DIGIT, at(source, i))) i = this.skip(IS_DIGIT, i + 1);\n    else throw new SyntaxError('Failed to parse number at: ' + i);\n    if (at(source, i) === '.') i = this.skip(IS_DIGIT, i + 1);\n    if (at(source, i) === 'e' || at(source, i) === 'E') {\n      i++;\n      if (at(source, i) === '+' || at(source, i) === '-') i++;\n      var exponentStartIndex = i;\n      i = this.skip(IS_DIGIT, i);\n      if (exponentStartIndex === i) throw new SyntaxError(\"Failed to parse number's exponent value at: \" + i);\n    }\n    return this.node(PRIMITIVE, Number(slice(source, startIndex, i)), startIndex, i);\n  },\n  keyword: function (value) {\n    var keyword = '' + value;\n    var index = this.index;\n    var endIndex = index + keyword.length;\n    if (slice(this.source, index, endIndex) !== keyword) throw new SyntaxError('Failed to parse value at: ' + index);\n    return this.node(PRIMITIVE, value, index, endIndex);\n  },\n  skip: function (regex, i) {\n    var source = this.source;\n    for (; i < source.length; i++) if (!exec(regex, at(source, i))) break;\n    return i;\n  },\n  until: function (array, i) {\n    i = this.skip(IS_WHITESPACE, i);\n    var chr = at(this.source, i);\n    for (var j = 0; j < array.length; j++) if (array[j] === chr) return i;\n    throw new SyntaxError('Unexpected character: \"' + chr + '\" at: ' + i);\n  }\n};\n\nvar NO_SOURCE_SUPPORT = fails(function () {\n  var unsafeInt = '9007199254740993';\n  var source;\n  nativeParse(unsafeInt, function (key, value, context) {\n    source = context.source;\n  });\n  return source !== unsafeInt;\n});\n\nvar PROPER_BASE_PARSE = NATIVE_SYMBOL && !fails(function () {\n  // Safari 9 bug\n  return 1 / nativeParse('-0 \\t') !== -Infinity;\n});\n\n// `JSON.parse` method\n// https://tc39.es/ecma262/#sec-json.parse\n// https://github.com/tc39/proposal-json-parse-with-source\n$({ target: 'JSON', stat: true, forced: NO_SOURCE_SUPPORT }, {\n  parse: function parse(text, reviver) {\n    return PROPER_BASE_PARSE && !isCallable(reviver) ? nativeParse(text) : $parse(text, reviver);\n  }\n});\n", "'use strict';\nvar fails = require('../internals/fails');\n\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es/no-object-isextensible, es/no-object-preventextensions -- required for testing\n  return Object.isExtensible(Object.preventExtensions({}));\n});\n", "'use strict';\nvar uncurryThis = require('../internals/function-uncurry-this');\nvar isArray = require('../internals/is-array');\nvar isCallable = require('../internals/is-callable');\nvar classof = require('../internals/classof-raw');\nvar toString = require('../internals/to-string');\n\nvar push = uncurryThis([].push);\n\nmodule.exports = function (replacer) {\n  if (isCallable(replacer)) return replacer;\n  if (!isArray(replacer)) return;\n  var rawLength = replacer.length;\n  var keys = [];\n  for (var i = 0; i < rawLength; i++) {\n    var element = replacer[i];\n    if (typeof element == 'string') push(keys, element);\n    else if (typeof element == 'number' || classof(element) === 'Number' || classof(element) === 'String') push(keys, toString(element));\n  }\n  var keysLength = keys.length;\n  var root = true;\n  return function (key, value) {\n    if (root) {\n      root = false;\n      return value;\n    }\n    if (isArray(this)) return value;\n    for (var j = 0; j < keysLength; j++) if (keys[j] === key) return value;\n  };\n};\n", "'use strict';\nvar $ = require('../internals/export');\nvar FREEZING = require('../internals/freezing');\nvar NATIVE_RAW_JSON = require('../internals/native-raw-json');\nvar getBuiltIn = require('../internals/get-built-in');\nvar call = require('../internals/function-call');\nvar uncurryThis = require('../internals/function-uncurry-this');\nvar isCallable = require('../internals/is-callable');\nvar isRawJSON = require('../internals/is-raw-json');\nvar toString = require('../internals/to-string');\nvar createProperty = require('../internals/create-property');\nvar parseJSONString = require('../internals/parse-json-string');\nvar getReplacerFunction = require('../internals/get-json-replacer-function');\nvar uid = require('../internals/uid');\nvar setInternalState = require('../internals/internal-state').set;\n\nvar $String = String;\nvar $SyntaxError = SyntaxError;\nvar parse = getBuiltIn('JSON', 'parse');\nvar $stringify = getBuiltIn('JSON', 'stringify');\nvar create = getBuiltIn('Object', 'create');\nvar freeze = getBuiltIn('Object', 'freeze');\nvar at = uncurryThis(''.charAt);\nvar slice = uncurryThis(''.slice);\nvar push = uncurryThis([].push);\n\nvar MARK = uid();\nvar MARK_LENGTH = MARK.length;\nvar ERROR_MESSAGE = 'Unacceptable as raw JSON';\n\nvar isWhitespace = function (it) {\n  return it === ' ' || it === '\\t' || it === '\\n' || it === '\\r';\n};\n\n// `JSON.parse` method\n// https://tc39.es/proposal-json-parse-with-source/#sec-json.israwjson\n// https://github.com/tc39/proposal-json-parse-with-source\n$({ target: 'JSON', stat: true, forced: !NATIVE_RAW_JSON }, {\n  rawJSON: function rawJSON(text) {\n    var jsonString = toString(text);\n    if (jsonString === '' || isWhitespace(at(jsonString, 0)) || isWhitespace(at(jsonString, jsonString.length - 1))) {\n      throw new $SyntaxError(ERROR_MESSAGE);\n    }\n    var parsed = parse(jsonString);\n    if (typeof parsed == 'object' && parsed !== null) throw new $SyntaxError(ERROR_MESSAGE);\n    var obj = create(null);\n    setInternalState(obj, { type: 'RawJSON' });\n    createProperty(obj, 'rawJSON', jsonString);\n    return FREEZING ? freeze(obj) : obj;\n  }\n});\n\n// `JSON.stringify` method\n// https://tc39.es/ecma262/#sec-json.stringify\n// https://github.com/tc39/proposal-json-parse-with-source\nif ($stringify) $({ target: 'JSON', stat: true, arity: 3, forced: !NATIVE_RAW_JSON }, {\n  stringify: function stringify(text, replacer, space) {\n    var replacerFunction = getReplacerFunction(replacer);\n    var rawStrings = [];\n\n    var json = $stringify(text, function (key, value) {\n      // some old implementations (like WebKit) could pass numbers as keys\n      var v = isCallable(replacerFunction) ? call(replacerFunction, this, $String(key), value) : value;\n      return isRawJSON(v) ? MARK + (push(rawStrings, v.rawJSON) - 1) : v;\n    }, space);\n\n    if (typeof json != 'string') return json;\n\n    var result = '';\n    var length = json.length;\n\n    for (var i = 0; i < length; i++) {\n      var chr = at(json, i);\n      if (chr === '\"') {\n        var end = parseJSONString(json, ++i).end - 1;\n        var string = slice(json, i, end);\n        result += slice(string, 0, MARK_LENGTH) === MARK\n          ? rawStrings[slice(string, MARK_LENGTH)]\n          : '\"' + string + '\"';\n        i = end;\n      } else result += chr;\n    }\n\n    return result;\n  }\n});\n", "'use strict';\n// https://github.com/tc39/proposal-json-parse-with-source\nrequire('../modules/esnext.json.is-raw-json');\nrequire('../modules/esnext.json.parse');\nrequire('../modules/esnext.json.raw-json');\n", "export function logAndThrow(message: string): never {\n    console.error(message);\n    throw new Error(message);\n}\n\n\nexport function parseJSON(json: string): any {\n    function revive(key: string, value: any, context: any) {\n        if (Number.isInteger(value)) {\n            return BigInt(context.source);\n        } else {\n            return value;\n        }\n    }\n\n    return JSON.parse(json, revive as any);\n}\n\n\nexport async function get(url: URL | string, options?: RequestInit) {\n    const response = await fetch(url, options);\n\n    if (!response.ok) {\n        throw new Error(response.status + \" could not get URL \" + url);\n    }\n\n    return response;\n}\n\n\nexport async function post(url: URL | string, options: RequestInit) {\n    options.method = \"POST\";\n\n    const response = await fetch(url, options);\n\n    if (!response.ok) {\n        throw new Error(response.status + \" could not post URL \" + url);\n    }\n\n    return response;\n}\n", "import { get, post, parseJSON, logAndThrow } from \"./utils\";\nimport { Account } from \"./account\";\nimport { BlockJSON } from \"./models/blockJSON\";\nimport { TransactionJSON } from \"./models/transaction/transactionJSON\";\nimport {\n  Address,\n  Plaintext,\n  RecordCiphertext,\n  Program,\n  RecordPlaintext,\n  PrivateKey,\n  Transaction,\n} from \"./wasm\";\nimport { ConfirmedTransactionJSON } from \"./models/confirmed_transaction\";\n\ntype ProgramImports = { [key: string]: string | Program };\n\ninterface AleoNetworkClientOptions {\n  headers?: { [key: string]: string };\n}\n\n/**\n * Client library that encapsulates REST calls to publicly exposed endpoints of Aleo nodes. The methods provided in this\n * allow users to query public information from the Aleo blockchain and submit transactions to the network.\n *\n * @param {string} host\n * @example\n * // Connection to a local node.\n * const localNetworkClient = new AleoNetworkClient(\"http://0.0.0.0:3030\", undefined, account);\n *\n * // Connection to a public beacon node\n * const account = Account.fromCiphertext(process.env.ciphertext, process.env.password);\n * const publicNetworkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined, account);\n */\nclass AleoNetworkClient {\n  host: string;\n  headers: { [key: string]: string };\n  account: Account | undefined;\n\n  constructor(host: string, options?: AleoNetworkClientOptions) {\n    this.host = host + \"/%%NETWORK%%\";\n\n    if (options && options.headers) {\n      this.headers = options.headers;\n\n    } else {\n      this.headers = {\n        // This is replaced by the actual version by a Rollup plugin\n        \"X-Aleo-SDK-Version\": \"%%VERSION%%\",\n      };\n    }\n  }\n\n  /**\n   * Set an account to use in networkClient calls\n   *\n   * @param {Account} account Set an account to use for record scanning functions.\n   * @example\n   * import { Account, AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\");\n   * const account = new Account();\n   * networkClient.setAccount(account);\n   */\n  setAccount(account: Account) {\n    this.account = account;\n  }\n\n  /**\n   * Return the Aleo account used in the networkClient\n   *\n   * @example\n   * const account = networkClient.getAccount();\n   */\n  getAccount(): Account | undefined {\n    return this.account;\n  }\n\n  /**\n   * Set a new host for the networkClient\n   *\n   * @param {string} host The address of a node hosting the Aleo API\n   * @param host\n   *\n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a networkClient that connects to a local node.\n   * const networkClient = new AleoNetworkClient(\"http://0.0.0.0:3030\", undefined);\n   *\n   * // Set the host to a public node.\n   * networkClient.setHost(\"http://api.explorer.provable.com/v1\");\n   */\n  setHost(host: string) {\n    this.host = host + \"/%%NETWORK%%\";\n  }\n\n  /**\n   * Fetches data from the Aleo network and returns it as a JSON object.\n   *\n   * @param url The URL to fetch data from.\n   */\n  async fetchData<Type>(\n      url = \"/\",\n  ): Promise<Type> {\n    try {\n      return parseJSON(await this.fetchRaw(url));\n    } catch (error) {\n      throw new Error(`Error fetching data: ${error}`);\n    }\n  }\n\n  /**\n   * Fetches data from the Aleo network and returns it as an unparsed string.\n   *\n   * This method should be used when it is desired to reconstitute data returned\n   * from the network into a WASM object.\n   *\n   * @param url\n   */\n  async fetchRaw(\n      url = \"/\",\n  ): Promise<string> {\n    try {\n      const response = await get(this.host + url, {\n        headers: this.headers\n      });\n      return await response.text();\n    } catch (error) {\n      throw new Error(`Error fetching data: ${error}`);\n    }\n  }\n\n  /**\n   * Attempt to find records in the Aleo blockchain.\n   *\n   * @param {number} startHeight - The height at which to start searching for unspent records\n   * @param {number} endHeight - The height at which to stop searching for unspent records\n   * @param {boolean} unspent - Whether to search for unspent records only\n   * @param {string[]} programs - The program(s) to search for unspent records in\n   * @param {number[]} amounts - The amounts (in microcredits) to search for (eg. [100, 200, 3000])\n   * @param {number} maxMicrocredits - The maximum number of microcredits to search for\n   * @param {string[]} nonces - The nonces of already found records to exclude from the search\n   * @param {string | PrivateKey} privateKey - An optional private key to use to find unspent records.\n   * @returns {Promise<Array<RecordPlaintext>>} An array of records belonging to the account configured in the network client.\n   *\n   * @example\n   * import { Account, AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Import an account from a ciphertext and password.\n   * const account = Account.fromCiphertext(process.env.ciphertext, process.env.password);\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   * networkClient.setAccount(account);\n   *\n   * // Find specific amounts\n   * const startHeight = 500000;\n   * const amounts = [600000, 1000000];\n   * const records = networkClient.findRecords(startHeight, undefined, true, [\"credits.aleo\"] amounts);\n   *\n   * // Find specific amounts with a maximum number of cumulative microcredits\n   * const maxMicrocredits = 100000;\n   * const records = networkClient.findRecords(startHeight, undefined, true, [\"credits.aleo\"] undefined, maxMicrocredits);\n   */\n  async findRecords(\n      startHeight: number,\n      endHeight: number | undefined,\n      unspent: boolean = false,\n      programs?: string[],\n      amounts?: number[] | undefined,\n      maxMicrocredits?: number | undefined,\n      nonces?: string[] | undefined,\n      privateKey?: string | PrivateKey | undefined,\n  ): Promise<Array<RecordPlaintext>> {\n    nonces = nonces || [];\n    // Ensure start height is not negative\n    if (startHeight < 0) {\n      throw new Error(\"Start height must be greater than or equal to 0\");\n    }\n\n    // Initialize search parameters\n    const records = new Array<RecordPlaintext>();\n    let start;\n    let end;\n    let resolvedPrivateKey: PrivateKey;\n    let failures = 0;\n    let totalRecordValue = BigInt(0);\n    let latestHeight: number;\n\n    // Ensure a private key is present to find owned records\n    if (typeof privateKey === \"undefined\") {\n      if (typeof this.account === \"undefined\") {\n        throw new Error(\"Private key must be specified in an argument to findOwnedRecords or set in the AleoNetworkClient\");\n      } else {\n        resolvedPrivateKey = this.account._privateKey;\n      }\n    } else {\n      try {\n        resolvedPrivateKey = privateKey instanceof PrivateKey ? privateKey : PrivateKey.from_string(privateKey);\n      } catch (error) {\n        throw new Error(\"Error parsing private key provided.\");\n      }\n    }\n    const viewKey = resolvedPrivateKey.to_view_key();\n\n    // Get the latest height to ensure the range being searched is valid\n    try {\n      const blockHeight = await this.getLatestHeight();\n      if (typeof blockHeight === \"number\") {\n        latestHeight = blockHeight;\n      } else {\n        throw new Error(`Error fetching latest block height: Expected type 'number' got '${typeof blockHeight}'`);\n      }\n    } catch (error) {\n      throw new Error(`Error fetching latest block height: ${error}`);\n    }\n\n    // If no end height is specified or is greater than the latest height, set the end height to the latest height\n    if (typeof endHeight === \"number\" && endHeight <= latestHeight) {\n      end = endHeight\n    } else {\n      end = latestHeight;\n    }\n\n    // If the starting is greater than the ending height, return an error\n    if (startHeight > end) {\n      throw new Error(\"Start height must be less than or equal to end height.\");\n    }\n\n    // Iterate through blocks in reverse order in chunks of 50\n    while (end > startHeight) {\n      start = end - 50;\n      if (start < startHeight) {\n        start = startHeight;\n      }\n      try {\n        // Get 50 blocks (or the difference between the start and end if less than 50)\n        const blocks = await this.getBlockRange(start, end);\n        end = start;\n        // Iterate through blocks to find unspent records\n        for (let i = 0; i < blocks.length; i++) {\n          const block = blocks[i];\n          const transactions = block.transactions;\n          if (!(typeof transactions === \"undefined\")) {\n            for (let j = 0; j < transactions.length; j++) {\n              const confirmedTransaction = transactions[j];\n              // Search for unspent records in execute transactions of credits.aleo\n              if (confirmedTransaction.type == \"execute\") {\n                const transaction = confirmedTransaction.transaction;\n                if (transaction.execution && !(typeof transaction.execution.transitions == \"undefined\")) {\n                  for (let k = 0; k < transaction.execution.transitions.length; k++) {\n                    const transition = transaction.execution.transitions[k];\n                    // Only search for unspent records in the specified programs.\n                    if (!(typeof programs === \"undefined\")) {\n                      if (!programs.includes(transition.program)) {\n                        continue;\n                      }\n                    }\n                    if (!(typeof transition.outputs == \"undefined\")) {\n                      for (let l = 0; l < transition.outputs.length; l++) {\n                        const output = transition.outputs[l];\n                        if (output.type === \"record\") {\n                          try {\n                            // Create a wasm record ciphertext object from the found output\n                            const record = RecordCiphertext.fromString(output.value);\n                            // Determine if the record is owned by the specified view key\n                            if (record.isOwner(viewKey)) {\n                              // Decrypt the record and get the serial number\n                              const recordPlaintext = record.decrypt(viewKey);\n\n                              // If the record has already been found, skip it\n                              const nonce = recordPlaintext.nonce();\n                              if (nonces.includes(nonce)) {\n                                continue;\n                              }\n\n                              if (unspent) {\n                                // Otherwise record the nonce that has been found\n                                const serialNumber = recordPlaintext.serialNumberString(resolvedPrivateKey, \"credits.aleo\", \"credits\");\n                                // Attempt to see if the serial number is spent\n                                try {\n                                  await this.getTransitionId(serialNumber);\n                                  continue;\n                                } catch (error) {\n                                  console.log(\"Found unspent record!\")\n                                }\n                              }\n\n                              // Add the record to the list of records if the user did not specify amounts.\n                              if (!amounts) {\n                                records.push(recordPlaintext);\n                                // If the user specified a maximum number of microcredits, check if the search has found enough\n                                if (typeof maxMicrocredits === \"number\") {\n                                  totalRecordValue += recordPlaintext.microcredits();\n                                  // Exit if the search has found the amount specified\n                                  if (totalRecordValue >= BigInt(maxMicrocredits)) {\n                                    return records;\n                                  }\n                                }\n                              }\n\n                              // If the user specified a list of amounts, check if the search has found them\n                              if (!(typeof amounts === \"undefined\") && amounts.length > 0) {\n                                let amounts_found = 0;\n                                if (recordPlaintext.microcredits() > amounts[amounts_found]) {\n                                  amounts_found += 1;\n                                  records.push(recordPlaintext);\n                                  // If the user specified a maximum number of microcredits, check if the search has found enough\n                                  if (typeof maxMicrocredits === \"number\") {\n                                    totalRecordValue += recordPlaintext.microcredits();\n                                    // Exit if the search has found the amount specified\n                                    if (totalRecordValue >= BigInt(maxMicrocredits)) {\n                                      return records;\n                                    }\n                                  }\n                                  if (records.length >= amounts.length) {\n                                    return records;\n                                  }\n                                }\n                              }\n                            }\n                          } catch (error) {\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      } catch (error) {\n        // If there is an error fetching blocks, log it and keep searching\n        console.warn(\"Error fetching blocks in range: \" + start.toString() + \"-\" + end.toString());\n        console.warn(\"Error: \", error);\n        failures += 1;\n        if (failures > 10) {\n          console.warn(\"10 failures fetching records reached. Returning records fetched so far\");\n          return records;\n        }\n      }\n    }\n    return records;\n  }\n\n  /**\n   * Attempts to find unspent records in the Aleo blockchain.\n   *\n   * @param {number} startHeight - The height at which to start searching for unspent records\n   * @param {number} endHeight - The height at which to stop searching for unspent records\n   * @param {string[]} programs - The program(s) to search for unspent records in\n   * @param {number[]} amounts - The amounts (in microcredits) to search for (eg. [100, 200, 3000])\n   * @param {number} maxMicrocredits - The maximum number of microcredits to search for\n   * @param {string[]} nonces - The nonces of already found records to exclude from the search\n   * @param {string | PrivateKey} privateKey - An optional private key to use to find unspent records.\n   * @returns {Promise<Array<RecordPlaintext>>} An array of unspent records belonging to the account configured in the network client.\n   *\n   * @example\n   * import { Account, AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * const account = Account.fromCiphertext(process.env.ciphertext, process.env.password);\n   *\n   * // Create a network client and set an account to search for records with.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   * networkClient.setAccount(account);\n   *\n   * // Find specific amounts\n   * const startHeight = 500000;\n   * const endHeight = 550000;\n   * const amounts = [600000, 1000000];\n   * const records = networkClient.findUnspentRecords(startHeight, endHeight, [\"credits.aleo\"], amounts);\n   *\n   * // Find specific amounts with a maximum number of cumulative microcredits\n   * const maxMicrocredits = 100000;\n   * const records = networkClient.findUnspentRecords(startHeight, undefined, [\"credits.aleo\"], undefined, maxMicrocredits);\n   */\n  async findUnspentRecords(\n      startHeight: number,\n      endHeight: number | undefined,\n      programs?: string[],\n      amounts?: number[] | undefined,\n      maxMicrocredits?: number | undefined,\n      nonces?: string[] | undefined,\n      privateKey?: string | PrivateKey | undefined,\n  ): Promise<Array<RecordPlaintext>> {\n    return await this.findRecords(startHeight, endHeight, true, programs, amounts, maxMicrocredits, nonces, privateKey);\n  }\n\n  /**\n   * Returns the contents of the block at the specified block height.\n   *\n   * @param {number} blockHeight - The height of the block to fetch\n   * @returns {Promise<BlockJSON>} A javascript object containing the block at the specified height\n   * \n   * @example\n   * const block = networkClient.getBlock(1234);\n   */\n  async getBlock(blockHeight: number): Promise<BlockJSON> {\n    try {\n      const block = await this.fetchData<BlockJSON>(\"/block/\" + blockHeight);\n      return block;\n    } catch (error) {\n      throw new Error(`Error fetching block ${blockHeight}: ${error}`);\n    }\n  }\n\n  /**\n   * Returns the contents of the block with the specified hash.\n   * \n   * @param {string} blockHash The hash of the block to fetch.\n   * @returns {Promise<BlockJSON>} A javascript object representation of the block matching the hash.\n   * \n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   * const block = networkClient.getBlockByHash(\"ab19dklwl9vp63zu3hwg57wyhvmqf92fx5g8x0t6dr72py8r87pxupqfne5t9\");\n   */\n  async getBlockByHash(blockHash: string): Promise<BlockJSON> {\n      try {\n        const block = await this.fetchData<BlockJSON>(`/block/${blockHash}`);\n        return block;\n      } catch (error) {\n        throw new Error(`Error fetching block ${blockHash}: ${error}`);\n      }\n  }\n\n  /**\n   * Returns a range of blocks between the specified block heights. A maximum of 50 blocks can be fetched at a time.\n   *\n   * @param {number} start Starting block to fetch.\n   * @param {number} end Ending block to fetch. This cannot be more than 50 blocks ahead of the start block.\n   * @returns {Promise<Array<BlockJSON>>} An array of block objects\n   *\n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Fetch 50 blocks.\n   * const (start, end) = (2050, 2100);\n   * const blockRange = networkClient.getBlockRange(start, end);\n   *\n   * let cursor = start;\n   * blockRange.forEach((block) => {\n   *   assert(block.height == cursor);\n   *   cursor += 1;\n   *  }\n   */\n  async getBlockRange(start: number, end: number): Promise<Array<BlockJSON>> {\n    try {\n      return await this.fetchData<Array<BlockJSON>>(\"/blocks?start=\" + start + \"&end=\" + end);\n    } catch (error) {\n      throw new Error(`Error fetching blocks between ${start} and ${end}: ${error}`);\n    }\n  }\n\n  /**\n   * Returns the deployment transaction id associated with the specified program.\n   *\n   * @param {Program | string} program The name of the deployed program OR a wasm Program object.\n   * @returns {Promise<string>} The transaction ID of the deployment transaction.\n   *\n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/testnet.js\";\n   *\n   * // Get the transaction ID of the deployment transaction for a program.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   * const transactionId = networkClient.getDeploymentTransactionIDForProgram(\"hello_hello.aleo\");\n   *\n   * // Get the transaction data for the deployment transaction.\n   * const transaction = networkClient.getTransactionObject(transactionId);\n   *\n   * // Get the verifying keys for the functions in the deployed program.\n   * const verifyingKeys = transaction.verifyingKeys();\n   */\n  async getDeploymentTransactionIDForProgram(program: Program | string): Promise<string> {\n    if (program instanceof Program) {\n      program = program.id();\n    }\n    try {\n      const id = await this.fetchData<string>(\"/find/transactionID/deployment/\" + program);\n      return id.replace(\"\\\"\", \"\")\n    } catch (error) {\n      throw new Error(`Error fetching deployment transaction for program ${program}: ${error}`);\n    }\n  }\n\n  /**\n   * Returns the deployment transaction associated with a specified program as a JSON object.\n   *\n   * @param {Program | string} program The name of the deployed program OR a wasm Program object.\n   * @returns {Promise<Transaction>} JSON representation of the deployment transaction.\n   *\n   * @example\n   * import { AleoNetworkClient, DeploymentJSON } from \"@provablehq/sdk/testnet.js\";\n   *\n   * // Get the transaction ID of the deployment transaction for a program.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   * const transaction = networkClient.getDeploymentTransactionForProgram(\"hello_hello.aleo\");\n   *\n   * // Get the verifying keys for each function in the deployment.\n   * const deployment = <DeploymentJSON>transaction.deployment;\n   * const verifyingKeys = deployment.verifying_keys;\n   */\n  async getDeploymentTransactionForProgram(program: Program | string): Promise<TransactionJSON> {\n    if (program instanceof Program) {\n      program = program.id();\n    }\n    try {\n      const transaction_id = <string>await this.getDeploymentTransactionIDForProgram(program);\n      return <TransactionJSON>await this.getTransaction(transaction_id);\n    } catch (error) {\n      throw new Error(`Error fetching deployment transaction for program ${program}: ${error}`);\n    }\n  }\n\n  /**\n   * Returns the deployment transaction associated with a specified program as a wasm object.\n   *\n   * @param {Program | string} program The name of the deployed program OR a wasm Program object.\n   * @returns {Promise<Transaction>} Wasm object representation of the deployment transaction.\n   *\n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/testnet.js\";\n   *\n   * // Get the transaction ID of the deployment transaction for a program.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   * const transactionId = networkClient.getDeploymentTransactionIDForProgram(\"hello_hello.aleo\");\n   *\n   * // Get the transaction data for the deployment transaction.\n   * const transaction = networkClient.getDeploymentTransactionObjectForProgram(transactionId);\n   *\n   * // Get the verifying keys for the functions in the deployed program.\n   * const verifyingKeys = transaction.verifyingKeys();\n   */\n  async getDeploymentTransactionObjectForProgram(program: Program | string): Promise<Transaction> {\n    try {\n      const transaction_id = <string>await this.getDeploymentTransactionIDForProgram(program);\n      return await this.getTransactionObject(transaction_id);\n    } catch (error) {\n      throw new Error(`Error fetching deployment transaction for program ${program}: ${error}`);\n    }\n  }\n\n  /**\n   * Returns the contents of the latest block as JSON.\n   *\n   * @returns {Promise<BlockJSON>} A javascript object containing the latest block\n   * \n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/testnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   *\n   * const latestHeight = networkClient.getLatestBlock();\n   */\n  async getLatestBlock(): Promise<BlockJSON> {\n    try {\n      return await this.fetchData<BlockJSON>(\"/block/latest\") as BlockJSON;\n    } catch (error) {\n      throw new Error(`Error fetching latest block: ${error}`);\n    }\n  }\n\n  /**\n   * Returns the latest committee.\n   *\n   * @returns {Promise<object>} A javascript object containing the latest committee\n   * \n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   * \n   * // Create a network client and get the latest committee.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   * const latestCommittee = await networkClient.getLatestCommittee();\n   */\n  async getLatestCommittee(): Promise<object> {\n    try {\n      return await this.fetchData<object>(\"/committee/latest\");\n    } catch (error) {\n      throw new Error(`Error fetching latest committee: ${error}`);\n    }\n  }\n\n  /**\n   * Returns the committee at the specified block height.\n   * \n   * @param {number} blockHeight - The height of the block to fetch the committee for\n   * @returns {Promise<object>} A javascript object containing the committee\n   * \n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   * \n   * // Create a network client and get the committee for a specific block.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   * const committee = await networkClient.getCommitteeByBlockHeight(1234);\n   */\n  async getCommitteeByBlockHeight(blockHeight: number): Promise<object> {\n    try {\n      return await this.fetchData<object>(`/committee/${blockHeight}`);\n    } catch (error) {\n      throw new Error(`Error fetching committee at height ${blockHeight}: ${error}`);\n    }\n  }\n\n  /**\n   * Returns the latest block height.\n   *\n   * @returns {Promise<number>} The latest block height.\n   *\n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   *\n   * const latestHeight = networkClient.getLatestHeight();\n   */\n  async getLatestHeight(): Promise<number> {\n    try {\n      return Number(await this.fetchData<bigint>(\"/block/height/latest\"));\n    } catch (error) {\n      throw new Error(`Error fetching latest height: ${error}`);\n    }\n  }\n\n  /**\n   * Returns the latest block hash.\n   *\n   * @returns {Promise<string>} The latest block hash.\n   * \n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   *\n   * // Get the latest block hash.\n   * const latestHash = networkClient.getLatestBlockHash();\n   */\n  async getLatestBlockHash(): Promise<string> {\n    try {\n      return String(await this.fetchData<string>(\"/block/hash/latest\"));\n    } catch (error) {\n      throw new Error(`Error fetching latest hash: ${error}`);\n    }\n  }\n\n  /**\n   * Returns the source code of a program given a program ID.\n   *\n   * @param {string} programId The program ID of a program deployed to the Aleo Network\n   * @returns {Promise<string>} Source code of the program\n   *\n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   *\n   * const program = networkClient.getProgram(\"hello_hello.aleo\");\n   * const expectedSource = \"program hello_hello.aleo;\\n\\nfunction hello:\\n    input r0 as u32.public;\\n    input r1 as u32.private;\\n    add r0 r1 into r2;\\n    output r2 as u32.private;\\n\"\n   * assert.equal(program, expectedSource);\n   */\n  async getProgram(programId: string): Promise<string> {\n    try {\n      return await this.fetchData<string>(\"/program/\" + programId)\n    } catch (error) {\n      throw new Error(`Error fetching program ${programId}: ${error}`);\n    }\n  }\n\n  /**\n   * Returns a program object from a program ID or program source code.\n   *\n   * @param {string} inputProgram The program ID or program source code of a program deployed to the Aleo Network\n   * @returns {Promise<Program>} Source code of the program\n   *\n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   *\n   * const programID = \"hello_hello.aleo\";\n   * const programSource = \"program hello_hello.aleo;\\n\\nfunction hello:\\n    input r0 as u32.public;\\n    input r1 as u32.private;\\n    add r0 r1 into r2;\\n    output r2 as u32.private;\\n\"\n   *\n   * // Get program object from program ID or program source code\n   * const programObjectFromID = await networkClient.getProgramObject(programID);\n   * const programObjectFromSource = await networkClient.getProgramObject(programSource);\n   *\n   * // Both program objects should be equal\n   * assert(programObjectFromID.to_string() === programObjectFromSource.to_string());\n   */\n  async getProgramObject(inputProgram: string): Promise<Program> {\n    try {\n      return Program.fromString(inputProgram);\n    } catch (error) {\n      try {\n        return Program.fromString(<string>(await this.getProgram(inputProgram)));\n      } catch (error) {\n        throw new Error(`${inputProgram} is neither a program name or a valid program: ${error}`);\n      }\n    }\n  }\n\n  /**\n   *  Returns an object containing the source code of a program and the source code of all programs it imports\n   *\n   * @param {Program | string} inputProgram The program ID or program source code of a program deployed to the Aleo Network\n   * @returns {Promise<ProgramImports>} Object of the form { \"program_id\": \"program_source\", .. } containing program id & source code for all program imports\n   *\n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   * \n   * const double_test_source = \"import multiply_test.aleo;\\n\\nprogram double_test.aleo;\\n\\nfunction double_it:\\n    input r0 as u32.private;\\n    call multiply_test.aleo/multiply 2u32 r0 into r1;\\n    output r1 as u32.private;\\n\"\n   * const double_test = Program.fromString(double_test_source);\n   * const expectedImports = {\n   *     \"multiply_test.aleo\": \"program multiply_test.aleo;\\n\\nfunction multiply:\\n    input r0 as u32.public;\\n    input r1 as u32.private;\\n    mul r0 r1 into r2;\\n    output r2 as u32.private;\\n\"\n   * }\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   *\n   * // Imports can be fetched using the program ID, source code, or program object\n   * let programImports = await networkClient.getProgramImports(\"double_test.aleo\");\n   * assert.deepStrictEqual(programImports, expectedImports);\n   *\n   * // Using the program source code\n   * programImports = await networkClient.getProgramImports(double_test_source);\n   * assert.deepStrictEqual(programImports, expectedImports);\n   *\n   * // Using the program object\n   * programImports = await networkClient.getProgramImports(double_test);\n   * assert.deepStrictEqual(programImports, expectedImports);\n   */\n  async getProgramImports(inputProgram: Program | string): Promise<ProgramImports> {\n    try {\n      const imports: ProgramImports = {};\n\n      // Get the program object or fail if the program is not valid or does not exist\n      const program = inputProgram instanceof Program ? inputProgram : <Program>(await this.getProgramObject(inputProgram));\n\n      // Get the list of programs that the program imports\n      const importList = program.getImports();\n\n      // Recursively get any imports that the imported programs have in a depth first search order\n      for (let i = 0; i < importList.length; i++) {\n        const import_id = importList[i];\n        if (!imports.hasOwnProperty(import_id)) {\n          const programSource = <string>await this.getProgram(import_id);\n          const nestedImports = <ProgramImports>await this.getProgramImports(import_id);\n          for (const key in nestedImports) {\n            if (!imports.hasOwnProperty(key)) {\n              imports[key] = nestedImports[key];\n            }\n          }\n          imports[import_id] = programSource;\n        }\n      }\n      return imports;\n    } catch (error: any) {\n      logAndThrow(\"Error fetching program imports: \" + error.message);\n    }\n  }\n\n  /**\n   * Get a list of the program names that a program imports.\n   *\n   * @param {Program | string} inputProgram - The program id or program source code to get the imports of\n   * @returns {string[]} - The list of program names that the program imports\n   *\n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   *\n   * const programImportsNames = networkClient.getProgramImports(\"wrapped_credits.aleo\");\n   * const expectedImportsNames = [\"credits.aleo\"];\n   * assert.deepStrictEqual(programImportsNames, expectedImportsNames);\n   */\n  async getProgramImportNames(inputProgram: Program | string): Promise<string[]> {\n    try {\n      const program = inputProgram instanceof Program ? inputProgram : <Program>(await this.getProgramObject(inputProgram));\n      return program.getImports();\n    } catch (error: any) {\n      throw new Error(`Error fetching imports for program ${inputProgram instanceof Program ? inputProgram.id() : inputProgram}: ${error.message}`);\n    }\n  }\n\n  /**\n   * Returns the names of the mappings of a program.\n   *\n   * @param {string} programId - The program ID to get the mappings of (e.g. \"credits.aleo\")\n   * @returns {Promise<Array<string>>} - The names of the mappings of the program.\n   *\n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   *\n   * const mappings = networkClient.getProgramMappingNames(\"credits.aleo\");\n   * const expectedMappings = [\n   *   \"committee\",\n   *   \"delegated\",\n   *   \"metadata\",\n   *   \"bonded\",\n   *   \"unbonding\",\n   *   \"account\",\n   *   \"withdraw\"\n   * ];\n   * assert.deepStrictEqual(mappings, expectedMappings);\n   */\n  async getProgramMappingNames(programId: string): Promise<Array<string>> {\n    try {\n      return await this.fetchData<Array<string>>(`/program/${programId}/mappings`)\n    } catch (error) {\n      throw new Error(`Error fetching mappings for program ${programId} - ensure the program exists on chain before trying again`);\n    }\n  }\n\n  /**\n   * Returns the value of a program's mapping for a specific key.\n   *\n   * @param {string} programId - The program ID to get the mapping value of (e.g. \"credits.aleo\")\n   * @param {string} mappingName - The name of the mapping to get the value of (e.g. \"account\")\n   * @param {string | Plaintext} key - The key to look up in the mapping (e.g. an address for the \"account\" mapping)\n   * @returns {Promise<string>} String representation of the value of the mapping\n   *\n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   *\n   * // Get public balance of an account\n   * const mappingValue = networkClient.getMappingValue(\"credits.aleo\", \"account\", \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\");\n   * const expectedValue = \"0u64\";\n   * assert(mappingValue === expectedValue);\n   */\n  async getProgramMappingValue(programId: string, mappingName: string, key: string | Plaintext): Promise<string> {\n    try {\n      const keyString = key instanceof Plaintext ? key.toString() : key;\n      return await this.fetchData<string>(`/program/${programId}/mapping/${mappingName}/${keyString}`);\n    } catch (error) {\n      throw new Error(`Error fetching value for key '${key}' in mapping '${mappingName}' in program '${programId}' - ensure the mapping exists and the key is correct`);\n    }\n  }\n\n\n  /**\n   * Returns the value of a mapping as a wasm Plaintext object. Returning an object in this format allows it to be converted to a Js type and for its internal members to be inspected if it's a struct or array.\n   *\n   * @param {string} programId - The program ID to get the mapping value of (e.g. \"credits.aleo\")\n   * @param {string} mappingName - The name of the mapping to get the value of (e.g. \"bonded\")\n   * @param {string | Plaintext} key - The key to look up in the mapping (e.g. an address for the \"bonded\" mapping)\n   * @returns {Promise<Plaintext>} String representation of the value of the mapping\n   *\n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   *\n   * // Get the bond state as an account.\n   * const unbondedState = networkClient.getMappingPlaintext(\"credits.aleo\", \"bonded\", \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\");\n   *\n   * // Get the two members of the object individually.\n   * const validator = unbondedState.getMember(\"validator\");\n   * const microcredits = unbondedState.getMember(\"microcredits\");\n   *\n   * // Ensure the expected values are correct.\n   * assert.equal(validator, \"aleo1u6940v5m0fzud859xx2c9tj2gjg6m5qrd28n636e6fdd2akvfcgqs34mfd\");\n   * assert.equal(microcredits, BigInt(\"9007199254740991\"));\n   *\n   * // Get a JS object representation of the unbonded state.\n   * const unbondedStateObject = unbondedState.toObject();\n   *\n   * const expectedState = {\n   *     validator: \"aleo1u6940v5m0fzud859xx2c9tj2gjg6m5qrd28n636e6fdd2akvfcgqs34mfd\",\n   *     microcredits: BigInt(9007199254740991)\n   * };\n   * assert.equal(unbondedState, expectedState);\n   */\n  async getProgramMappingPlaintext(programId: string, mappingName: string, key: string | Plaintext): Promise<Plaintext> {\n    try {\n      const keyString = key instanceof Plaintext ? key.toString() : key;\n      const value = await this.fetchRaw(`/program/${programId}/mapping/${mappingName}/${keyString}`);\n      return Plaintext.fromString(JSON.parse(value));\n    } catch (error) {\n      throw new Error(\"Failed to fetch mapping value.\" + error);\n    }\n  }\n\n  /**\n   * Returns the public balance of an address from the account mapping in credits.aleo\n   * \n   * @param {Address | string} address A string or wasm object representing an address.\n   * @returns {Promise<number>} The public balance of the address in microcredits.\n   * \n   * @example\n   * import { AleoNetworkClient, Account } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   *\n   * // Get the balance of an account from either an address object or address string.\n   * const account = Account.fromCiphertext(process.env.ciphertext, process.env.password);\n   * const publicBalance = await networkClient.getPublicBalance(account.address());\n   * const publicBalanceFromString = await networkClient.getPublicBalance(account.address().to_string());\n   * assert(publicBalance === publicBalanceFromString);\n   */\n  async getPublicBalance(address: Address | string): Promise<number> {\n    try {\n      const addressString = address instanceof Address ? address.to_string() : address;\n      const balanceStr = await this.getProgramMappingValue('credits.aleo', 'account', addressString);\n      return balanceStr ? parseInt(balanceStr) : 0;\n    } catch (error) {\n      throw new Error(`Error fetching public balance for ${address}: ${error}`);\n    }\n  }\n\n  /**\n   * Returns the latest state/merkle root of the Aleo blockchain.\n   * \n   * @returns {Promise<string>} A string representing the latest state root of the Aleo blockchain.\n   * \n   * @example\n   * import { AleoNetworkClient, Account } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   *\n   * // Get the latest state root.\n   * const stateRoot = networkClient.getStateRoot();\n   */\n  async getStateRoot(): Promise<string> {\n    try {\n      return await this.fetchData<string>('/stateRoot/latest');\n    } catch (error) {\n      throw new Error(`Error fetching latest state root: ${error}`);\n    }\n  }\n\n  /**\n   * Returns a transaction by its unique identifier.\n   *\n   * @param {string} transactionId The transaction ID to fetch.\n   * @returns {Promise<TransactionJSON>} A json representation of the transaction.\n   * \n   * @example\n   * import { AleoNetworkClient, Account } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   *\n   * const transaction = networkClient.getTransaction(\"at1handz9xjrqeynjrr0xay4pcsgtnczdksz3e584vfsgaz0dh0lyxq43a4wj\");\n   */\n  async getTransaction(transactionId: string): Promise<TransactionJSON> {\n    try {\n    return await this.fetchData<TransactionJSON>(\"/transaction/\" + transactionId);\n    } catch (error) {\n      throw new Error(`Error fetching transaction ${transactionId}: ${error}`);\n    }\n  }\n\n  /**\n   * Returns a confirmed transaction by its unique identifier.\n   * \n   * @param {string} transactionId The transaction ID to fetch.\n   * @returns {Promise<ConfirmedTransactionJSON>} A json object containing the confirmed transaction.\n   * \n   * @example\n   * import { AleoNetworkClient, Account } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   * \n   * const transaction = networkClient.getConfirmedTransaction(\"at1handz9xjrqeynjrr0xay4pcsgtnczdksz3e584vfsgaz0dh0lyxq43a4wj\");\n   * assert.equal(transaction.status, \"confirmed\");\n   */\n  async getConfirmedTransaction(transactionId: string): Promise<ConfirmedTransactionJSON> {\n    try {\n      return await this.fetchData<ConfirmedTransactionJSON>(`/transaction/confirmed/${transactionId}`);\n    } catch (error) {\n      throw new Error(`Error fetching confirmed transaction ${transactionId}: ${error}`);\n    }\n  }\n\n  /**\n   * Returns a transaction as a wasm object. Getting a transaction of this type will allow the ability for the inputs,\n   * outputs, and records to be searched for and displayed.\n   * \n   * @param {string} transactionId - The unique identifier of the transaction to fetch\n   * @returns {Promise<Transaction>} A wasm object representation of the transaction.\n   *\n   * @example\n   * const transactionObject = networkClient.getTransaction(\"at1handz9xjrqeynjrr0xay4pcsgtnczdksz3e584vfsgaz0dh0lyxq43a4wj\");\n   * // Get the transaction inputs as a JS array.\n   * const transactionInputs = transactionObject.inputs(true);\n   *\n   * // Get the transaction outputs as a JS object.\n   * const transactionOutputs = transactionObject.outputs(true);\n   *\n   * // Get any records generated in transitions in the transaction as a JS object.\n   * const records = transactionObject.records();\n   *\n   * // Get the transaction type.\n   * const transactionType = transactionObject.transactionType();\n   * assert.equal(transactionType, \"Execute\");\n   *\n   * // Get a JS representation of all inputs, outputs, and transaction metadata.\n   * const transactionSummary = transactionObject.summary();\n   */\n  async getTransactionObject(transactionId: string): Promise<Transaction> {\n    try {\n      const transaction = await this.fetchRaw(\"/transaction/\" + transactionId);\n      return Transaction.fromString(transaction);\n    } catch (error) {\n      throw new Error(`Error fetching transaction object ${transactionId}: ${error}`);\n    }\n  }\n\n  /**\n   * Returns the transactions present at the specified block height.\n   *\n   * @param {number} blockHeight The block height to fetch the confirmed transactions at.\n   * @returns {Promise<Array<ConfirmedTransactionJSON>>} An array of confirmed transactions (in JSON format) for the block height.\n   *\n   * @example\n   * import { AleoNetworkClient, Account } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   *\n   * const transactions = networkClient.getTransactions(654);\n   */\n  async getTransactions(blockHeight: number): Promise<Array<ConfirmedTransactionJSON>> {\n    try {\n      return await this.fetchData<Array<ConfirmedTransactionJSON>>(\"/block/\" + blockHeight.toString() + \"/transactions\");\n    } catch (error) {\n      throw new Error(`Error fetching transactions: ${error}`);\n    }\n  }\n\n  /**\n   * Returns the confirmed transactions present in the block with the specified block hash.\n   *\n   * @param {string} blockHash The block hash to fetch the confirmed transactions at.\n   * @returns {Promise<Array<ConfirmedTransactionJSON>>} An array of confirmed transactions (in JSON format) for the block hash.\n   *\n   * @example\n   * import { AleoNetworkClient, Account } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   *\n   * const transactions = networkClient.getTransactionsByBlockHash(\"ab19dklwl9vp63zu3hwg57wyhvmqf92fx5g8x0t6dr72py8r87pxupqfne5t9\");\n   */\n  async getTransactionsByBlockHash(blockHash: string): Promise<Array<ConfirmedTransactionJSON>> {\n    try {\n      const block = await this.fetchData<BlockJSON>(`/block/${blockHash}`);\n      const height = block.header.metadata.height;\n      return await this.getTransactions(Number(height));\n    } catch (error) {\n      throw new Error(`Error fetching transactions for block ${blockHash}: ${error}`);\n    }\n  }\n\n  /**\n   * Returns the transactions in the memory pool. This method requires access to a validator's REST API.\n   *\n   * @returns {Promise<Array<TransactionJSON>>} An array of transactions (in JSON format) currently in the mempool.\n   *\n   * @example\n   * import { AleoNetworkClient, Account } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   *\n   * // Get the current transactions in the mempool.\n   * const transactions = networkClient.getTransactionsInMempool();\n   */\n  async getTransactionsInMempool(): Promise<Array<TransactionJSON>> {\n    try {\n      return await this.fetchData<Array<TransactionJSON>>(\"/memoryPool/transactions\");\n    } catch (error) {\n      throw new Error(`Error fetching transactions from mempool: ${error}`);\n    }\n  }\n\n  /**\n   * Returns the transition ID of the transition corresponding to the ID of the input or output.\n   * @param {string} inputOrOutputID - The unique identifier of the input or output to find the transition ID for\n   * @returns {Promise<string>} - The transition ID of the input or output ID.\n   *\n   * @example\n   * const transitionId = networkClient.getTransitionId(\"2429232855236830926144356377868449890830704336664550203176918782554219952323field\");\n   */\n  async getTransitionId(inputOrOutputID: string): Promise<string> {\n    try {\n      return await this.fetchData<string>(\"/find/transitionID/\" + inputOrOutputID);\n    } catch (error) {\n      throw new Error(`Error fetching transition ID for input/output ${inputOrOutputID}: ${error}`);\n    }\n  }\n\n  /**\n   * Submit an execute or deployment transaction to the Aleo network.\n   *\n   * @param {Transaction | string} transaction - The transaction to submit, either as a Transaction object or string representation\n   * @returns {Promise<string>} - The transaction id of the submitted transaction or the resulting error\n   */\n  async submitTransaction(transaction: Transaction | string): Promise<string> {\n    const transaction_string = transaction instanceof Transaction ? transaction.toString() : transaction;\n    try {\n      const response = await post(this.host + \"/transaction/broadcast\", {\n        body: transaction_string,\n        headers: Object.assign({}, this.headers, {\n          \"Content-Type\": \"application/json\",\n        }),\n      });\n\n      try {\n        const text = await response.text();\n        return parseJSON(text);\n\n      } catch (error: any) {\n        throw new Error(`Error posting transaction. Aleo network response: ${error.message}`);\n      }\n    } catch (error: any) {\n      throw new Error(`Error posting transaction: No response received: ${error.message}`);\n    }\n  }\n\n  /**\n   * Submit a solution to the Aleo network.\n   *\n   * @param {string} solution - The string representation of the solution to submit\n   * @returns {Promise<string>} The solution id of the submitted solution or the resulting error.\n   */\n  async submitSolution(solution: string): Promise<string> {\n    try {\n      const response = await post(this.host + \"/solution/broadcast\", {\n        body: solution,\n        headers: Object.assign({}, this.headers, {\n          \"Content-Type\": \"application/json\",\n        }),\n      });\n\n      try {\n        const text = await response.text();\n        return parseJSON(text);\n\n      } catch (error: any) {\n        throw new Error(`Error posting transaction. Aleo network response: ${error.message}`);\n      }\n    } catch (error: any) {\n      throw new Error(`Error posting transaction: No response received: ${error.message}`);\n    }\n  }\n\n  /**\n   * Await a submitted transaction to be confirmed or rejected on the Aleo network.\n   *\n   * @param {string} transactionId - The transaction ID to wait for confirmation\n   * @param {number} checkInterval - The interval in milliseconds to check for confirmation (default: 2000)\n   * @param {number} timeout - The maximum time in milliseconds to wait for confirmation (default: 45000)\n   * @returns {Promise<Transaction>} The confirmed transaction object that returns if the transaction is confirmed.\n   *\n   * @example\n   * import { AleoNetworkClient, Account, ProgramManager } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client and program manager.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   * const programManager = new ProgramManager(networkClient);\n   *\n   * // Set the account for the program manager.\n   * programManager.setAccount(Account.fromCiphertext(process.env.ciphertext, process.env.password));\n   *\n   * // Build a transfer transaction.\n   * const tx = await programManager.buildTransferPublicTransaction(100, \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\", 0);\n   *\n   * // Submit the transaction to the network.\n   * const transactionId = await networkClient.submitTransaction(tx);\n   *\n   * // Wait for the transaction to be confirmed.\n   * const transaction = await networkClient.waitForTransactionConfirmation(transactionId);\n   */\n  async waitForTransactionConfirmation(\n      transactionId: string,\n      checkInterval: number = 2000,  // Poll every 2 seconds\n      timeout: number = 45000        // Timeout after 45 seconds\n  ): Promise<Transaction> {\n    const startTime = Date.now();\n\n    return new Promise<Transaction>((resolve, reject) => {\n      const interval = setInterval(async () => {\n        try {\n          // Replace with actual Aleo transaction lookup API\n          const transaction = <Transaction>await this.getTransactionObject(transactionId);\n          resolve(transaction);\n          if (Date.now() - startTime > timeout) {\n            clearInterval(interval);\n            reject(new Error(\"Transaction confirmation timed out\"));\n          }\n        } catch (error) {\n          console.error(\"Error checking transaction:\", error);\n        }\n      }, checkInterval);\n    });\n  }\n}\n\nexport { AleoNetworkClient, AleoNetworkClientOptions, ProgramImports }\n", "import {VerifyingKey, Metadata} from \"./wasm\";\n\nexport const KEY_STORE = Metadata.baseUrl();\n\nexport interface Key {\n    name: string,\n    locator: string,\n    prover: string,\n    verifier: string,\n    verifyingKey: () => VerifyingKey,\n}\n\nfunction convert(metadata: Metadata): Key {\n    // This looks up the method name in VerifyingKey\n    const verifyingKey = (VerifyingKey as any)[metadata.verifyingKey];\n\n    if (!verifyingKey) {\n        throw new Error(\"Invalid method name: \" + metadata.verifyingKey);\n    }\n\n    return {\n        name: metadata.name,\n        locator: metadata.locator,\n        prover: metadata.prover,\n        verifier: metadata.verifier,\n        verifyingKey,\n    };\n}\n\nexport const CREDITS_PROGRAM_KEYS = {\n    bond_public: convert(Metadata.bond_public()),\n    bond_validator: convert(Metadata.bond_validator()),\n    claim_unbond_public: convert(Metadata.claim_unbond_public()),\n    fee_private: convert(Metadata.fee_private()),\n    fee_public: convert(Metadata.fee_public()),\n    inclusion: convert(Metadata.inclusion()),\n    join: convert(Metadata.join()),\n    set_validator_state: convert(Metadata.set_validator_state()),\n    split: convert(Metadata.split()),\n    transfer_private: convert(Metadata.transfer_private()),\n    transfer_private_to_public: convert(Metadata.transfer_private_to_public()),\n    transfer_public: convert(Metadata.transfer_public()),\n    transfer_public_as_signer: convert(Metadata.transfer_public_as_signer()),\n    transfer_public_to_private: convert(Metadata.transfer_public_to_private()),\n    unbond_public: convert(Metadata.unbond_public()),\n    getKey: function(key: string): Key {\n        if (this.hasOwnProperty(key)) {\n            return (this as any)[key] as Key;\n        } else {\n            throw new Error(`Key \"${key}\" not found.`);\n        }\n    }\n};\n\nexport const PRIVATE_TRANSFER_TYPES = new Set([\n    \"transfer_private\",\n    \"private\",\n    \"transferPrivate\",\n    \"transfer_private_to_public\",\n    \"privateToPublic\",\n    \"transferPrivateToPublic\",\n]);\n\nexport const VALID_TRANSFER_TYPES = new Set([\n    \"transfer_private\",\n    \"private\",\n    \"transferPrivate\",\n    \"transfer_private_to_public\",\n    \"privateToPublic\",\n    \"transferPrivateToPublic\",\n    \"transfer_public\",\n    \"transfer_public_as_signer\",\n    \"public\",\n    \"public_as_signer\",\n    \"transferPublic\",\n    \"transferPublicAsSigner\",\n    \"transfer_public_to_private\",\n    \"publicToPrivate\",\n    \"publicAsSigner\",\n    \"transferPublicToPrivate\",\n]);\n\nexport const PRIVATE_TRANSFER = new Set([\n    \"private\",\n    \"transfer_private\",\n    \"transferPrivate\",\n]);\n\nexport const PRIVATE_TO_PUBLIC_TRANSFER = new Set([\n    \"private_to_public\",\n    \"privateToPublic\",\n    \"transfer_private_to_public\",\n    \"transferPrivateToPublic\",\n]);\n\nexport const PUBLIC_TRANSFER = new Set([\n    \"public\",\n    \"transfer_public\",\n    \"transferPublic\",\n]);\n\nexport const PUBLIC_TRANSFER_AS_SIGNER = new Set([\n    \"public_as_signer\",\n    \"transfer_public_as_signer\",\n    \"transferPublicAsSigner\",\n]);\n\nexport const PUBLIC_TO_PRIVATE_TRANSFER = new Set([\n    \"public_to_private\",\n    \"publicToPrivate\",\n    \"transfer_public_to_private\",\n    \"transferPublicToPrivate\",\n]);\n", "import {\n    CREDITS_PROGRAM_KEYS,\n    KEY_STORE,\n    Key,\n    PRIVATE_TRANSFER,\n    PRIVATE_TO_PUBLIC_TRANSFER,\n    PUBLIC_TRANSFER,\n    PUBLIC_TO_PRIVATE_TRANSFER,\n    PUBLIC_TRANSFER_AS_SIGNER,\n} from \"./constants\";\n\nimport {\n    ProvingKey,\n    VerifyingKey,\n} from \"./wasm\";\n\nimport { get } from \"./utils\";\n\ntype FunctionKeyPair = [ProvingKey, VerifyingKey];\ntype CachedKeyPair = [Uint8Array, Uint8Array];\ntype AleoKeyProviderInitParams = {\n    proverUri?: string;\n    verifierUri?: string;\n    cacheKey?: string;\n};\n\n/**\n * Interface for record search parameters. This allows for arbitrary search parameters to be passed to record provider\n * implementations.\n */\ninterface KeySearchParams {\n    [key: string]: any; // This allows for arbitrary keys with any type values\n}\n\n/**\n * AleoKeyProviderParams search parameter for the AleoKeyProvider. It allows for the specification of a proverUri and\n * verifierUri to fetch keys via HTTP from a remote resource as well as a unique cacheKey to store the keys in memory.\n */\nclass AleoKeyProviderParams implements KeySearchParams {\n    name: string | undefined;\n    proverUri: string | undefined;\n    verifierUri: string | undefined;\n    cacheKey: string | undefined;\n\n    /**\n     * Create a new AleoKeyProviderParams object which implements the KeySearchParams interface. Users can optionally\n     * specify a url for the proverUri & verifierUri to fetch keys via HTTP from a remote resource as well as a unique\n     * cacheKey to store the keys in memory for future use. If no proverUri or verifierUri is specified, a cachekey must\n     * be provided.\n     *\n     * @param { AleoKeyProviderInitParams } params - Optional search parameters\n     */\n    constructor(params: {proverUri?: string, verifierUri?: string, cacheKey?: string, name?: string}) {\n        this.proverUri = params.proverUri;\n        this.verifierUri = params.verifierUri;\n        this.cacheKey = params.cacheKey;\n        this.name = params.name;\n    }\n}\n\n/**\n * KeyProvider interface. Enables the retrieval of public proving and verifying keys for Aleo Programs.\n */\ninterface FunctionKeyProvider {\n    /**\n     * Get bond_public function keys from the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the bond_public function\n     */\n    bondPublicKeys(): Promise<FunctionKeyPair>;\n\n    /**\n     * Get bond_validator function keys from the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the bond_validator function\n     */\n    bondValidatorKeys(): Promise<FunctionKeyPair>;\n\n    /**\n     * Cache a set of keys. This will overwrite any existing keys with the same keyId. The user can check if a keyId\n     * exists in the cache using the containsKeys method prior to calling this method if overwriting is not desired.\n     *\n     * @param {string} keyId access key for the cache\n     * @param {FunctionKeyPair} keys keys to cache\n     */\n    cacheKeys(keyId: string, keys: FunctionKeyPair): void;\n\n    /**\n     * Get unbond_public function keys from the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the unbond_public function\n     */\n    claimUnbondPublicKeys(): Promise<FunctionKeyPair>;\n\n    /**\n     * Get arbitrary function keys from a provider\n     *\n     * @param {KeySearchParams | undefined} params - Optional search parameters for the key provider\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the specified program\n     *\n     * @example\n     * // Create a search object which implements the KeySearchParams interface\n     * class IndexDbSearch implements KeySearchParams {\n     *     db: string\n     *     keyId: string\n     *     constructor(params: {db: string, keyId: string}) {\n     *         this.db = params.db;\n     *         this.keyId = params.keyId;\n     *     }\n     * }\n     *\n     * // Create a new object which implements the KeyProvider interface\n     * class IndexDbKeyProvider implements FunctionKeyProvider {\n     *     async functionKeys(params: KeySearchParams): Promise<FunctionKeyPair> {\n     *         return new Promise((resolve, reject) => {\n     *             const request = indexedDB.open(params.db, 1);\n     *\n     *             request.onupgradeneeded = function(e) {\n     *                 const db = e.target.result;\n     *                 if (!db.objectStoreNames.contains('keys')) {\n     *                     db.createObjectStore('keys', { keyPath: 'id' });\n     *                 }\n     *             };\n     *\n     *             request.onsuccess = function(e) {\n     *                 const db = e.target.result;\n     *                 const transaction = db.transaction([\"keys\"], \"readonly\");\n     *                 const store = transaction.objectStore(\"keys\");\n     *                 const request = store.get(params.keyId);\n     *                 request.onsuccess = function(e) {\n     *                     if (request.result) {\n     *                         resolve(request.result as FunctionKeyPair);\n     *                     } else {\n     *                         reject(new Error(\"Key not found\"));\n     *                     }\n     *                 };\n     *                 request.onerror = function(e) { reject(new Error(\"Error fetching key\")); };\n     *             };\n     *\n     *             request.onerror = function(e) { reject(new Error(\"Error opening database\")); };\n     *         });\n     *     }\n     *\n     *     // implement the other methods...\n     * }\n     *\n     *\n     * const keyProvider = new AleoKeyProvider();\n     * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for value transfers\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * programManager.transfer(1, \"aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at\", \"public\", 0.5);\n     *\n     * // Keys can also be fetched manually\n     * const searchParams = new IndexDbSearch({db: \"keys\", keyId: \"credits.aleo:transferPrivate\"});\n     * const [transferPrivateProvingKey, transferPrivateVerifyingKey] = await keyProvider.functionKeys(searchParams);\n     */\n    functionKeys(params?: KeySearchParams): Promise<FunctionKeyPair>;\n\n    /**\n     * Get fee_private function keys from the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function\n     */\n    feePrivateKeys(): Promise<FunctionKeyPair>;\n\n    /**\n     * Get fee_public function keys from the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function\n     */\n    feePublicKeys(): Promise<FunctionKeyPair>;\n\n    /**\n     * Get join function keys from the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function\n     */\n    joinKeys(): Promise<FunctionKeyPair>;\n\n    /**\n     * Get split function keys from the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function\n     */\n    splitKeys(): Promise<FunctionKeyPair>;\n\n    /**\n     * Get keys for a variant of the transfer function from the credits.aleo program\n     *\n     * @param {string} visibility Visibility of the transfer function (private, public, privateToPublic, publicToPrivate)\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the specified transfer function\n     *\n     * @example\n     * // Create a new object which implements the KeyProvider interface\n     * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for value transfers\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * programManager.transfer(1, \"aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at\", \"public\", 0.5);\n     *\n     * // Keys can also be fetched manually\n     * const [transferPublicProvingKey, transferPublicVerifyingKey] = await keyProvider.transferKeys(\"public\");\n     */\n    transferKeys(visibility: string): Promise<FunctionKeyPair>;\n\n    /**\n     * Get unbond_public function keys from the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function\n     */\n    unBondPublicKeys(): Promise<FunctionKeyPair>;\n\n}\n\n\n/**\n * AleoKeyProvider class. Implements the KeyProvider interface. Enables the retrieval of Aleo program proving and\n * verifying keys for the credits.aleo program over http from official Aleo sources and storing and retrieving function\n * keys from a local memory cache.\n */\nclass AleoKeyProvider implements FunctionKeyProvider {\n    cache: Map<string, CachedKeyPair>;\n    cacheOption: boolean;\n    keyUris: string;\n\n    async fetchBytes(\n        url = \"/\",\n    ): Promise<Uint8Array> {\n        try {\n        const response = await get(url);\n        const data = await response.arrayBuffer();\n        return new Uint8Array(data);\n        } catch (error: any) {\n            throw new Error(\"Error fetching data.\" + error.message);\n        }\n    }\n\n    constructor() {\n        this.keyUris = KEY_STORE;\n        this.cache = new Map<string, CachedKeyPair>();\n        this.cacheOption = false;\n    }\n\n    /**\n     * Use local memory to store keys\n     *\n     * @param {boolean} useCache whether to store keys in local memory\n     */\n    useCache(useCache: boolean) {\n        this.cacheOption = useCache;\n    }\n\n    /**\n     * Clear the key cache\n     */\n    clearCache() {\n        this.cache.clear();\n    }\n\n    /**\n     * Cache a set of keys. This will overwrite any existing keys with the same keyId. The user can check if a keyId\n     * exists in the cache using the containsKeys method prior to calling this method if overwriting is not desired.\n     *\n     * @param {string} keyId access key for the cache\n     * @param {FunctionKeyPair} keys keys to cache\n     */\n    cacheKeys(keyId: string, keys: FunctionKeyPair) {\n        const [provingKey, verifyingKey] = keys;\n        this.cache.set(keyId, [provingKey.toBytes(), verifyingKey.toBytes()]);\n    }\n\n    /**\n     * Determine if a keyId exists in the cache\n     *\n     * @param {string} keyId keyId of a proving and verifying key pair\n     * @returns {boolean} true if the keyId exists in the cache, false otherwise\n     */\n    containsKeys(keyId: string): boolean {\n        return this.cache.has(keyId)\n    }\n\n    /**\n     * Delete a set of keys from the cache\n     *\n     * @param {string} keyId keyId of a proving and verifying key pair to delete from memory\n     * @returns {boolean} true if the keyId exists in the cache and was deleted, false if the key did not exist\n     */\n    deleteKeys(keyId: string): boolean {\n        return this.cache.delete(keyId)\n    }\n\n    /**\n     * Get a set of keys from the cache\n     * @param keyId keyId of a proving and verifying key pair\n     *\n     * @returns {FunctionKeyPair} Proving and verifying keys for the specified program\n     */\n    getKeys(keyId: string): FunctionKeyPair {\n        console.debug(`Checking if key exists in cache. KeyId: ${keyId}`)\n        if (this.cache.has(keyId)) {\n            const [provingKeyBytes, verifyingKeyBytes] = <CachedKeyPair>this.cache.get(keyId);\n            return [ProvingKey.fromBytes(provingKeyBytes), VerifyingKey.fromBytes(verifyingKeyBytes)];\n        } else {\n            throw new Error(\"Key not found in cache.\");\n        }\n    }\n\n    /**\n     * Get arbitrary function keys from a provider\n     *\n     * @param {KeySearchParams} params parameters for the key search in form of: {proverUri: string, verifierUri: string, cacheKey: string}\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the specified program\n     *\n     * @example\n     * // Create a new object which implements the KeyProvider interface\n     * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for value transfers\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * programManager.transfer(1, \"aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at\", \"public\", 0.5);\n     *\n     * // Keys can also be fetched manually using the key provider\n     * const keySearchParams = { \"cacheKey\": \"myProgram:myFunction\" };\n     * const [transferPrivateProvingKey, transferPrivateVerifyingKey] = await keyProvider.functionKeys(keySearchParams);\n     */\n    async functionKeys(params?: KeySearchParams): Promise<FunctionKeyPair> {\n        if (params) {\n            let proverUrl;\n            let verifierUrl;\n            let cacheKey;\n            if (\"name\" in params && typeof params[\"name\"] == \"string\") {\n                let key = CREDITS_PROGRAM_KEYS.getKey(params[\"name\"]);\n                return this.fetchCreditsKeys(key);\n            }\n\n            if (\"proverUri\" in params && typeof params[\"proverUri\"] == \"string\") {\n                proverUrl = params[\"proverUri\"];\n            }\n\n            if (\"verifierUri\" in params && typeof params[\"verifierUri\"] == \"string\") {\n                verifierUrl = params[\"verifierUri\"];\n            }\n\n            if (\"cacheKey\" in params && typeof params[\"cacheKey\"] == \"string\") {\n                cacheKey = params[\"cacheKey\"];\n            }\n\n            if (proverUrl && verifierUrl) {\n                return await this.fetchRemoteKeys(proverUrl, verifierUrl, cacheKey);\n            }\n\n            if (cacheKey) {\n                return this.getKeys(cacheKey);\n            }\n        }\n        throw new Error(\"Invalid parameters provided, must provide either a cacheKey and/or a proverUrl and a verifierUrl\");\n    }\n\n    /**\n     * Returns the proving and verifying keys for a specified program from a specified url.\n     *\n     * @param {string} verifierUrl Url of the proving key\n     * @param {string} proverUrl Url the verifying key\n     * @param {string} cacheKey Key to store the keys in the cache\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the specified program\n     *\n     * @example\n     * // Create a new AleoKeyProvider object\n     * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for value transfers\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * programManager.transfer(1, \"aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at\", \"public\", 0.5);\n     *\n     * // Keys can also be fetched manually\n     * const [transferPrivateProvingKey, transferPrivateVerifyingKey] = await keyProvider.fetchKeys(\n     *     CREDITS_PROGRAM_KEYS.transfer_private.prover,\n     *     CREDITS_PROGRAM_KEYS.transfer_private.verifier,\n     * );\n     */\n    async fetchRemoteKeys(proverUrl: string, verifierUrl: string, cacheKey?: string): Promise<FunctionKeyPair> {\n        try {\n            // If cache is enabled, check if the keys have already been fetched and return them if they have\n            if (this.cacheOption) {\n                if (!cacheKey) {\n                    cacheKey = proverUrl;\n                }\n                const value = this.cache.get(cacheKey);\n                if (typeof value !== \"undefined\") {\n                    return [ProvingKey.fromBytes(value[0]), VerifyingKey.fromBytes(value[1])];\n                } else {\n                    console.debug(\"Fetching proving keys from url \" + proverUrl);\n                    const provingKey = <ProvingKey>ProvingKey.fromBytes(await this.fetchBytes(proverUrl))\n                    console.debug(\"Fetching verifying keys \" + verifierUrl);\n                    const verifyingKey = <VerifyingKey>(await this.getVerifyingKey(verifierUrl));\n                    this.cache.set(cacheKey, [provingKey.toBytes(), verifyingKey.toBytes()]);\n                    return [provingKey, verifyingKey];\n                }\n            }\n            else {\n                // If cache is disabled, fetch the keys and return them\n                const provingKey = <ProvingKey>ProvingKey.fromBytes(await this.fetchBytes(proverUrl))\n                const verifyingKey = <VerifyingKey>(await this.getVerifyingKey(verifierUrl));\n                return [provingKey, verifyingKey];\n            }\n        } catch (error: any) {\n            throw new Error(`Error: ${error.message} fetching fee proving and verifying keys from ${proverUrl} and ${verifierUrl}.`);\n        }\n    }\n\n    /***\n     * Fetches the proving key from a remote source.\n     *\n     * @param proverUrl\n     * @param cacheKey\n     *\n     * @returns {Promise<ProvingKey>} Proving key for the specified program\n     */\n    async fetchProvingKey(proverUrl: string, cacheKey?: string): Promise<ProvingKey> {\n        try {\n            // If cache is enabled, check if the keys have already been fetched and return them if they have\n            if (this.cacheOption) {\n                if (!cacheKey) {\n                    cacheKey = proverUrl;\n                }\n                const value = this.cache.get(cacheKey);\n                if (typeof value !== \"undefined\") {\n                    return ProvingKey.fromBytes(value[0]);\n                } else {\n                    console.debug(\"Fetching proving keys from url \" + proverUrl);\n                    const provingKey = <ProvingKey>ProvingKey.fromBytes(await this.fetchBytes(proverUrl));\n                    return provingKey;\n                }\n            }\n            else {\n                const provingKey = <ProvingKey>ProvingKey.fromBytes(await this.fetchBytes(proverUrl));\n                return provingKey;\n            }\n        } catch (error: any) {\n            throw new Error(`Error: ${error.message} fetching fee proving keys from ${proverUrl}`);\n        }\n    }\n\n    async fetchCreditsKeys(key: Key): Promise<FunctionKeyPair> {\n        try {\n            if (!this.cache.has(key.locator) || !this.cacheOption) {\n                const verifying_key = key.verifyingKey()\n                const proving_key = <ProvingKey>await this.fetchProvingKey(key.prover, key.locator);\n                if (this.cacheOption) {\n                    this.cache.set(CREDITS_PROGRAM_KEYS.bond_public.locator, [proving_key.toBytes(), verifying_key.toBytes()]);\n                }\n                return [proving_key, verifying_key];\n            } else {\n                const keyPair = <CachedKeyPair>this.cache.get(key.locator);\n                return [ProvingKey.fromBytes(keyPair[0]), VerifyingKey.fromBytes(keyPair[1])];\n            }\n        } catch (error: any) {\n            throw new Error(`Error: fetching credits.aleo keys: ${error.message}`);\n        }\n    }\n\n    async bondPublicKeys(): Promise<FunctionKeyPair> {\n        return this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.bond_public);\n    }\n\n    bondValidatorKeys(): Promise<FunctionKeyPair> {\n        return this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.bond_validator);\n    }\n\n    claimUnbondPublicKeys(): Promise<FunctionKeyPair> {\n        return this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.claim_unbond_public)\n    }\n\n    /**\n     * Returns the proving and verifying keys for the transfer functions in the credits.aleo program\n     * @param {string} visibility Visibility of the transfer function\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the transfer functions\n     *\n     * @example\n     * // Create a new AleoKeyProvider\n     * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for value transfers\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * programManager.transfer(1, \"aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at\", \"public\", 0.5);\n     *\n     * // Keys can also be fetched manually\n     * const [transferPublicProvingKey, transferPublicVerifyingKey] = await keyProvider.transferKeys(\"public\");\n     */\n    async transferKeys(visibility: string): Promise<FunctionKeyPair> {\n        if (PRIVATE_TRANSFER.has(visibility)) {\n            return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.transfer_private);\n        } else if (PRIVATE_TO_PUBLIC_TRANSFER.has(visibility)) {\n            return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.transfer_private_to_public);\n        } else if (PUBLIC_TRANSFER.has(visibility)) {\n            return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.transfer_public);\n        } else if (PUBLIC_TRANSFER_AS_SIGNER.has(visibility)) {\n            return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.transfer_public_as_signer);\n        } else if (PUBLIC_TO_PRIVATE_TRANSFER.has(visibility)) {\n            return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.transfer_public_to_private);\n        } else {\n            throw new Error(\"Invalid visibility type\");\n        }\n    }\n\n    /**\n     * Returns the proving and verifying keys for the join function in the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function\n     */\n    async joinKeys(): Promise<FunctionKeyPair> {\n        return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.join);\n    }\n\n    /**\n     * Returns the proving and verifying keys for the split function in the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the split function\n     * */\n    async splitKeys(): Promise<FunctionKeyPair> {\n        return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.split);\n    }\n\n    /**\n     * Returns the proving and verifying keys for the fee_private function in the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the fee function\n     */\n    async feePrivateKeys(): Promise<FunctionKeyPair> {\n        return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.fee_private);\n    }\n\n    /**\n     * Returns the proving and verifying keys for the fee_public function in the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the fee function\n     */\n    async feePublicKeys(): Promise<FunctionKeyPair> {\n        return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.fee_public);\n    }\n\n    /**\n     * Gets a verifying key. If the verifying key is for a credits.aleo function, get it from the wasm cache otherwise\n     *\n     * @returns {Promise<VerifyingKey>} Verifying key for the function\n     */\n    // attempt to fetch it from the network\n    async getVerifyingKey(verifierUri: string): Promise<VerifyingKey> {\n        switch (verifierUri) {\n            case CREDITS_PROGRAM_KEYS.bond_public.verifier:\n                return CREDITS_PROGRAM_KEYS.bond_public.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.bond_validator.verifier:\n                return CREDITS_PROGRAM_KEYS.bond_validator.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.claim_unbond_public.verifier:\n                return CREDITS_PROGRAM_KEYS.claim_unbond_public.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.fee_private.verifier:\n                return CREDITS_PROGRAM_KEYS.fee_private.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.fee_public.verifier:\n                return CREDITS_PROGRAM_KEYS.fee_public.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.inclusion.verifier:\n                return CREDITS_PROGRAM_KEYS.inclusion.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.join.verifier:\n                return CREDITS_PROGRAM_KEYS.join.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.set_validator_state.verifier:\n                return CREDITS_PROGRAM_KEYS.set_validator_state.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.split.verifier:\n                return CREDITS_PROGRAM_KEYS.split.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.transfer_private.verifier:\n                return CREDITS_PROGRAM_KEYS.transfer_private.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.transfer_private_to_public.verifier:\n                return CREDITS_PROGRAM_KEYS.transfer_private_to_public.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.transfer_public.verifier:\n                return CREDITS_PROGRAM_KEYS.transfer_public.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.transfer_public_as_signer.verifier:\n                return CREDITS_PROGRAM_KEYS.transfer_public_as_signer.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.transfer_public_to_private.verifier:\n                return CREDITS_PROGRAM_KEYS.transfer_public_to_private.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.unbond_public.verifier:\n                return CREDITS_PROGRAM_KEYS.unbond_public.verifyingKey();\n            default:\n                try {\n                    /// Try to fetch the verifying key from the network as a string\n                    const response = await get(verifierUri);\n                    const text = await response.text();\n                    return <VerifyingKey>VerifyingKey.fromString(text);\n                } catch (e) {\n                    /// If that fails, try to fetch the verifying key from the network as bytes\n                    try {\n                    return <VerifyingKey>VerifyingKey.fromBytes(await this.fetchBytes(verifierUri));\n                    } catch (inner: any) {\n                        throw new Error(\"Invalid verifying key. Error: \" + inner.message);\n                    }\n                }\n        }\n    }\n\n    unBondPublicKeys(): Promise<FunctionKeyPair> {\n        return this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.unbond_public);\n    }\n}\n\nexport {AleoKeyProvider, AleoKeyProviderParams, AleoKeyProviderInitParams, CachedKeyPair, FunctionKeyPair, FunctionKeyProvider, KeySearchParams}\n", "import { Account } from \"./account\";\nimport { AleoNetworkClient, ProgramImports } from \"./network-client\";\n\nimport { RecordProvider, RecordSearchParams } from \"./record-provider\";\n\nimport {\n    AleoKeyProvider,\n    AleoKeyProviderParams,\n    FunctionKeyPair,\n    FunctionKeyProvider,\n    KeySearchParams,\n} from \"./function-key-provider\";\n\nimport {\n    Address,\n    ExecutionResponse,\n    Execution as FunctionExecution,\n    OfflineQuery,\n    RecordPlaintext,\n    PrivateKey,\n    Program,\n    ProvingKey,\n    VerifyingKey,\n    Transaction,\n    ProgramManager as WasmProgramManager,\n    verifyFunctionExecution,\n} from \"./wasm\";\n\nimport {\n    CREDITS_PROGRAM_KEYS,\n    PRIVATE_TRANSFER_TYPES,\n    VALID_TRANSFER_TYPES,\n} from \"./constants\";\n\nimport { logAndThrow } from \"./utils\";\n\n/**\n * Represents the options for executing a transaction in the Aleo network.\n * This interface is used to specify the parameters required for building and submitting an execution transaction.\n *\n * @property {string} programName - The name of the program containing the function to be executed.\n * @property {string} functionName - The name of the function to execute within the program.\n * @property {number} priorityFee - The optional priority fee to be paid for the transaction.\n * @property {boolean} privateFee - If true, uses a private record to pay the fee; otherwise, uses the account's public credit balance.\n * @property {string[]} inputs - The inputs to the function being executed.\n * @property {RecordSearchParams} [recordSearchParams] - Optional parameters for searching for a record to pay the execution transaction fee.\n * @property {KeySearchParams} [keySearchParams] - Optional parameters for finding the matching proving & verifying keys for the function.\n * @property {string | RecordPlaintext} [feeRecord] - Optional fee record to use for the transaction.\n * @property {ProvingKey} [provingKey] - Optional proving key to use for the transaction.\n * @property {VerifyingKey} [verifyingKey] - Optional verifying key to use for the transaction.\n * @property {PrivateKey} [privateKey] - Optional private key to use for the transaction.\n * @property {OfflineQuery} [offlineQuery] - Optional offline query if creating transactions in an offline environment.\n * @property {string | Program} [program] - Optional program source code to use for the transaction.\n * @property {ProgramImports} [imports] - Optional programs that the program being executed imports.\n */\ninterface ExecuteOptions {\n    programName: string;\n    functionName: string;\n    priorityFee: number;\n    privateFee: boolean;\n    inputs: string[];\n    recordSearchParams?: RecordSearchParams;\n    keySearchParams?: KeySearchParams;\n    feeRecord?: string | RecordPlaintext;\n    provingKey?: ProvingKey;\n    verifyingKey?: VerifyingKey;\n    privateKey?: PrivateKey;\n    offlineQuery?: OfflineQuery;\n    program?: string | Program;\n    imports?: ProgramImports;\n}\n\n/**\n * The ProgramManager class is used to execute and deploy programs on the Aleo network and create value transfers.\n */\nclass ProgramManager {\n    account: Account | undefined;\n    keyProvider: FunctionKeyProvider;\n    host: string;\n    networkClient: AleoNetworkClient;\n    recordProvider: RecordProvider | undefined;\n\n    /** Create a new instance of the ProgramManager\n     *\n     * @param { string | undefined } host A host uri running the official Aleo API\n     * @param { FunctionKeyProvider | undefined } keyProvider A key provider that implements {@link FunctionKeyProvider} interface\n     * @param { RecordProvider | undefined } recordProvider A record provider that implements {@link RecordProvider} interface\n     */\n    constructor(\n        host?: string | undefined,\n        keyProvider?: FunctionKeyProvider | undefined,\n        recordProvider?: RecordProvider | undefined,\n    ) {\n        this.host = host ? host : \"https://api.explorer.provable.com/v1\";\n        this.networkClient = new AleoNetworkClient(this.host);\n\n        this.keyProvider = keyProvider ? keyProvider : new AleoKeyProvider();\n        this.recordProvider = recordProvider;\n    }\n\n    /**\n     * Check if the fee is sufficient to pay for the transaction\n     */\n    async checkFee(address: string, feeAmount: bigint) {\n        const balance =\n            BigInt(await this.networkClient.getPublicBalance(address));\n        if (feeAmount > balance) {\n            throw Error(\n                `The desired execution requires a fee of ${feeAmount} microcredits, but the account paying the fee has ${balance} microcredits available.`,\n            );\n        }\n    }\n\n    /**\n     * Set the account to use for transaction submission to the Aleo network\n     *\n     * @param {Account} account Account to use for transaction submission\n     */\n    setAccount(account: Account) {\n        this.account = account;\n    }\n\n    /**\n     * Set the key provider that provides the proving and verifying keys for programs\n     *\n     * @param {FunctionKeyProvider} keyProvider\n     */\n    setKeyProvider(keyProvider: FunctionKeyProvider) {\n        this.keyProvider = keyProvider;\n    }\n\n    /**\n     * Set the host peer to use for transaction submission to the Aleo network\n     *\n     * @param host {string} Peer url to use for transaction submission\n     */\n    setHost(host: string) {\n        this.host = host;\n        this.networkClient.setHost(host);\n    }\n\n    /**\n     * Set the record provider that provides records for transactions\n     *\n     * @param {RecordProvider} recordProvider\n     */\n    setRecordProvider(recordProvider: RecordProvider) {\n        this.recordProvider = recordProvider;\n    }\n\n    /**\n     * Builds a deployment transaction for submission to the Aleo network.\n     *\n     * @param {string} program Program source code\n     * @param {number} priorityFee The optional priority fee to be paid for that transaction.\n     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance\n     * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for searching for a record to use pay the deployment fee\n     * @param {string | RecordPlaintext | undefined} feeRecord Optional Fee record to use for the transaction\n     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transaction\n     * @returns {string} The transaction id of the deployed program or a failure message from the network\n     *\n     * @example\n     * /// Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     * keyProvider.useCache = true;\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for deployments\n     * const program = \"program hello_hello.aleo;\\n\\nfunction hello:\\n    input r0 as u32.public;\\n    input r1 as u32.private;\\n    add r0 r1 into r2;\\n    output r2 as u32.private;\\n\";\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * programManager.setAccount(Account);\n     *\n     * // Define a fee in credits\n     * const priorityFee = 0.0;\n     *\n     * // Create the deployment transaction.\n     * const tx = await programManager.buildDeploymentTransaction(program, fee, false);\n     * await programManager.networkClient.submitTransaction(tx);\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx.id());\n     *  assert(transaction.id() === tx.id());\n     * }, 20000);\n     */\n    async buildDeploymentTransaction(\n        program: string,\n        priorityFee: number,\n        privateFee: boolean,\n        recordSearchParams?: RecordSearchParams,\n        feeRecord?: string | RecordPlaintext,\n        privateKey?: PrivateKey,\n    ): Promise<Transaction> {\n        // Ensure the program is valid.\n        let programObject;\n        try {\n            programObject = Program.fromString(program);\n        } catch (e: any) {\n            logAndThrow(\n                `Error parsing program: '${e.message}'. Please ensure the program is valid.`,\n            );\n        }\n\n        // Ensure the program is valid and does not exist on the network\n        try {\n            let programSource;\n            try {\n                programSource = await this.networkClient.getProgram(\n                    programObject.id(),\n                );\n            } catch (e) {\n                // Program does not exist on the network, deployment can proceed\n                console.log(\n                    `Program ${programObject.id()} does not exist on the network, deploying...`,\n                );\n            }\n            if (typeof programSource === \"string\") {\n                throw Error(`Program ${programObject.id()} already exists on the network, please rename your program`);\n            }\n        } catch (e: any) {\n            logAndThrow(`Error validating program: ${e.message}`);\n        }\n\n        // Get the private key from the account if it is not provided in the parameters\n        let deploymentPrivateKey = privateKey;\n        if (\n            typeof privateKey === \"undefined\" &&\n            typeof this.account !== \"undefined\"\n        ) {\n            deploymentPrivateKey = this.account.privateKey();\n        }\n\n        if (typeof deploymentPrivateKey === \"undefined\") {\n            throw \"No private key provided and no private key set in the ProgramManager\";\n        }\n\n        // Get the fee record from the account if it is not provided in the parameters\n        try {\n            feeRecord = privateFee\n                ? <RecordPlaintext>(\n                      await this.getCreditsRecord(\n                          priorityFee,\n                          [],\n                          feeRecord,\n                          recordSearchParams,\n                      )\n                  )\n                : undefined;\n        } catch (e: any) {\n            logAndThrow(\n                `Error finding fee record. Record finder response: '${e.message}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`,\n            );\n        }\n\n        // Get the proving and verifying keys from the key provider\n        let feeKeys;\n        try {\n            feeKeys = privateFee\n                ? <FunctionKeyPair>await this.keyProvider.feePrivateKeys()\n                : <FunctionKeyPair>await this.keyProvider.feePublicKeys();\n        } catch (e: any) {\n            logAndThrow(\n                `Error finding fee keys. Key finder response: '${e.message}'. Please ensure your key provider is configured correctly.`,\n            );\n        }\n        const [feeProvingKey, feeVerifyingKey] = feeKeys;\n\n        // Resolve the program imports if they exist\n        let imports;\n        try {\n            imports = await this.networkClient.getProgramImports(program);\n        } catch (e: any) {\n            logAndThrow(\n                `Error finding program imports. Network response: '${e.message}'. Please ensure you're connected to a valid Aleo network and the program is deployed to the network.`,\n            );\n        }\n\n        // Build a deployment transaction\n        return await WasmProgramManager.buildDeploymentTransaction(\n            deploymentPrivateKey,\n            program,\n            priorityFee,\n            feeRecord,\n            this.host,\n            imports,\n            feeProvingKey,\n            feeVerifyingKey,\n        );\n    }\n\n    /**\n     * Deploy an Aleo program to the Aleo network\n     *\n     * @param {string} program Program source code\n     * @param {number} priorityFee The optional fee to be paid for the transaction\n     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance\n     * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for searching for a record to used pay the deployment fee\n     * @param {string | RecordPlaintext | undefined} feeRecord Optional Fee record to use for the transaction\n     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transaction\n     * @returns {string} The transaction id of the deployed program or a failure message from the network\n     *\n     * @example\n     * /// Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     * keyProvider.useCache = true;\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for deployments\n     * const program = \"program hello_hello.aleo;\\n\\nfunction hello:\\n    input r0 as u32.public;\\n    input r1 as u32.private;\\n    add r0 r1 into r2;\\n    output r2 as u32.private;\\n\";\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     *\n     * // Define a fee in credits\n     * const priorityFee = 0.0;\n     *\n     * // Deploy the program\n     * const tx_id = await programManager.deploy(program, fee, false);\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx_id);\n     *  assert(transaction.id() === tx_id);\n     * }, 20000);\n     */\n    async deploy(\n        program: string,\n        priorityFee: number,\n        privateFee: boolean,\n        recordSearchParams?: RecordSearchParams,\n        feeRecord?: string | RecordPlaintext,\n        privateKey?: PrivateKey,\n    ): Promise<string> {\n        const tx = <Transaction>(\n            await this.buildDeploymentTransaction(\n                program,\n                priorityFee,\n                privateFee,\n                recordSearchParams,\n                feeRecord,\n                privateKey,\n            )\n        );\n\n        let feeAddress;\n\n        if (typeof privateKey !== \"undefined\") {\n            feeAddress = Address.from_private_key(privateKey);\n        } else if (this.account !== undefined) {\n            feeAddress = this.account?.address();\n        } else {\n            throw Error(\n                \"No private key provided and no private key set in the ProgramManager. Please set an account or provide a private key.\",\n            );\n        }\n\n        // Check if the account has sufficient credits to pay for the transaction\n        await this.checkFee(feeAddress.to_string(), tx.feeAmount());\n\n        return await this.networkClient.submitTransaction(tx);\n    }\n\n    /**\n     * Builds an execution transaction for submission to the Aleo network.\n     *\n     * @param {ExecuteOptions} options - The options for the execution transaction.\n     * @returns {Promise<Transaction>} - A promise that resolves to the transaction or an error.\n     *\n     * @example\n     * /// Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider using official Aleo record, key, and network providers\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     * keyProvider.useCache = true;\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for executions\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     *\n     * // Build and execute the transaction\n     * const tx = await programManager.buildExecutionTransaction({\n     *   programName: \"hello_hello.aleo\",\n     *   functionName: \"hello_hello\",\n     *   priorityFee: 0.0,\n     *   privateFee: false,\n     *   inputs: [\"5u32\", \"5u32\"],\n     *   keySearchParams: { \"cacheKey\": \"hello_hello:hello\" }\n     * });\n     *\n     * // Submit the transaction to the network\n     * await programManager.networkClient.submitTransaction(tx.toString());\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx.id());\n     *  assert(transaction.id() === tx.id());\n     * }, 10000);\n     */\n    async buildExecutionTransaction(\n        options: ExecuteOptions,\n    ): Promise<Transaction> {\n        // Destructure the options object to access the parameters\n        const {\n            programName,\n            functionName,\n            priorityFee,\n            privateFee,\n            inputs,\n            recordSearchParams,\n            keySearchParams,\n            privateKey,\n            offlineQuery,\n        } = options;\n\n        let feeRecord = options.feeRecord;\n        let provingKey = options.provingKey;\n        let verifyingKey = options.verifyingKey;\n        let program = options.program;\n        let imports = options.imports;\n\n        // Ensure the function exists on the network\n        if (program === undefined) {\n            try {\n                program = <string>(\n                    await this.networkClient.getProgram(programName)\n                );\n            } catch (e: any) {\n                logAndThrow(\n                    `Error finding ${programName}. Network response: '${e.message}'. Please ensure you're connected to a valid Aleo network the program is deployed to the network.`,\n                );\n            }\n        } else if (program instanceof Program) {\n            program = program.toString();\n        }\n\n        // Get the private key from the account if it is not provided in the parameters\n        let executionPrivateKey = privateKey;\n        if (\n            typeof privateKey === \"undefined\" &&\n            typeof this.account !== \"undefined\"\n        ) {\n            executionPrivateKey = this.account.privateKey();\n        }\n\n        if (typeof executionPrivateKey === \"undefined\") {\n            throw \"No private key provided and no private key set in the ProgramManager\";\n        }\n\n        // Get the fee record from the account if it is not provided in the parameters\n        try {\n            feeRecord = privateFee\n                ? <RecordPlaintext>(\n                      await this.getCreditsRecord(\n                          priorityFee,\n                          [],\n                          feeRecord,\n                          recordSearchParams,\n                      )\n                  )\n                : undefined;\n        } catch (e: any) {\n            logAndThrow(\n                `Error finding fee record. Record finder response: '${e.message}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`,\n            );\n        }\n\n        // Get the fee proving and verifying keys from the key provider\n        let feeKeys;\n        try {\n            feeKeys = privateFee\n                ? <FunctionKeyPair>await this.keyProvider.feePrivateKeys()\n                : <FunctionKeyPair>await this.keyProvider.feePublicKeys();\n        } catch (e: any) {\n            logAndThrow(\n                `Error finding fee keys. Key finder response: '${e.message}'. Please ensure your key provider is configured correctly.`,\n            );\n        }\n        const [feeProvingKey, feeVerifyingKey] = feeKeys;\n\n        // If the function proving and verifying keys are not provided, attempt to find them using the key provider\n        if (!provingKey || !verifyingKey) {\n            try {\n                [provingKey, verifyingKey] = <FunctionKeyPair>(\n                    await this.keyProvider.functionKeys(keySearchParams)\n                );\n            } catch (e) {\n                console.log(\n                    `Function keys not found. Key finder response: '${e}'. The function keys will be synthesized`,\n                );\n            }\n        }\n\n        // Resolve the program imports if they exist\n        const numberOfImports = Program.fromString(program).getImports().length;\n        if (numberOfImports > 0 && !imports) {\n            try {\n                imports = <ProgramImports>(\n                    await this.networkClient.getProgramImports(programName)\n                );\n            } catch (e: any) {\n                logAndThrow(\n                    `Error finding program imports. Network response: '${e.message}'. Please ensure you're connected to a valid Aleo network and the program is deployed to the network.`,\n                );\n            }\n        }\n\n        // Build an execution transaction\n        return await WasmProgramManager.buildExecutionTransaction(\n            executionPrivateKey,\n            program,\n            functionName,\n            inputs,\n            priorityFee,\n            feeRecord,\n            this.host,\n            imports,\n            provingKey,\n            verifyingKey,\n            feeProvingKey,\n            feeVerifyingKey,\n            offlineQuery,\n        );\n    }\n\n    /**\n     * Builds an execution transaction for submission to the Aleo network.\n     *\n     * @param {ExecuteOptions} options - The options for the execution transaction.\n     * @returns {Promise<string>} - The transaction id\n     *\n     * @example\n     * /// Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider using official Aleo record, key, and network providers\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     * keyProvider.useCache = true;\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for executions\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     *\n     * // Build and execute the transaction\n     * const tx_id = await programManager.execute({\n     *   programName: \"hello_hello.aleo\",\n     *   functionName: \"hello_hello\",\n     *   priorityFee: 0.0,\n     *   privateFee: false,\n     *   inputs: [\"5u32\", \"5u32\"],\n     *   keySearchParams: { \"cacheKey\": \"hello_hello:hello\" }\n     * });\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx_id);\n     *  assert(transaction.id() === tx_id);\n     * }, 10000);\n     */\n    async execute(options: ExecuteOptions): Promise<string> {\n        const tx = <Transaction>await this.buildExecutionTransaction(options);\n\n        let feeAddress;\n\n        if (typeof options.privateKey !== \"undefined\") {\n            feeAddress = Address.from_private_key(options.privateKey);\n        } else if (this.account !== undefined) {\n            feeAddress = this.account?.address();\n        } else {\n            throw Error(\n                \"No private key provided and no private key set in the ProgramManager. Please set an account or provide a private key.\",\n            );\n        }\n\n        // Check if the account has sufficient credits to pay for the transaction\n        await this.checkFee(feeAddress.to_string(), tx.feeAmount());\n\n        return await this.networkClient.submitTransaction(tx);\n    }\n\n    /**\n     * Run an Aleo program in offline mode\n     *\n     * @param {string} program Program source code containing the function to be executed\n     * @param {string} function_name Function name to execute\n     * @param {string[]} inputs Inputs to the function\n     * @param {number} proveExecution Whether to prove the execution of the function and return an execution transcript that contains the proof.\n     * @param {string[] | undefined} imports Optional imports to the program\n     * @param {KeySearchParams | undefined} keySearchParams Optional parameters for finding the matching proving & verifying keys for the function\n     * @param {ProvingKey | undefined} provingKey Optional proving key to use for the transaction\n     * @param {VerifyingKey | undefined} verifyingKey Optional verifying key to use for the transaction\n     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transaction\n     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment\n     * @returns {Promise<ExecutionResponse>} The execution response containing the outputs of the function and the proof if the program is proved.\n     *\n     * @example\n     * /// Import the mainnet version of the sdk used to build executions.\n     * import { Account, ProgramManager } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * /// Create the source for the \"helloworld\" program\n     * const program = \"program helloworld.aleo;\\n\\nfunction hello:\\n    input r0 as u32.public;\\n    input r1 as u32.private;\\n    add r0 r1 into r2;\\n    output r2 as u32.private;\\n\";\n     * const programManager = new ProgramManager(undefined, undefined, undefined);\n     *\n     * /// Create a temporary account for the execution of the program\n     * const account = new Account();\n     * programManager.setAccount(account);\n     *\n     * /// Get the response and ensure that the program executed correctly\n     * const executionResponse = await programManager.run(program, \"hello\", [\"5u32\", \"5u32\"]);\n     * const result = executionResponse.getOutputs();\n     * assert(result === [\"10u32\"]);\n     */\n    async run(\n        program: string,\n        function_name: string,\n        inputs: string[],\n        proveExecution: boolean,\n        imports?: ProgramImports,\n        keySearchParams?: KeySearchParams,\n        provingKey?: ProvingKey,\n        verifyingKey?: VerifyingKey,\n        privateKey?: PrivateKey,\n        offlineQuery?: OfflineQuery,\n    ): Promise<ExecutionResponse> {\n        // Get the private key from the account if it is not provided in the parameters\n        let executionPrivateKey = privateKey;\n        if (\n            typeof privateKey === \"undefined\" &&\n            typeof this.account !== \"undefined\"\n        ) {\n            executionPrivateKey = this.account.privateKey();\n        }\n\n        if (typeof executionPrivateKey === \"undefined\") {\n            throw \"No private key provided and no private key set in the ProgramManager\";\n        }\n\n        // If the function proving and verifying keys are not provided, attempt to find them using the key provider\n        if (!provingKey || !verifyingKey) {\n            try {\n                [provingKey, verifyingKey] = <FunctionKeyPair>(\n                    await this.keyProvider.functionKeys(keySearchParams)\n                );\n            } catch (e) {\n                console.log(\n                    `Function keys not found. Key finder response: '${e}'. The function keys will be synthesized`,\n                );\n            }\n        }\n\n        // Run the program offline and return the result\n        console.log(\"Running program offline\");\n        console.log(\"Proving key: \", provingKey);\n        console.log(\"Verifying key: \", verifyingKey);\n        return WasmProgramManager.executeFunctionOffline(\n            executionPrivateKey,\n            program,\n            function_name,\n            inputs,\n            proveExecution,\n            false,\n            imports,\n            provingKey,\n            verifyingKey,\n            this.host,\n            offlineQuery,\n        );\n    }\n\n    /**\n     * Join two credits records into a single credits record\n     *\n     * @param {RecordPlaintext | string} recordOne First credits record to join\n     * @param {RecordPlaintext | string} recordTwo Second credits record to join\n     * @param {number} priorityFee The optional priority fee to be paid for the transaction\n     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance\n     * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for finding the fee record to use to pay the fee for the join transaction\n     * @param {RecordPlaintext | string | undefined} feeRecord Fee record to use for the join transaction\n     * @param {PrivateKey | undefined} privateKey Private key to use for the join transaction\n     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment\n     * @returns {Promise<string>} The transaction id\n     *\n     * @example\n     * /// Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     * keyProvider.useCache = true;\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for executions\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * const record_1 = \"{  owner: aleo184vuwr5u7u0ha5f5k44067dd2uaqewxx6pe5ltha5pv99wvhfqxqv339h4.private,  microcredits: 45000000u64.private,  _nonce: 4106205762862305308495708971985748592380064201230396559307556388725936304984group.public}\"\n     * const record_2 = \"{  owner: aleo184vuwr5u7u0ha5f5k44067dd2uaqewxx6pe5ltha5pv99wvhfqxqv339h4.private,  microcredits: 45000000u64.private,  _nonce: 1540945439182663264862696551825005342995406165131907382295858612069623286213group.public}\"\n     * const tx_id = await programManager.join(record_1, record_2, 0.05, false);\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx_id);\n     *  assert(transaction.id() === tx_id);\n     * }, 10000);\n     */\n    async join(\n        recordOne: RecordPlaintext | string,\n        recordTwo: RecordPlaintext | string,\n        priorityFee: number,\n        privateFee: boolean,\n        recordSearchParams?: RecordSearchParams | undefined,\n        feeRecord?: RecordPlaintext | string | undefined,\n        privateKey?: PrivateKey,\n        offlineQuery?: OfflineQuery,\n    ): Promise<string> {\n        // Get the private key from the account if it is not provided in the parameters and assign the fee address\n        let executionPrivateKey = privateKey;\n        let feeAddress;\n        if (\n            typeof privateKey === \"undefined\" &&\n            typeof this.account !== \"undefined\"\n        ) {\n            executionPrivateKey = this.account.privateKey();\n            feeAddress = this.account?.address();\n        }\n        else if (typeof executionPrivateKey === \"undefined\") {\n            throw \"No private key provided and no private key set in the ProgramManager\";\n        }\n        else {\n            feeAddress = Address.from_private_key(executionPrivateKey);\n        }\n\n        // Get the proving and verifying keys from the key provider\n        let feeKeys;\n        let joinKeys;\n        try {\n            feeKeys = privateFee\n                ? <FunctionKeyPair>await this.keyProvider.feePrivateKeys()\n                : <FunctionKeyPair>await this.keyProvider.feePublicKeys();\n            joinKeys = <FunctionKeyPair>await this.keyProvider.joinKeys();\n        } catch (e: any) {\n            logAndThrow(\n                `Error finding fee keys. Key finder response: '${e.message}'. Please ensure your key provider is configured correctly.`,\n            );\n        }\n        const [feeProvingKey, feeVerifyingKey] = feeKeys;\n        const [joinProvingKey, joinVerifyingKey] = joinKeys;\n\n        // Get the fee record from the account if it is not provided in the parameters\n        try {\n            feeRecord = privateFee\n                ? <RecordPlaintext>(\n                      await this.getCreditsRecord(\n                          priorityFee,\n                          [],\n                          feeRecord,\n                          recordSearchParams,\n                      )\n                  )\n                : undefined;\n        } catch (e: any) {\n            logAndThrow(\n                `Error finding fee record. Record finder response: '${e.message}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`,\n            );\n        }\n\n        // Validate the records provided are valid plaintext records\n        try {\n            recordOne =\n                recordOne instanceof RecordPlaintext\n                    ? recordOne\n                    : RecordPlaintext.fromString(recordOne);\n            recordTwo =\n                recordTwo instanceof RecordPlaintext\n                    ? recordTwo\n                    : RecordPlaintext.fromString(recordTwo);\n        } catch (e: any) {\n            logAndThrow(\n                \"Records provided are not valid. Please ensure they are valid plaintext records.\",\n            );\n        }\n\n        // Build an execution transaction and submit it to the network\n        const tx = await WasmProgramManager.buildJoinTransaction(\n            executionPrivateKey,\n            recordOne,\n            recordTwo,\n            priorityFee,\n            feeRecord,\n            this.host,\n            joinProvingKey,\n            joinVerifyingKey,\n            feeProvingKey,\n            feeVerifyingKey,\n            offlineQuery,\n        );\n\n        // Check if the account has sufficient credits to pay for the transaction\n        await this.checkFee(feeAddress.to_string(), tx.feeAmount());\n\n        return await this.networkClient.submitTransaction(tx);\n    }\n\n    /**\n     * Split credits into two new credits records\n     *\n     * @param {number} splitAmount Amount in microcredits to split from the original credits record\n     * @param {RecordPlaintext | string} amountRecord Amount record to use for the split transaction\n     * @param {PrivateKey | undefined} privateKey Optional private key to use for the split transaction\n     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment\n     * @returns {Promise<string>} The transaction id\n     *\n     * @example\n     * /// Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     * keyProvider.useCache = true;\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for executions\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * const record = \"{  owner: aleo184vuwr5u7u0ha5f5k44067dd2uaqewxx6pe5ltha5pv99wvhfqxqv339h4.private,  microcredits: 45000000u64.private,  _nonce: 4106205762862305308495708971985748592380064201230396559307556388725936304984group.public}\"\n     * const tx_id = await programManager.split(25000000, record);\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx_id);\n     *  assert(transaction.id() === tx_id);\n     * }, 10000);\n     */\n    async split(\n        splitAmount: number,\n        amountRecord: RecordPlaintext | string,\n        privateKey?: PrivateKey,\n        offlineQuery?: OfflineQuery,\n    ): Promise<string> {\n         // Get the private key from the account if it is not provided in the parameters\n         let executionPrivateKey = privateKey;\n         if (\n             typeof privateKey === \"undefined\" &&\n             typeof this.account !== \"undefined\"\n         ) {\n             executionPrivateKey = this.account.privateKey();\n         }\n\n        if (typeof executionPrivateKey === \"undefined\") {\n            throw \"No private key provided and no private key set in the ProgramManager\";\n        }\n\n        // Get the split keys from the key provider\n        let splitKeys;\n        try {\n            splitKeys = <FunctionKeyPair>await this.keyProvider.splitKeys();\n        } catch (e: any) {\n            logAndThrow(\n                `Error finding fee keys. Key finder response: '${e.message}'. Please ensure your key provider is configured correctly.`,\n            );\n        }\n        const [splitProvingKey, splitVerifyingKey] = splitKeys;\n\n        // Validate the record to be split\n        try {\n            amountRecord =\n                amountRecord instanceof RecordPlaintext\n                    ? amountRecord\n                    : RecordPlaintext.fromString(amountRecord);\n        } catch (e: any) {\n            logAndThrow(\n                \"Record provided is not valid. Please ensure it is a valid plaintext record.\",\n            );\n        }\n\n        // Build an execution transaction and submit it to the network\n        const tx = await WasmProgramManager.buildSplitTransaction(\n            executionPrivateKey,\n            splitAmount,\n            amountRecord,\n            this.host,\n            splitProvingKey,\n            splitVerifyingKey,\n            offlineQuery,\n        );\n\n        return await this.networkClient.submitTransaction(tx);\n    }\n\n    /**\n     * Pre-synthesize proving and verifying keys for a program\n     *\n     * @param program {string} The program source code to synthesize keys for\n     * @param function_id {string} The function id to synthesize keys for\n     * @param inputs {Array<string>}  Sample inputs to the function\n     * @param privateKey {PrivateKey | undefined} Optional private key to use for the key synthesis\n     *\n     * @returns {Promise<FunctionKeyPair>}\n     */\n    async synthesizeKeys(\n        program: string,\n        function_id: string,\n        inputs: Array<string>,\n        privateKey?: PrivateKey,\n    ): Promise<FunctionKeyPair> {\n        // Resolve the program imports if they exist\n        let imports;\n\n        let executionPrivateKey = privateKey;\n        if (typeof executionPrivateKey === \"undefined\") {\n            if (typeof this.account !== \"undefined\") {\n                executionPrivateKey = this.account.privateKey();\n            } else {\n                executionPrivateKey = new PrivateKey();\n            }\n        }\n\n        // Attempt to run an offline execution of the program and extract the proving and verifying keys\n        try {\n            imports = await this.networkClient.getProgramImports(program);\n            const keyPair = await WasmProgramManager.synthesizeKeyPair(\n                executionPrivateKey,\n                program,\n                function_id,\n                inputs,\n                imports,\n            );\n            return [\n                <ProvingKey>keyPair.provingKey(),\n                <VerifyingKey>keyPair.verifyingKey(),\n            ];\n        } catch (e: any) {\n            logAndThrow(\n                `Could not synthesize keys - error ${e.message}. Please ensure the program is valid and the inputs are correct.`,\n            );\n        }\n    }\n\n    /**\n     * Build a transaction to transfer credits to another account for later submission to the Aleo network\n     *\n     * @param {number} amount The amount of credits to transfer\n     * @param {string} recipient The recipient of the transfer\n     * @param {string} transferType The type of transfer to perform - options: 'private', 'privateToPublic', 'public', 'publicToPrivate'\n     * @param {number} priorityFee The optional priority fee to be paid for the transaction\n     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance\n     * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for finding the amount and fee records for the transfer transaction\n     * @param {RecordPlaintext | string} amountRecord Optional amount record to use for the transfer\n     * @param {RecordPlaintext | string} feeRecord Optional fee record to use for the transfer\n     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transfer transaction\n     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment\n     * @returns {Promise<Transaction>} The transaction object\n     *\n     * @example\n     * /// Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     * keyProvider.useCache = true;\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for executions\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * const tx = await programManager.buildTransferTransaction(1, \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\", \"public\", 0.2, false);\n     * await programManager.networkClient.submitTransaction(tx.toString());\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx.id());\n     *  assert(transaction.id() === tx.id());\n     * }, 10000);\n     */\n    async buildTransferTransaction(\n        amount: number,\n        recipient: string,\n        transferType: string,\n        priorityFee: number,\n        privateFee: boolean,\n        recordSearchParams?: RecordSearchParams,\n        amountRecord?: RecordPlaintext | string,\n        feeRecord?: RecordPlaintext | string,\n        privateKey?: PrivateKey,\n        offlineQuery?: OfflineQuery,\n    ): Promise<Transaction> {\n        // Validate the transfer type\n        transferType = <string>validateTransferType(transferType);\n\n        // Get the private key from the account if it is not provided in the parameters\n        let executionPrivateKey = privateKey;\n        if (\n            typeof executionPrivateKey === \"undefined\" &&\n            typeof this.account !== \"undefined\"\n        ) {\n            executionPrivateKey = this.account.privateKey();\n        }\n\n        if (typeof executionPrivateKey === \"undefined\") {\n            throw \"No private key provided and no private key set in the ProgramManager\";\n        }\n\n        // Get the proving and verifying keys from the key provider\n        let feeKeys;\n        let transferKeys;\n        try {\n            feeKeys = privateFee\n                ? <FunctionKeyPair>await this.keyProvider.feePrivateKeys()\n                : <FunctionKeyPair>await this.keyProvider.feePublicKeys();\n            transferKeys = <FunctionKeyPair>(\n                await this.keyProvider.transferKeys(transferType)\n            );\n        } catch (e: any) {\n            logAndThrow(\n                `Error finding fee keys. Key finder response: '${e.message}'. Please ensure your key provider is configured correctly.`,\n            );\n        }\n        const [feeProvingKey, feeVerifyingKey] = feeKeys;\n        const [transferProvingKey, transferVerifyingKey] = transferKeys;\n\n        // Get the amount and fee record from the account if it is not provided in the parameters\n        try {\n            // Track the nonces of the records found so no duplicate records are used\n            const nonces: string[] = [];\n            if (requiresAmountRecord(transferType)) {\n                // If the transfer type is private and requires an amount record, get it from the record provider\n                amountRecord = <RecordPlaintext>(\n                    await this.getCreditsRecord(\n                        priorityFee,\n                        [],\n                        amountRecord,\n                        recordSearchParams,\n                    )\n                );\n                nonces.push(amountRecord.nonce());\n            } else {\n                amountRecord = undefined;\n            }\n            feeRecord = privateFee\n                ? <RecordPlaintext>(\n                      await this.getCreditsRecord(\n                          priorityFee,\n                          nonces,\n                          feeRecord,\n                          recordSearchParams,\n                      )\n                  )\n                : undefined;\n        } catch (e: any) {\n            logAndThrow(\n                `Error finding fee record. Record finder response: '${e.message}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`,\n            );\n        }\n\n        // Build an execution transaction\n        return await WasmProgramManager.buildTransferTransaction(\n            executionPrivateKey,\n            amount,\n            recipient,\n            transferType,\n            amountRecord,\n            priorityFee,\n            feeRecord,\n            this.host,\n            transferProvingKey,\n            transferVerifyingKey,\n            feeProvingKey,\n            feeVerifyingKey,\n            offlineQuery,\n        );\n    }\n\n    /**\n     * Build a transfer_public transaction to transfer credits to another account for later submission to the Aleo network\n     *\n     * @param {number} amount The amount of credits to transfer\n     * @param {string} recipient The recipient of the transfer\n     * @param {number} priorityFee The optional priority fee to be paid for the transfer\n     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transfer transaction\n     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment\n     * @returns {Promise<Transaction>} The transaction object\n     *\n     * @example\n     * /// Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     * keyProvider.useCache = true;\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for executions\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * const tx = await programManager.buildTransferPublicTransaction(1, \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\", 0.2);\n     * await programManager.networkClient.submitTransaction(tx.toString());\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx.id());\n     *  assert(transaction.id() === tx.id());\n     * }, 10000);\n     */\n    async buildTransferPublicTransaction(\n        amount: number,\n        recipient: string,\n        priorityFee: number,\n        privateKey?: PrivateKey,\n        offlineQuery?: OfflineQuery,\n    ): Promise<Transaction> {\n        return this.buildTransferTransaction(\n            amount,\n            recipient,\n            \"public\",\n            priorityFee,\n            false,\n            undefined,\n            undefined,\n            undefined,\n            privateKey,\n            offlineQuery,\n        );\n    }\n\n    /**\n     * Build a transfer_public_as_signer transaction to transfer credits to another account for later submission to the Aleo network\n     *\n     * @param {number} amount The amount of credits to transfer\n     * @param {string} recipient The recipient of the transfer\n     * @param {number} priorityFee The optional priority fee to be paid for the transfer\n     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transfer transaction\n     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment\n     * @returns {Promise<Transaction>} The transaction object\n     *\n     * @example\n     * /// Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     * keyProvider.useCache = true;\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for executions\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * const tx = await programManager.buildTransferPublicAsSignerTransaction(1, \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\", 0.2);\n     * await programManager.networkClient.submitTransaction(tx.toString());\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx.id());\n     *  assert(transaction.id() === tx.id());\n     * }, 10000);\n     */\n    async buildTransferPublicAsSignerTransaction(\n        amount: number,\n        recipient: string,\n        priorityFee: number,\n        privateKey?: PrivateKey,\n        offlineQuery?: OfflineQuery,\n    ): Promise<Transaction> {\n        return this.buildTransferTransaction(\n            amount,\n            recipient,\n            \"public\",\n            priorityFee,\n            false,\n            undefined,\n            undefined,\n            undefined,\n            privateKey,\n            offlineQuery,\n        );\n    }\n\n    /**\n     * Transfer credits to another account\n     *\n     * @param {number} amount The amount of credits to transfer\n     * @param {string} recipient The recipient of the transfer\n     * @param {string} transferType The type of transfer to perform - options: 'private', 'privateToPublic', 'public', 'publicToPrivate'\n     * @param {number} priorityFee The optional priority fee to be paid for the transfer\n     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance\n     * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for finding the amount and fee records for the transfer transaction\n     * @param {RecordPlaintext | string} amountRecord Optional amount record to use for the transfer\n     * @param {RecordPlaintext | string} feeRecord Optional fee record to use for the transfer\n     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transfer transaction\n     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment\n     * @returns {Promise<string>} The transaction id\n     *\n     * @example\n     * /// Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     * keyProvider.useCache = true;\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for executions\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * const tx_id = await programManager.transfer(1, \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\", \"public\", 0.2, false);\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx_id);\n     *  assert(transaction.id() === tx_id);\n     * }, 10000);\n     */\n    async transfer(\n        amount: number,\n        recipient: string,\n        transferType: string,\n        priorityFee: number,\n        privateFee: boolean,\n        recordSearchParams?: RecordSearchParams,\n        amountRecord?: RecordPlaintext | string,\n        feeRecord?: RecordPlaintext | string,\n        privateKey?: PrivateKey,\n        offlineQuery?: OfflineQuery,\n    ): Promise<string> {\n        const tx = <Transaction>(\n            await this.buildTransferTransaction(\n                amount,\n                recipient,\n                transferType,\n                priorityFee,\n                privateFee,\n                recordSearchParams,\n                amountRecord,\n                feeRecord,\n                privateKey,\n                offlineQuery,\n            )\n        );\n\n        let feeAddress;\n\n        if (typeof privateKey !== \"undefined\") {\n            feeAddress = Address.from_private_key(privateKey);\n        } else if (this.account !== undefined) {\n            feeAddress = this.account?.address();\n        } else {\n            throw Error(\n                \"No private key provided and no private key set in the ProgramManager. Please set an account or provide a private key.\",\n            );\n        }\n\n        // Check if the account has sufficient credits to pay for the transaction\n        await this.checkFee(feeAddress.to_string(), tx.feeAmount());\n\n        return await this.networkClient.submitTransaction(tx);\n    }\n\n    /**\n     * Build transaction to bond credits to a validator for later submission to the Aleo Network\n     *\n     * @param {string} validator_address Address of the validator to bond to, if this address is the same as the staker (i.e. the executor of this function), it will attempt to bond the credits as a validator. Bonding as a validator currently requires a minimum of 10,000,000 credits to bond (subject to change). If the address is specified is an existing validator and is different from the address of the executor of this function, it will bond the credits to that validator's staking committee as a delegator. A minimum of 10 credits is required to bond as a delegator.\n     * @param {string} withdrawal_address Address to withdraw the staked credits to when unbond_public is called.\n     * @param {number} amount The amount of credits to bond\n     * @param {Partial<ExecuteOptions>} options - Override default execution options.\n     * @returns {Promise<Transaction>} The transaction object\n     *\n     * @example\n     * // Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to bond credits\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, undefined);\n     * programManager.setAccount(new Account(\"YourPrivateKey\"));\n     *\n     * // Create the bonding transaction object for later submission\n     * const tx = await programManager.buildBondPublicTransaction(\"aleo1jx8s4dvjepculny4wfrzwyhs3tlyv65r58ns3g6q2gm2esh7ps8sqy9s5j\", \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\", \"aleo1feya8sjy9k2zflvl2dx39pdsq5tju28elnp2ektnn588uu9ghv8s84msv9\", 2000000);\n     *\n     * // The transaction can be later submitted to the network using the network client.\n     * await programManager.networkClient.submitTransaction(tx.toString());\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx.id());\n     *  assert(transaction.id() === tx.id());\n     * }, 10000);\n     */\n    async buildBondPublicTransaction(\n        validator_address: string,\n        withdrawal_address: string,\n        amount: number,\n        options: Partial<ExecuteOptions> = {},\n    ) {\n        const scaledAmount = Math.trunc(amount * 1000000);\n\n        const {\n            programName = \"credits.aleo\",\n            functionName = \"bond_public\",\n            priorityFee = options.priorityFee || 0,\n            privateFee = false,\n            inputs = [\n                validator_address,\n                withdrawal_address,\n                `${scaledAmount.toString()}u64`,\n            ],\n            keySearchParams = new AleoKeyProviderParams({\n                proverUri: CREDITS_PROGRAM_KEYS.bond_public.prover,\n                verifierUri: CREDITS_PROGRAM_KEYS.bond_public.verifier,\n                cacheKey: \"credits.aleo/bond_public\",\n            }),\n            program = this.creditsProgram(),\n            ...additionalOptions\n        } = options;\n\n        const executeOptions: ExecuteOptions = {\n            programName,\n            functionName,\n            priorityFee,\n            privateFee,\n            inputs,\n            keySearchParams,\n            ...additionalOptions,\n        };\n\n        return await this.buildExecutionTransaction(executeOptions);\n    }\n\n    /**\n     * Bond credits to validator.\n     *\n     * @param {string} validator_address Address of the validator to bond to, if this address is the same as the signer (i.e. the executor of this function), it will attempt to bond the credits as a validator. Bonding as a validator currently requires a minimum of 1,000,000 credits to bond (subject to change). If the address is specified is an existing validator and is different from the address of the executor of this function, it will bond the credits to that validator's staking committee as a delegator. A minimum of 10 credits is required to bond as a delegator.\n     * @param {string} withdrawal_address Address to withdraw the staked credits to when unbond_public is called.\n     * @param {number} amount The amount of credits to bond\n     * @param {Options} options Options for the execution\n     * @returns {Promise<string>} The transaction id\n     *\n     * @example\n     * // Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to bond credits\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, undefined);\n     *\n     * // Create the bonding transaction\n     * tx_id = await programManager.bondPublic(\"aleo1jx8s4dvjepculny4wfrzwyhs3tlyv65r58ns3g6q2gm2esh7ps8sqy9s5j\", \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\", \"aleo1feya8sjy9k2zflvl2dx39pdsq5tju28elnp2ektnn588uu9ghv8s84msv9\", 2000000);\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx_id);\n     *  assert(transaction.id() === tx_id);\n     * }, 10000);\n     */\n    async bondPublic(\n        validator_address: string,\n        withdrawal_address: string,\n        amount: number,\n        options: Partial<ExecuteOptions> = {},\n    ) {\n        const tx = <Transaction>(\n            await this.buildBondPublicTransaction(\n                validator_address,\n                withdrawal_address,\n                amount,\n                options,\n            )\n        );\n\n        let feeAddress;\n\n        if (typeof options.privateKey !== \"undefined\") {\n            feeAddress = Address.from_private_key(options.privateKey);\n        } else if (this.account !== undefined) {\n            feeAddress = this.account?.address();\n        } else {\n            throw Error(\n                \"No private key provided and no private key set in the ProgramManager. Please set an account or provide a private key.\",\n            );\n        }\n\n        // Check if the account has sufficient credits to pay for the transaction\n        await this.checkFee(feeAddress.to_string(), tx.feeAmount());\n\n        return await this.networkClient.submitTransaction(tx);\n    }\n\n    /**\n     * Build a bond_validator transaction for later submission to the Aleo Network.\n     *\n     * @param {string} validator_address Address of the validator to bond to, if this address is the same as the staker (i.e. the executor of this function), it will attempt to bond the credits as a validator. If the address is specified is an existing validator and is different from the address of the executor of this function, it will bond the credits to that validator's staking committee as a delegator.\n     * @param {string} withdrawal_address Address to withdraw the staked credits to when unbond_public is called.\n     * @param {number} amount The amount of credits to bond. A minimum of 10000 credits is required to bond as a delegator.\n     * @param {number} commission The commission rate for the validator (must be between 0 and 100 - an error will be thrown if it is not)\n     * @param {Partial<ExecuteOptions>} options - Override default execution options.\n     * @returns {Promise<Transaction>} The transaction object\n     *\n     * @example\n     * // Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to bond credits\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, undefined);\n     * programManager.setAccount(new Account(\"YourPrivateKey\"));\n     *\n     * // Create the bond validator transaction object for later use.\n     * const tx = await programManager.buildBondValidatorTransaction(\"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\", \"aleo1feya8sjy9k2zflvl2dx39pdsq5tju28elnp2ektnn588uu9ghv8s84msv9\", 2000000);\n     *\n     * // The transaction can later be submitted to the network using the network client.\n     * const tx_id = await programManager.networkClient.submitTransaction(tx.toString());\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx_id);\n     *  assert(transaction.id() === tx_id);\n     * }, 10000);\n     */\n    async buildBondValidatorTransaction(\n        validator_address: string,\n        withdrawal_address: string,\n        amount: number,\n        commission: number,\n        options: Partial<ExecuteOptions> = {},\n    ) {\n        const scaledAmount = Math.trunc(amount * 1000000);\n\n        const adjustedCommission = Math.trunc(commission);\n\n        const {\n            programName = \"credits.aleo\",\n            functionName = \"bond_validator\",\n            priorityFee = options.priorityFee || 0,\n            privateFee = false,\n            inputs = [\n                validator_address,\n                withdrawal_address,\n                `${scaledAmount.toString()}u64`,\n                `${adjustedCommission.toString()}u8`,\n            ],\n            keySearchParams = new AleoKeyProviderParams({\n                proverUri: CREDITS_PROGRAM_KEYS.bond_validator.prover,\n                verifierUri: CREDITS_PROGRAM_KEYS.bond_validator.verifier,\n                cacheKey: \"credits.aleo/bond_validator\",\n            }),\n            program = this.creditsProgram(),\n            ...additionalOptions\n        } = options;\n\n        const executeOptions: ExecuteOptions = {\n            programName,\n            functionName,\n            priorityFee,\n            privateFee,\n            inputs,\n            keySearchParams,\n            ...additionalOptions,\n        };\n\n        return await this.buildExecutionTransaction(executeOptions);\n    }\n\n    /**\n     * Build transaction to bond a validator.\n     *\n     * @param {string} validator_address Address of the validator to bond to, if this address is the same as the staker (i.e. the executor of this function), it will attempt to bond the credits as a validator. Bonding as a validator currently requires a minimum of 10,000,000 credits to bond (subject to change). If the address is specified is an existing validator and is different from the address of the executor of this function, it will bond the credits to that validator's staking committee as a delegator. A minimum of 10 credits is required to bond as a delegator.\n     * @param {string} withdrawal_address Address to withdraw the staked credits to when unbond_public is called.\n     * @param {number} amount The amount of credits to bond\n     * @param {number} commission The commission rate for the validator (must be between 0 and 100 - an error will be thrown if it is not)\n     * @param {Partial<ExecuteOptions>} options - Override default execution options.\n     * @returns {Promise<string>} The transaction id\n     *\n     * @example\n     * // Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to bond credits\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, undefined);\n     * programManager.setAccount(new Account(\"YourPrivateKey\"));\n     *\n     * // Create the bonding transaction\n     * const tx_id = await programManager.bondValidator(\"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\", \"aleo1feya8sjy9k2zflvl2dx39pdsq5tju28elnp2ektnn588uu9ghv8s84msv9\", 2000000);\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx_id);\n     *  assert(transaction.id() === tx_id);\n     * }, 10000);\n     */\n    async bondValidator(\n        validator_address: string,\n        withdrawal_address: string,\n        amount: number,\n        commission: number,\n        options: Partial<ExecuteOptions> = {},\n    ) {\n        const tx = <Transaction>(\n            await this.buildBondValidatorTransaction(\n                validator_address,\n                withdrawal_address,\n                amount,\n                commission,\n                options,\n            )\n        );\n\n        let feeAddress;\n\n        if (typeof options.privateKey !== \"undefined\") {\n            feeAddress = Address.from_private_key(options.privateKey);\n        } else if (this.account !== undefined) {\n            feeAddress = this.account?.address();\n        } else {\n            throw Error(\n                \"No private key provided and no private key set in the ProgramManager. Please set an account or provide a private key.\",\n            );\n        }\n\n        // Check if the account has sufficient credits to pay for the transaction\n        await this.checkFee(feeAddress.to_string(), tx.feeAmount());\n\n        return await this.networkClient.submitTransaction(tx);\n    }\n\n    /**\n     * Build an unbond_public execution transaction to unbond credits from a validator in the Aleo network.\n     *\n     * @param {string} staker_address - The address of the staker who is unbonding the credits.\n     * @param {number} amount - The amount of credits to unbond (scaled by 1,000,000).\n     * @param {Partial<ExecuteOptions>} options - Override default execution options.\n     * @returns {Promise<Transaction>} - A promise that resolves to the transaction or an error message.\n     *\n     * @example\n     * // Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a keyProvider to handle key management.\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to unbond credits.\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, undefined);\n     * const tx = await programManager.buildUnbondPublicTransaction(\"aleo1jx8s4dvjepculny4wfrzwyhs3tlyv65r58ns3g6q2gm2esh7ps8sqy9s5j\", 2000000);\n     *\n     * // The transaction can be submitted later to the network using the network client.\n     * programManager.networkClient.submitTransaction(tx.toString());\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx.id());\n     *  assert(transaction.id() === tx.id());\n     * }, 10000);\n     */\n    async buildUnbondPublicTransaction(\n        staker_address: string,\n        amount: number,\n        options: Partial<ExecuteOptions> = {},\n    ): Promise<Transaction> {\n        const scaledAmount = Math.trunc(amount * 1000000);\n\n        const {\n            programName = \"credits.aleo\",\n            functionName = \"unbond_public\",\n            priorityFee = options.priorityFee || 0,\n            privateFee = false,\n            inputs = [staker_address, `${scaledAmount.toString()}u64`],\n            keySearchParams = new AleoKeyProviderParams({\n                proverUri: CREDITS_PROGRAM_KEYS.unbond_public.prover,\n                verifierUri: CREDITS_PROGRAM_KEYS.unbond_public.verifier,\n                cacheKey: \"credits.aleo/unbond_public\",\n            }),\n            program = this.creditsProgram(),\n            ...additionalOptions\n        } = options;\n\n        const executeOptions: ExecuteOptions = {\n            programName,\n            functionName,\n            priorityFee,\n            privateFee,\n            inputs,\n            keySearchParams,\n            ...additionalOptions,\n        };\n\n        return this.buildExecutionTransaction(executeOptions);\n    }\n\n    /**\n     * Unbond a specified amount of staked credits. If the address of the executor of this function is an existing\n     * validator, it will subtract this amount of credits from the validator's staked credits. If there are less than\n     * 1,000,000 credits staked pool after the unbond, the validator will be removed from the validator set. If the\n     * address of the executor of this function is not a validator and has credits bonded as a delegator, it will\n     * subtract this amount of credits from the delegator's staked credits. If there are less than 10 credits bonded\n     * after the unbond operation, the delegator will be removed from the validator's staking pool.\n     *\n     * @param {string} staker_address Address of the staker who is unbonding the credits\n     * @param {number} amount Amount of credits to unbond.\n     * @param {ExecuteOptions} options Options for the execution\n     * @returns {Promise<string>} The transaction id\n     *\n     * @example\n     * // Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to bond credits\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, undefined);\n     * programManager.setAccount(new Account(\"YourPrivateKey\"));\n     *\n     * // Create the unbond_public transaction and send it to the network\n     * const tx_id = await programManager.unbondPublic(\"aleo1jx8s4dvjepculny4wfrzwyhs3tlyv65r58ns3g6q2gm2esh7ps8sqy9s5j\", 10);\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx_id);\n     *  assert(transaction.id() === tx_id);\n     * }, 10000);\n     */\n    async unbondPublic(\n        staker_address: string,\n        amount: number,\n        options: Partial<ExecuteOptions> = {},\n    ): Promise<string> {\n        const tx = <Transaction>(\n            await this.buildUnbondPublicTransaction(\n                staker_address,\n                amount,\n                options,\n            )\n        );\n\n        let feeAddress;\n\n        if (typeof options.privateKey !== \"undefined\") {\n            feeAddress = Address.from_private_key(options.privateKey);\n        } else if (this.account !== undefined) {\n            feeAddress = this.account?.address();\n        } else {\n            throw Error(\n                \"No private key provided and no private key set in the ProgramManager. Please set an account or provide a private key.\",\n            );\n        }\n\n        // Check if the account has sufficient credits to pay for the transaction\n        await this.checkFee(feeAddress.to_string(), tx.feeAmount());\n\n        return await this.networkClient.submitTransaction(tx);\n    }\n\n    /**\n     * Build a transaction to claim unbonded public credits in the Aleo network.\n     *\n     * @param {string} staker_address - The address of the staker who is claiming the credits.\n     * @param {Partial<ExecuteOptions>} options - Override default execution options.\n     * @returns {Promise<Transaction>} - A promise that resolves to the transaction or an error message.\n     *\n     * @example\n     * // Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to claim unbonded credits.\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, undefined);\n     *\n     * // Create the claim_unbond_public transaction object for later use.\n     * const tx = await programManager.buildClaimUnbondPublicTransaction(\"aleo1jx8s4dvjepculny4wfrzwyhs3tlyv65r58ns3g6q2gm2esh7ps8sqy9s5j\");\n     *\n     * // The transaction can be submitted later to the network using the network client.\n     * programManager.networkClient.submitTransaction(tx.toString());\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx.id());\n     *  assert(transaction.id() === tx.id());\n     * }, 10000);\n     */\n    async buildClaimUnbondPublicTransaction(\n        staker_address: string,\n        options: Partial<ExecuteOptions> = {},\n    ): Promise<Transaction> {\n        const {\n            programName = \"credits.aleo\",\n            functionName = \"claim_unbond_public\",\n            priorityFee = options.priorityFee || 0,\n            privateFee = false,\n            inputs = [staker_address],\n            keySearchParams = new AleoKeyProviderParams({\n                proverUri: CREDITS_PROGRAM_KEYS.claim_unbond_public.prover,\n                verifierUri: CREDITS_PROGRAM_KEYS.claim_unbond_public.verifier,\n                cacheKey: \"credits.aleo/claim_unbond_public\",\n            }),\n            program = this.creditsProgram(),\n            ...additionalOptions\n        } = options;\n\n        const executeOptions: ExecuteOptions = {\n            programName,\n            functionName,\n            priorityFee,\n            privateFee,\n            inputs,\n            keySearchParams,\n            ...additionalOptions,\n        };\n\n        // Check if the account has sufficient credits to pay for the transaction\n        return await this.buildExecutionTransaction(executeOptions);\n    }\n\n    /**\n     * Claim unbonded credits. If credits have been unbonded by the account executing this function, this method will\n     * claim them and add them to the public balance of the account.\n     *\n     * @param {string} staker_address Address of the staker who is claiming the credits\n     * @param {ExecuteOptions} options\n     * @returns {Promise<string>} The transaction id\n     *\n     * @example\n     * // Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to bond credits\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, undefined);\n     * programManager.setAccount(new Account(\"YourPrivateKey\"));\n     *\n     * // Create the claim_unbond_public transaction\n     * const tx_id = await programManager.claimUnbondPublic(\"aleo1jx8s4dvjepculny4wfrzwyhs3tlyv65r58ns3g6q2gm2esh7ps8sqy9s5j\");\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx_id);\n     *  assert(transaction.id() === tx_id);\n     * }, 10000);\n     */\n    async claimUnbondPublic(\n        staker_address: string,\n        options: Partial<ExecuteOptions> = {},\n    ): Promise<string> {\n        const tx = <Transaction>(\n            await this.buildClaimUnbondPublicTransaction(\n                staker_address,\n                options,\n            )\n        );\n\n        let feeAddress;\n\n        if (typeof options.privateKey !== \"undefined\") {\n            feeAddress = Address.from_private_key(options.privateKey);\n        } else if (this.account !== undefined) {\n            feeAddress = this.account?.address();\n        } else {\n            throw Error(\n                \"No private key provided and no private key set in the ProgramManager. Please set an account or provide a private key.\",\n            );\n        }\n\n        // Check if the account has sufficient credits to pay for the transaction\n        await this.checkFee(feeAddress.to_string(), tx.feeAmount());\n\n        return await this.networkClient.submitTransaction(tx);\n    }\n\n    /**\n     * Build a set_validator_state transaction for later usage.\n     *\n     * This function allows a validator to set their state to be either opened or closed to new stakers.\n     * When the validator is open to new stakers, any staker (including the validator) can bond or unbond from the validator.\n     * When the validator is closed to new stakers, existing stakers can still bond or unbond from the validator, but new stakers cannot bond.\n     *\n     * This function serves two primary purposes:\n     * 1. Allow a validator to leave the committee, by closing themselves to stakers and then unbonding all of their stakers.\n     * 2. Allow a validator to maintain their % of stake, by closing themselves to allowing more stakers to bond to them.\n     *\n     * @param {boolean} validator_state\n     * @param {Partial<ExecuteOptions>} options - Override default execution options\n     * @returns {Promise<Transaction>} The transaction object\n     *\n     * @example\n     * // Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to bond credits\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, undefined);\n     *\n     * // Create the set_validator_state transaction\n     * const tx = await programManager.buildSetValidatorStateTransaction(true);\n     *\n     * // The transaction can be submitted later to the network using the network client.\n     * programManager.networkClient.submitTransaction(tx.toString());\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx.id());\n     *  assert(transaction.id() === tx.id());\n     * }, 10000);\n     */\n    async buildSetValidatorStateTransaction(\n        validator_state: boolean,\n        options: Partial<ExecuteOptions> = {},\n    ): Promise<Transaction> {\n        const {\n            programName = \"credits.aleo\",\n            functionName = \"set_validator_state\",\n            priorityFee = 0,\n            privateFee = false,\n            inputs = [validator_state.toString()],\n            keySearchParams = new AleoKeyProviderParams({\n                proverUri: CREDITS_PROGRAM_KEYS.set_validator_state.prover,\n                verifierUri: CREDITS_PROGRAM_KEYS.set_validator_state.verifier,\n                cacheKey: \"credits.aleo/set_validator_state\",\n            }),\n            ...additionalOptions\n        } = options;\n\n        const executeOptions: ExecuteOptions = {\n            programName,\n            functionName,\n            priorityFee,\n            privateFee,\n            inputs,\n            keySearchParams,\n            ...additionalOptions,\n        };\n\n        return await this.buildExecutionTransaction(executeOptions);\n    }\n\n    /**\n     * Submit a set_validator_state transaction to the Aleo Network.\n     *\n     * This function allows a validator to set their state to be either opened or closed to new stakers.\n     * When the validator is open to new stakers, any staker (including the validator) can bond or unbond from the validator.\n     * When the validator is closed to new stakers, existing stakers can still bond or unbond from the validator, but new stakers cannot bond.\n     *\n     * This function serves two primary purposes:\n     * 1. Allow a validator to leave the committee, by closing themselves to stakers and then unbonding all of their stakers.\n     * 2. Allow a validator to maintain their % of stake, by closing themselves to allowing more stakers to bond to them.\n     *\n     * @param {boolean} validator_state\n     * @param {Partial<ExecuteOptions>} options - Override default execution options\n     * @returns {Promise<string>} The transaction id\n     *\n     * @example\n     * // Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to bond credits\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, undefined);\n     *\n     * // Create the set_validator_state transaction\n     * const tx_id = await programManager.setValidatorState(true);\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx_id);\n     *  assert(transaction.id() === tx_id);\n     * }, 10000);\n     */\n    async setValidatorState(\n        validator_state: boolean,\n        options: Partial<ExecuteOptions> = {},\n    ) {\n        const tx = <Transaction>(\n            await this.buildSetValidatorStateTransaction(\n                validator_state,\n                options,\n            )\n        );\n\n        let feeAddress;\n\n        if (typeof options.privateKey !== \"undefined\") {\n            feeAddress = Address.from_private_key(options.privateKey);\n        } else if (this.account !== undefined) {\n            feeAddress = this.account?.address();\n        } else {\n            throw Error(\n                \"No private key provided and no private key set in the ProgramManager. Please set an account or provide a private key.\",\n            );\n        }\n\n        // Check if the account has sufficient credits to pay for the transaction\n        await this.checkFee(feeAddress.to_string(), tx.feeAmount());\n\n        return this.networkClient.submitTransaction(tx);\n    }\n\n    /**\n     * Verify a proof of execution from an offline execution\n     *\n     * @param {executionResponse} executionResponse\n     * @returns {boolean} True if the proof is valid, false otherwise\n     */\n    verifyExecution(executionResponse: ExecutionResponse): boolean {\n        try {\n            const execution = <FunctionExecution>(\n                executionResponse.getExecution()\n            );\n            const function_id = executionResponse.getFunctionId();\n            const program = executionResponse.getProgram();\n            const verifyingKey = executionResponse.getVerifyingKey();\n            return verifyFunctionExecution(\n                execution,\n                verifyingKey,\n                program,\n                function_id,\n            );\n        } catch (e) {\n            console.warn(\n                \"The execution was not found in the response, cannot verify the execution\",\n            );\n            return false;\n        }\n    }\n\n    /**\n     * Create a program object from a program's source code\n     *\n     * @param {string} program Program source code\n     * @returns {Program} The program object\n     */\n    createProgramFromSource(program: string): Program {\n        return Program.fromString(program);\n    }\n\n    /**\n     * Get the credits program object\n     *\n     * @returns {Program} The credits program object\n     */\n    creditsProgram(): Program {\n        return Program.getCreditsProgram();\n    }\n\n    /**\n     * Verify a program is valid\n     *\n     * @param {string} program The program source code\n     */\n    verifyProgram(program: string): boolean {\n        try {\n            <Program>Program.fromString(program);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    // Internal utility function for getting a credits.aleo record\n    async getCreditsRecord(\n        amount: number,\n        nonces: string[],\n        record?: RecordPlaintext | string,\n        params?: RecordSearchParams,\n    ): Promise<RecordPlaintext> {\n        try {\n            return record instanceof RecordPlaintext\n                ? record\n                : RecordPlaintext.fromString(<string>record);\n        } catch (e) {\n            try {\n                const recordProvider = <RecordProvider>this.recordProvider;\n                return <RecordPlaintext>(\n                    await recordProvider.findCreditsRecord(\n                        amount,\n                        true,\n                        nonces,\n                        params,\n                    )\n                );\n            } catch (e: any) {\n                logAndThrow(\n                    `Error finding fee record. Record finder response: '${e.message}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`,\n                );\n            }\n        }\n    }\n}\n\n// Ensure the transfer type requires an amount record\nfunction requiresAmountRecord(transferType: string): boolean {\n    return PRIVATE_TRANSFER_TYPES.has(transferType);\n}\n\n// Validate the transfer type\nfunction validateTransferType(transferType: string): string {\n    return VALID_TRANSFER_TYPES.has(transferType)\n        ? transferType\n        : logAndThrow(\n              `Invalid transfer type '${transferType}'. Valid transfer types are 'private', 'privateToPublic', 'public', and 'publicToPrivate'.`,\n          );\n}\n\nexport { ProgramManager };\n", "import {\n  Address,\n  ComputeKey,\n  PrivateKey,\n  Signature,\n  ViewKey,\n  PrivateKeyCiphertext,\n  RecordCiphertext,\n  RecordPlaintext,\n} from \"./wasm\";\n\ninterface AccountParam {\n  privateKey?: string;\n  seed?: Uint8Array;\n}\n\n/**\n * Key Management class. Enables the creation of a new Aleo Account, importation of an existing account from\n * an existing private key or seed, and message signing and verification functionality. An Aleo Account is generated\n * from a randomly generated seed (number) from which an account private key, view key, and a public account address are\n * derived. The private key lies at the root of an Aleo account. It is a highly sensitive secret and should be protected\n * as it allows for creation of Aleo Program executions and arbitrary value transfers. The View Key allows for decryption\n * of a user's activity on the blockchain. The Address is the public address to which other users of Aleo can send Aleo\n * credits and other records to. This class should only be used in environments where the safety of the underlying key\n * material can be assured.\n *\n * @example\n * import { Account } from \"@provablehq/sdk/testnet.js\";\n *\n * // Create a new account\n * const myRandomAccount = new Account();\n *\n * // Create an account from a randomly generated seed\n * const seed = new Uint8Array([94, 91, 52, 251, 240, 230, 226, 35, 117, 253, 224, 210, 175, 13, 205, 120, 155, 214, 7, 169, 66, 62, 206, 50, 188, 40, 29, 122, 40, 250, 54, 18]);\n * const mySeededAccount = new Account({seed: seed});\n *\n * // Create an account from an existing private key\n * const myExistingAccount = new Account({privateKey: process.env.privateKey});\n *\n * // Sign a message\n * const hello_world = Uint8Array.from([104, 101, 108, 108, 111 119, 111, 114, 108, 100]);\n * const signature = myRandomAccount.sign(hello_world);\n *\n * // Verify a signature\n * assert(myRandomAccount.verify(hello_world, signature));\n */\nexport class Account {\n  _privateKey: PrivateKey;\n  _viewKey: ViewKey;\n  _computeKey: ComputeKey;\n  _address: Address;\n\n  constructor(params: AccountParam = {}) {\n    try {\n      this._privateKey = this.privateKeyFromParams(params);\n    } catch (e) {\n      console.error(\"Wrong parameter\", e);\n      throw new Error(\"Wrong Parameter\");\n    }\n    this._viewKey = ViewKey.from_private_key(this._privateKey);\n    this._computeKey = ComputeKey.from_private_key(this._privateKey);\n    this._address = Address.from_private_key(this._privateKey);\n  }\n\n  /**\n   * Attempts to create an account from a private key ciphertext\n   * @param {PrivateKeyCiphertext | string} ciphertext The encrypted private key ciphertext or its string representation\n   * @param {string} password The password used to decrypt the private key ciphertext\n   * @returns {Account} A new Account instance created from the decrypted private key\n   *\n   * @example\n   * import { Account } from \"@provablehq/sdk/testnet.js\";\n   *\n   * // Create an account object from a previously encrypted ciphertext and password.\n   * const account = Account.fromCiphertext(process.env.ciphertext, process.env.password);\n   */\n  public static fromCiphertext(ciphertext: PrivateKeyCiphertext | string, password: string): Account {\n    try {\n      ciphertext = (typeof ciphertext === \"string\") ? PrivateKeyCiphertext.fromString(ciphertext) : ciphertext;\n      const _privateKey = PrivateKey.fromPrivateKeyCiphertext(ciphertext, password);\n      return new Account({ privateKey: _privateKey.to_string() });\n    } catch(e) {\n      throw new Error(\"Wrong password or invalid ciphertext\");\n    }\n  }\n\n  /**\n   * Creates a PrivateKey from the provided parameters.\n   * @param {AccountParam} params The parameters containing either a private key string or a seed\n   * @returns {PrivateKey} A PrivateKey instance derived from the provided parameters\n   */\n  private privateKeyFromParams(params: AccountParam): PrivateKey {\n    if (params.seed) {\n      return PrivateKey.from_seed_unchecked(params.seed);\n    }\n    if (params.privateKey) {\n      return PrivateKey.from_string(params.privateKey);\n    }\n    return new PrivateKey();\n  }\n\n  /**\n   * Returns the PrivateKey associated with the account.\n   * @returns {PrivateKey} The private key of the account\n   *\n   * @example\n   * import { Account } from \"@provablehq/sdk/testnet.js\";\n   *\n   * const account = new Account();\n   * const privateKey = account.privateKey();\n   */\n  privateKey(): PrivateKey {\n    return this._privateKey;\n  }\n\n  /**\n   * Returns the ViewKey associated with the account.\n   * @returns {ViewKey} The view key of the account\n   *\n   * @example\n   * import { Account } from \"@provablehq/sdk/testnet.js\";\n   *\n   * const account = new Account();\n   * const viewKey = account.viewKey();\n   */\n  viewKey(): ViewKey {\n    return this._viewKey;\n  }\n\n  /**\n   * Returns the ComputeKey associated with the account.\n   * @returns {ComputeKey} The compute key of the account\n   *\n   * @example\n   * import { Account } from \"@provablehq/sdk/testnet.js\";\n   *\n   * const account = new Account();\n   * const computeKey = account.computeKey();\n   */\n  computeKey(): ComputeKey {\n    return this._computeKey;\n  }\n\n  /**\n   * Returns the Aleo address associated with the account.\n   * @returns {Address} The public address of the account\n   *\n   * @example\n   * import { Account } from \"@provablehq/sdk/testnet.js\";\n   *\n   * const account = new Account();\n   * const address = account.address();\n   */\n  address(): Address {\n    return this._address;\n  }\n\n  /**\n   * Deep clones the Account.\n   * @returns {Account} A new Account instance with the same private key\n   *\n   * @example\n   * import { Account } from \"@provablehq/sdk/testnet.js\";\n   *\n   * const account = new Account();\n   * const clonedAccount = account.clone();\n   */\n  clone(): Account {\n    return new Account({ privateKey: this._privateKey.to_string() });\n  }\n\n  /**\n   * Returns the address of the account in a string representation.\n   *\n   * @returns {string} The string representation of the account address\n   */\n  toString(): string {\n    return this.address().to_string()\n  }\n\n  /**\n   * Encrypts the account's private key with a password.\n   *\n   * @param {string} password Password to encrypt the private key.\n   * @returns {PrivateKeyCiphertext} The encrypted private key ciphertext\n   *\n   * @example\n   * import { Account } from \"@provablehq/sdk/testnet.js\";\n   *\n   * const account = new Account();\n   * const ciphertext = account.encryptAccount(\"password\");\n   * process.env.ciphertext = ciphertext.toString();\n   */\n  encryptAccount(password: string): PrivateKeyCiphertext {\n    return this._privateKey.toCiphertext(password);\n  }\n\n  /**\n   * Decrypts an encrypted record string into a plaintext record object.\n   *\n   * @param {string} ciphertext A string representing the ciphertext of a record.\n   * @returns {RecordPlaintext} The decrypted record plaintext\n   *\n   * @example\n   * // Import the AleoNetworkClient and Account classes\n   * import { AleoNetworkClient, Account } from \"@provablehq/sdk/testnet.js\";\n   *\n   * // Create a connection to the Aleo network and an account\n   * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n   * const account = Account.fromCiphertext(process.env.ciphertext!, process.env.password!);\n   *\n   * // Get the record ciphertexts from a transaction.\n   * const transaction = await networkClient.getTransactionObject(\"at1fjy6s9md2v4rgcn3j3q4qndtfaa2zvg58a4uha0rujvrn4cumu9qfazxdd\");\n   * const records = transaction.records();\n   *\n   * // Decrypt any records the account owns.\n   * const decryptedRecords = [];\n   * for (const record of records) {\n   *    if (account.decryptRecord(record)) {\n   *      decryptedRecords.push(record);\n   *    }\n   * }\n   */\n  decryptRecord(ciphertext: string): RecordPlaintext {\n    return this._viewKey.decrypt(ciphertext);\n  }\n\n  /**\n   * Decrypts an array of Record ciphertext strings into an array of record plaintext objects.\n   *\n   * @param {string[]} ciphertexts An array of strings representing the ciphertexts of records.\n   * @returns {RecordPlaintext[]} An array of decrypted record plaintexts\n   *\n   * @example\n   * // Import the AleoNetworkClient and Account classes\n   * import { AleoNetworkClient, Account } from \"@provablehq/sdk/testnet.js\";\n   *\n   * // Create a connection to the Aleo network and an account\n   * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n   * const account = Account.fromCiphertext(process.env.ciphertext!, process.env.password!);\n   *\n   * // Get the record ciphertexts from a transaction.\n   * const transaction = await networkClient.getTransactionObject(\"at1fjy6s9md2v4rgcn3j3q4qndtfaa2zvg58a4uha0rujvrn4cumu9qfazxdd\");\n   * const records = transaction.records();\n   *\n   * // Decrypt any records the account owns. If the account owns no records, the array will be empty.\n   * const decryptedRecords = account.decryptRecords(records);\n   */\n  decryptRecords(ciphertexts: string[]): RecordPlaintext[] {\n    return ciphertexts.map((ciphertext) => this._viewKey.decrypt(ciphertext));\n  }\n\n  /**\n   * Determines whether the account owns a ciphertext record.\n   * @param {RecordCiphertext | string} ciphertext The record ciphertext to check ownership of\n   * @returns {boolean} True if the account owns the record, false otherwise\n   *\n   * @example\n   * // Import the AleoNetworkClient and Account classes\n   * import { AleoNetworkClient, Account } from \"@provablehq/sdk/testnet.js\";\n   *\n   * // Create a connection to the Aleo network and an account\n   * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n   * const account = Account.fromCiphertext(process.env.ciphertext!, process.env.password!);\n   *\n   * // Get the record ciphertexts from a transaction and check ownership of them.\n   * const transaction = await networkClient.getTransactionObject(\"at1fjy6s9md2v4rgcn3j3q4qndtfaa2zvg58a4uha0rujvrn4cumu9qfazxdd\");\n   * const records = transaction.records();\n   *\n   * // Check if the account owns any of the record ciphertexts present in the transaction.\n   * const ownedRecords = [];\n   * for (const record of records) {\n   *    if (account.ownsRecordCiphertext(record)) {\n   *      ownedRecords.push(record);\n   *    }\n   * }\n   */\n  ownsRecordCiphertext(ciphertext: RecordCiphertext | string): boolean {\n    if (typeof ciphertext === 'string') {\n      try {\n        const ciphertextObject = RecordCiphertext.fromString(ciphertext);\n        return ciphertextObject.isOwner(this._viewKey);\n      }\n      catch (e) {\n        return false;\n      }\n    }\n    else {\n      return ciphertext.isOwner(this._viewKey);\n    }\n  }\n\n  /**\n   * Signs a message with the account's private key.\n   * Returns a Signature.\n   *\n   * @param {Uint8Array} message Message to be signed.\n   * @returns {Signature} Signature over the message in bytes.\n   *\n   * @example\n   * // Import the Account class\n   * import { Account } from \"@provablehq/sdk/testnet.js\";\n   *\n   * // Create a connection to the Aleo network and an account\n   * const account = Account.fromCiphertext(process.env.ciphertext, process.env.password);\n   *\n   * // Create an account and a message to sign.\n   * const account = new Account();\n   * const message = Uint8Array.from([104, 101, 108, 108, 111 119, 111, 114, 108, 100])\n   * const signature = account.sign(message);\n   *\n   * // Verify the signature.\n   * assert(account.verify(message, signature));\n   */\n  sign(message: Uint8Array): Signature {\n    return this._privateKey.sign(message);\n  }\n\n  /**\n   * Verifies the Signature on a message.\n   *\n   * @param {Uint8Array} message Message in bytes to be signed.\n   * @param {Signature} signature Signature to be verified.\n   * @returns {boolean} True if the signature is valid, false otherwise.\n   *\n   * @example\n   * // Import the Account class\n   * import { Account } from \"@provablehq/sdk/testnet.js\";\n   *\n   * // Create a connection to the Aleo network and an account\n   * const account = Account.fromCiphertext(process.env.ciphertext, process.env.password);\n   *\n   * // Sign a message.\n   * const message = Uint8Array.from([104, 101, 108, 108, 111 119, 111, 114, 108, 100])\n   * const signature = account.sign(message);\n   *\n   * // Verify the signature.\n   * assert(account.verify(message, signature));\n   */\n  verify(message: Uint8Array, signature: Signature): boolean {\n    return this._address.verify(message, signature);\n  }\n}\n", "import {\n    CachedKeyPair,\n    FunctionKeyPair,\n    FunctionKeyProvider,\n    KeySearchParams,\n} from \"./function-key-provider\";\n\nimport {\n    ProvingKey,\n    VerifyingKey,\n} from \"./wasm\";\n\nimport {\n    CREDITS_PROGRAM_KEYS,\n    PRIVATE_TRANSFER,\n    PRIVATE_TO_PUBLIC_TRANSFER,\n    PUBLIC_TRANSFER,\n    PUBLIC_TO_PRIVATE_TRANSFER,\n    PUBLIC_TRANSFER_AS_SIGNER,\n} from \"./constants\";\n\n/**\n * Search parameters for the offline key provider. This class implements the KeySearchParams interface and includes\n * a convenience method for creating a new instance of this class for each function of the credits.aleo program.\n *\n * @example\n * // If storing a key for a custom program function\n * offlineSearchParams = new OfflineSearchParams(\"myprogram.aleo/myfunction\");\n *\n * // If storing a key for a credits.aleo program function\n * bondPublicKeyParams = OfflineSearchParams.bondPublicKeyParams();\n */\nclass OfflineSearchParams implements KeySearchParams {\n    cacheKey: string | undefined;\n    verifyCreditsKeys: boolean | undefined;\n\n    /**\n     * Create a new OfflineSearchParams instance.\n     *\n     * @param {string} cacheKey - Key used to store the local function proving & verifying keys. This should be stored\n     * under the naming convention \"programName/functionName\" (i.e. \"myprogram.aleo/myfunction\")\n     * @param {boolean} verifyCreditsKeys - Whether to verify the keys against the credits.aleo program,\n     * defaults to false, but should be set to true if using keys from the credits.aleo program\n     */\n    constructor(cacheKey: string, verifyCreditsKeys = false) {\n        this.cacheKey = cacheKey;\n        this.verifyCreditsKeys = verifyCreditsKeys;\n    }\n\n    /**\n     * Create a new OfflineSearchParams instance for the bond_public function of the credits.aleo program.\n     */\n    static bondPublicKeyParams(): OfflineSearchParams {\n        return new OfflineSearchParams(CREDITS_PROGRAM_KEYS.bond_public.locator, true);\n    }\n\n    /**\n     * Create a new OfflineSearchParams instance for the bond_validator function of the credits.aleo program.\n     */\n    static bondValidatorKeyParams(): OfflineSearchParams {\n        return new OfflineSearchParams(CREDITS_PROGRAM_KEYS.bond_validator.locator, true);\n    }\n\n    /**\n     * Create a new OfflineSearchParams instance for the claim_unbond_public function of the\n     */\n    static claimUnbondPublicKeyParams(): OfflineSearchParams {\n        return new OfflineSearchParams(CREDITS_PROGRAM_KEYS.claim_unbond_public.locator, true);\n    }\n\n    /**\n     * Create a new OfflineSearchParams instance for the fee_private function of the credits.aleo program.\n     */\n    static feePrivateKeyParams(): OfflineSearchParams {\n        return new OfflineSearchParams(CREDITS_PROGRAM_KEYS.fee_private.locator, true);\n    }\n\n    /**\n     * Create a new OfflineSearchParams instance for the fee_public function of the credits.aleo program.\n     */\n    static feePublicKeyParams(): OfflineSearchParams {\n        return new OfflineSearchParams(CREDITS_PROGRAM_KEYS.fee_public.locator, true);\n    }\n\n    /**\n     * Create a new OfflineSearchParams instance for the inclusion prover function.\n     */\n    static inclusionKeyParams(): OfflineSearchParams {\n        return new OfflineSearchParams(CREDITS_PROGRAM_KEYS.inclusion.locator, true);\n    }\n\n    /**\n     * Create a new OfflineSearchParams instance for the join function of the credits.aleo program.\n     */\n    static joinKeyParams(): OfflineSearchParams {\n        return new OfflineSearchParams(CREDITS_PROGRAM_KEYS.join.locator, true);\n    }\n\n    /**\n     * Create a new OfflineSearchParams instance for the set_validator_state function of the credits.aleo program.\n     */\n    static setValidatorStateKeyParams(): OfflineSearchParams {\n        return new OfflineSearchParams(CREDITS_PROGRAM_KEYS.set_validator_state.locator, true);\n    }\n\n    /**\n     * Create a new OfflineSearchParams instance for the split function of the credits.aleo program.\n     */\n    static splitKeyParams(): OfflineSearchParams {\n        return new OfflineSearchParams(CREDITS_PROGRAM_KEYS.split.locator, true);\n    }\n\n    /**\n     * Create a new OfflineSearchParams instance for the transfer_private function of the credits.aleo program.\n     */\n    static transferPrivateKeyParams(): OfflineSearchParams {\n        return new OfflineSearchParams(CREDITS_PROGRAM_KEYS.transfer_private.locator, true);\n    }\n\n    /**\n     * Create a new OfflineSearchParams instance for the transfer_private_to_public function of the credits.aleo program.\n     */\n    static transferPrivateToPublicKeyParams(): OfflineSearchParams {\n        return new OfflineSearchParams(CREDITS_PROGRAM_KEYS.transfer_private_to_public.locator, true);\n    }\n\n    /**\n     * Create a new OfflineSearchParams instance for the transfer_public function of the credits.aleo program.\n     */\n    static transferPublicKeyParams(): OfflineSearchParams {\n        return new OfflineSearchParams(CREDITS_PROGRAM_KEYS.transfer_public.locator, true);\n    }\n\n    /**\n     * Create a new OfflineSearchParams instance for the transfer_public_as_signer function of the credits.aleo program.\n     */\n    static transferPublicAsSignerKeyParams(): OfflineSearchParams {\n        return new OfflineSearchParams(CREDITS_PROGRAM_KEYS.transfer_public_as_signer.locator, true);\n    }\n\n    /**\n     * Create a new OfflineSearchParams instance for the transfer_public_to_private function of the credits.aleo program.\n     */\n    static transferPublicToPrivateKeyParams(): OfflineSearchParams {\n        return new OfflineSearchParams(CREDITS_PROGRAM_KEYS.transfer_public_to_private.locator, true);\n    }\n\n    /**\n     * Create a new OfflineSearchParams instance for the unbond_public function of the credits.aleo program.\n     */\n    static unbondPublicKeyParams(): OfflineSearchParams {\n        return new OfflineSearchParams(CREDITS_PROGRAM_KEYS.unbond_public.locator, true);\n    }\n}\n\n/**\n * A key provider meant for building transactions offline on devices such as hardware wallets. This key provider is not\n * able to contact the internet for key material and instead relies on the user to insert Aleo function proving &\n * verifying keys from local storage prior to usage.\n *\n * @example\n * // Create an offline program manager\n * const programManager = new ProgramManager();\n *\n * // Create a temporary account for the execution of the program\n * const account = new Account();\n * programManager.setAccount(account);\n *\n * // Create the proving keys from the key bytes on the offline machine\n * console.log(\"Creating proving keys from local key files\");\n * const program = \"program hello_hello.aleo; function hello: input r0 as u32.public; input r1 as u32.private; add r0 r1 into r2; output r2 as u32.private;\";\n * const myFunctionProver = await getLocalKey(\"/path/to/my/function/hello_hello.prover\");\n * const myFunctionVerifier = await getLocalKey(\"/path/to/my/function/hello_hello.verifier\");\n * const feePublicProvingKeyBytes = await getLocalKey(\"/path/to/credits.aleo/feePublic.prover\");\n *\n * myFunctionProvingKey = ProvingKey.fromBytes(myFunctionProver);\n * myFunctionVerifyingKey = VerifyingKey.fromBytes(myFunctionVerifier);\n * const feePublicProvingKey = ProvingKey.fromBytes(feePublicKeyBytes);\n *\n * // Create an offline key provider\n * console.log(\"Creating offline key provider\");\n * const offlineKeyProvider = new OfflineKeyProvider();\n *\n * // Cache the keys\n * // Cache the proving and verifying keys for the custom hello function\n * OfflineKeyProvider.cacheKeys(\"hello_hello.aleo/hello\", myFunctionProvingKey, myFunctionVerifyingKey);\n *\n * // Cache the proving key for the fee_public function (the verifying key is automatically cached)\n * OfflineKeyProvider.insertFeePublicKey(feePublicProvingKey);\n *\n * // Create an offline query using the latest state root in order to create the inclusion proof\n * const offlineQuery = new OfflineQuery(\"latestStateRoot\");\n *\n * // Insert the key provider into the program manager\n * programManager.setKeyProvider(offlineKeyProvider);\n *\n * // Create the offline search params\n * const offlineSearchParams = new OfflineSearchParams(\"hello_hello.aleo/hello\");\n *\n * // Create the offline transaction\n * const offlineExecuteTx = <Transaction>await this.buildExecutionTransaction(\"hello_hello.aleo\", \"hello\", 1, false, [\"5u32\", \"5u32\"], undefined, offlineSearchParams, undefined, undefined, undefined, undefined, offlineQuery, program);\n *\n * // Broadcast the transaction later on a machine with internet access\n * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n * const txId = await networkClient.broadcastTransaction(offlineExecuteTx);\n */\nclass OfflineKeyProvider implements FunctionKeyProvider {\n    cache: Map<string, CachedKeyPair>;\n\n    constructor() {\n        this.cache = new Map<string, CachedKeyPair>();\n    }\n\n    /**\n     * Get bond_public function keys from the credits.aleo program. The keys must be cached prior to calling this\n     * method for it to work.\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the bond_public function\n     */\n    bondPublicKeys(): Promise<FunctionKeyPair> {\n        return this.functionKeys(OfflineSearchParams.bondPublicKeyParams());\n    };\n\n    /**\n     * Get bond_validator function keys from the credits.aleo program. The keys must be cached prior to calling this\n     * method for it to work.\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the bond_public function\n     */\n    bondValidatorKeys(): Promise<FunctionKeyPair> {\n        return this.functionKeys(OfflineSearchParams.bondValidatorKeyParams());\n    };\n\n\n    /**\n     * Cache a set of keys. This will overwrite any existing keys with the same keyId. The user can check if a keyId\n     * exists in the cache using the containsKeys method prior to calling this method if overwriting is not desired.\n     *\n     * @param {string} keyId access key for the cache\n     * @param {FunctionKeyPair} keys keys to cache\n     */\n    cacheKeys(keyId: string, keys: FunctionKeyPair): void {\n        const [provingKey, verifyingKey] = keys;\n        this.cache.set(keyId, [provingKey.toBytes(), verifyingKey.toBytes()]);\n    };\n\n    /**\n     * Get unbond_public function keys from the credits.aleo program. The keys must be cached prior to calling this\n     * method for it to work.\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the unbond_public function\n     */\n    claimUnbondPublicKeys(): Promise<FunctionKeyPair> {\n        return this.functionKeys(OfflineSearchParams.claimUnbondPublicKeyParams());\n    };\n\n    /**\n     * Get arbitrary function key from the offline key provider cache.\n     *\n     * @param {KeySearchParams | undefined} params - Optional search parameters for the key provider\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the specified program\n     *\n     * @example\n     * /// First cache the keys from local offline resources\n     * const offlineKeyProvider = new OfflineKeyProvider();\n     * const myFunctionVerifyingKey = VerifyingKey.fromString(\"verifier...\");\n     * const myFunctionProvingKeyBytes = await readBinaryFile('./resources/myfunction.prover');\n     * const myFunctionProvingKey = ProvingKey.fromBytes(myFunctionProvingKeyBytes);\n     *\n     * /// Cache the keys for future use with a memorable locator\n     * offlineKeyProvider.cacheKeys(\"myprogram.aleo/myfunction\", [myFunctionProvingKey, myFunctionVerifyingKey]);\n     *\n     * /// When they're needed, retrieve the keys from the cache\n     *\n     * /// First create a search parameter object with the same locator used to cache the keys\n     * const keyParams = new OfflineSearchParams(\"myprogram.aleo/myfunction\");\n     *\n     * /// Then retrieve the keys\n     * const [myFunctionProver, myFunctionVerifier] = await offlineKeyProvider.functionKeys(keyParams);\n     */\n    functionKeys(params?: KeySearchParams): Promise<FunctionKeyPair> {\n        return new Promise((resolve, reject) => {\n            if (params === undefined) {\n                reject(new Error(\"No search parameters provided, cannot retrieve keys\"));\n            } else {\n                const keyId = params.cacheKey;\n                const verifyCreditsKeys = params.verifyCreditsKeys;\n                if (this.cache.has(keyId)) {\n                    const [provingKeyBytes, verifyingKeyBytes] = this.cache.get(keyId) as CachedKeyPair;\n                    const provingKey = ProvingKey.fromBytes(provingKeyBytes);\n                    const verifyingKey = VerifyingKey.fromBytes(verifyingKeyBytes);\n                    if (verifyCreditsKeys) {\n                        const keysMatchExpected = this.verifyCreditsKeys(keyId, provingKey, verifyingKey)\n                        if (!keysMatchExpected) {\n                            reject (new Error(`Cached keys do not match expected keys for ${keyId}`));\n                        }\n                    }\n                    resolve([provingKey, verifyingKey]);\n                } else {\n                    reject(new Error(\"Keys not found in cache for \" + keyId));\n                }\n            }\n        });\n    };\n\n    /**\n     * Determines if the keys for a given credits function match the expected keys.\n     *\n     * @returns {boolean} Whether the keys match the expected keys\n     */\n    verifyCreditsKeys(locator: string, provingKey: ProvingKey, verifyingKey: VerifyingKey): boolean {\n        switch (locator) {\n            case CREDITS_PROGRAM_KEYS.bond_public.locator:\n                return provingKey.isBondPublicProver() && verifyingKey.isBondPublicVerifier();\n            case CREDITS_PROGRAM_KEYS.claim_unbond_public.locator:\n                return provingKey.isClaimUnbondPublicProver() && verifyingKey.isClaimUnbondPublicVerifier();\n            case CREDITS_PROGRAM_KEYS.fee_private.locator:\n                return provingKey.isFeePrivateProver() && verifyingKey.isFeePrivateVerifier();\n            case CREDITS_PROGRAM_KEYS.fee_public.locator:\n                return provingKey.isFeePublicProver() && verifyingKey.isFeePublicVerifier();\n            case CREDITS_PROGRAM_KEYS.inclusion.locator:\n                return provingKey.isInclusionProver() && verifyingKey.isInclusionVerifier();\n            case CREDITS_PROGRAM_KEYS.join.locator:\n                return provingKey.isJoinProver() && verifyingKey.isJoinVerifier();\n            case CREDITS_PROGRAM_KEYS.set_validator_state.locator:\n                return provingKey.isSetValidatorStateProver() && verifyingKey.isSetValidatorStateVerifier();\n            case CREDITS_PROGRAM_KEYS.split.locator:\n                return provingKey.isSplitProver() && verifyingKey.isSplitVerifier();\n            case CREDITS_PROGRAM_KEYS.transfer_private.locator:\n                return provingKey.isTransferPrivateProver() && verifyingKey.isTransferPrivateVerifier();\n            case CREDITS_PROGRAM_KEYS.transfer_private_to_public.locator:\n                return provingKey.isTransferPrivateToPublicProver() && verifyingKey.isTransferPrivateToPublicVerifier();\n            case CREDITS_PROGRAM_KEYS.transfer_public.locator:\n                return provingKey.isTransferPublicProver() && verifyingKey.isTransferPublicVerifier();\n            case CREDITS_PROGRAM_KEYS.transfer_public_to_private.locator:\n                return provingKey.isTransferPublicToPrivateProver() && verifyingKey.isTransferPublicToPrivateVerifier();\n            case CREDITS_PROGRAM_KEYS.unbond_public.locator:\n                return provingKey.isUnbondPublicProver() && verifyingKey.isUnbondPublicVerifier();\n            default:\n                return false;\n        }\n    }\n\n    /**\n     * Get fee_private function keys from the credits.aleo program. The keys must be cached prior to calling this\n     * method for it to work.\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function\n     */\n    feePrivateKeys(): Promise<FunctionKeyPair> {\n        return this.functionKeys(OfflineSearchParams.feePrivateKeyParams());\n    };\n\n    /**\n     * Get fee_public function keys from the credits.aleo program. The keys must be cached prior to calling this\n     * method for it to work.\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function\n     */\n    feePublicKeys(): Promise<FunctionKeyPair> {\n        return this.functionKeys(OfflineSearchParams.feePublicKeyParams());\n    };\n\n    /**\n     * Get join function keys from the credits.aleo program. The keys must be cached prior to calling this\n     * method for it to work.\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function\n     */\n    joinKeys(): Promise<FunctionKeyPair> {\n        return this.functionKeys(OfflineSearchParams.joinKeyParams());\n    };\n\n    /**\n     * Get split function keys from the credits.aleo program. The keys must be cached prior to calling this\n     * method for it to work.\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function\n     */\n    splitKeys(): Promise<FunctionKeyPair> {\n        return this.functionKeys(OfflineSearchParams.splitKeyParams());\n    };\n\n    /**\n     * Get keys for a variant of the transfer function from the credits.aleo program.\n     *\n     *\n     * @param {string} visibility Visibility of the transfer function (private, public, privateToPublic, publicToPrivate)\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the specified transfer function\n     *\n     * @example\n     * // Create a new OfflineKeyProvider\n     * const offlineKeyProvider = new OfflineKeyProvider();\n     *\n     * // Cache the keys for future use with the official locator\n     * const transferPublicProvingKeyBytes = await readBinaryFile('./resources/transfer_public.prover.a74565e');\n     * const transferPublicProvingKey = ProvingKey.fromBytes(transferPublicProvingKeyBytes);\n     *\n     * // Cache the transfer_public keys for future use with the OfflinKeyProvider's convenience method for\n     * // transfer_public (the verifying key will be cached automatically)\n     * offlineKeyProvider.insertTransferPublicKeys(transferPublicProvingKey);\n     *\n     * /// When they're needed, retrieve the keys from the cache\n     * const [transferPublicProvingKey, transferPublicVerifyingKey] = await keyProvider.transferKeys(\"public\");\n     */\n    transferKeys(visibility: string): Promise<FunctionKeyPair> {\n        if (PRIVATE_TRANSFER.has(visibility)) {\n            return this.functionKeys(OfflineSearchParams.transferPrivateKeyParams());\n        } else if (PRIVATE_TO_PUBLIC_TRANSFER.has(visibility)) {\n            return this.functionKeys(OfflineSearchParams.transferPrivateToPublicKeyParams());\n        } else if (PUBLIC_TRANSFER.has(visibility)) {\n            return this.functionKeys(OfflineSearchParams.transferPublicKeyParams());\n        } else if (PUBLIC_TRANSFER_AS_SIGNER.has(visibility)) {\n            return this.functionKeys(OfflineSearchParams.transferPublicAsSignerKeyParams());\n        } else if (PUBLIC_TO_PRIVATE_TRANSFER.has(visibility)) {\n            return this.functionKeys(OfflineSearchParams.transferPublicToPrivateKeyParams());\n        } else {\n            throw new Error(\"Invalid visibility type\");\n        }\n    };\n\n    /**\n     * Get unbond_public function keys from the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function\n     */\n    async unBondPublicKeys(): Promise<FunctionKeyPair> {\n        return this.functionKeys(OfflineSearchParams.unbondPublicKeyParams());\n    };\n\n    /**\n     * Insert the proving and verifying keys for the bond_public function into the cache. Only the proving key needs\n     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check\n     * that the keys match the expected checksum for bond_public before inserting them into the cache.\n     *\n     * @param provingKey\n     */\n    insertBondPublicKeys(provingKey: ProvingKey) {\n        if (provingKey.isBondPublicProver()) {\n            this.cache.set(CREDITS_PROGRAM_KEYS.bond_public.locator, [provingKey.toBytes(), VerifyingKey.bondPublicVerifier().toBytes()]);\n        } else {\n            throw new Error(\"Attempted to insert invalid proving keys for bond_public\");\n        }\n    }\n\n    /**\n     * Insert the proving and verifying keys for the claim_unbond_public function into the cache. Only the proving key needs\n     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check\n     * that the keys match the expected checksum for claim_unbond_public before inserting them into the cache.\n     *\n     * @param provingKey\n     */\n    insertClaimUnbondPublicKeys(provingKey: ProvingKey) {\n        if (provingKey.isClaimUnbondPublicProver()) {\n            this.cache.set(CREDITS_PROGRAM_KEYS.claim_unbond_public.locator, [provingKey.toBytes(), VerifyingKey.claimUnbondPublicVerifier().toBytes()]);\n        } else {\n            throw new Error(\"Attempted to insert invalid proving keys for claim_unbond_public\");\n        }\n    }\n\n    /**\n     * Insert the proving and verifying keys for the fee_private function into the cache. Only the proving key needs\n     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check\n     * that the keys match the expected checksum for fee_private before inserting them into the cache.\n     *\n     * @param provingKey\n     */\n    insertFeePrivateKeys(provingKey: ProvingKey) {\n        if (provingKey.isFeePrivateProver()) {\n            this.cache.set(CREDITS_PROGRAM_KEYS.fee_private.locator, [provingKey.toBytes(), VerifyingKey.feePrivateVerifier().toBytes()]);\n        } else {\n            throw new Error(\"Attempted to insert invalid proving keys for fee_private\");\n        }\n    }\n\n    /**\n     * Insert the proving and verifying keys for the fee_public function into the cache. Only the proving key needs\n     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check\n     * that the keys match the expected checksum for fee_public before inserting them into the cache.\n     *\n     * @param provingKey\n     */\n    insertFeePublicKeys(provingKey: ProvingKey) {\n        if (provingKey.isFeePublicProver()) {\n            this.cache.set(CREDITS_PROGRAM_KEYS.fee_public.locator, [provingKey.toBytes(), VerifyingKey.feePublicVerifier().toBytes()]);\n        } else {\n            throw new Error(\"Attempted to insert invalid proving keys for fee_public\");\n        }\n    }\n\n    /**\n     * Insert the proving and verifying keys for the join function into the cache. Only the proving key needs\n     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check\n     * that the keys match the expected checksum for join before inserting them into the cache.\n     *\n     * @param provingKey\n     */\n    insertJoinKeys(provingKey: ProvingKey) {\n        if (provingKey.isJoinProver()) {\n            this.cache.set(CREDITS_PROGRAM_KEYS.join.locator, [provingKey.toBytes(), VerifyingKey.joinVerifier().toBytes()]);\n        } else {\n            throw new Error(\"Attempted to insert invalid proving keys for join\");\n        }\n    }\n\n    /**\n     * Insert the proving and verifying keys for the set_validator_state function into the cache. Only the proving key needs\n     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check\n     * that the keys match the expected checksum for set_validator_state before inserting them into the cache.\n     *\n     * @param provingKey\n     */\n    insertSetValidatorStateKeys(provingKey: ProvingKey) {\n        if (provingKey.isSetValidatorStateProver()) {\n            this.cache.set(CREDITS_PROGRAM_KEYS.set_validator_state.locator, [provingKey.toBytes(), VerifyingKey.setValidatorStateVerifier().toBytes()]);\n        } else {\n            throw new Error(\"Attempted to insert invalid proving keys for set_validator_state\");\n        }\n    }\n\n    /**\n     * Insert the proving and verifying keys for the split function into the cache. Only the proving key needs\n     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check\n     * that the keys match the expected checksum for split before inserting them into the cache.\n     *\n     * @param provingKey\n     */\n    insertSplitKeys(provingKey: ProvingKey) {\n        if (provingKey.isSplitProver()) {\n            this.cache.set(CREDITS_PROGRAM_KEYS.split.locator, [provingKey.toBytes(), VerifyingKey.splitVerifier().toBytes()]);\n        } else {\n            throw new Error(\"Attempted to insert invalid proving keys for split\");\n        }\n    }\n\n    /**\n     * Insert the proving and verifying keys for the transfer_private function into the cache. Only the proving key needs\n     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check\n     * that the keys match the expected checksum for transfer_private before inserting them into the cache.\n     *\n     * @param provingKey\n     */\n    insertTransferPrivateKeys(provingKey: ProvingKey) {\n        if (provingKey.isTransferPrivateProver()) {\n            this.cache.set(CREDITS_PROGRAM_KEYS.transfer_private.locator, [provingKey.toBytes(), VerifyingKey.transferPrivateVerifier().toBytes()]);\n        } else {\n            throw new Error(\"Attempted to insert invalid proving keys for transfer_private\");\n        }\n    }\n\n    /**\n     * Insert the proving and verifying keys for the transfer_private_to_public function into the cache. Only the proving key needs\n     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check\n     * that the keys match the expected checksum for transfer_private_to_public before inserting them into the cache.\n     *\n     * @param provingKey\n     */\n    insertTransferPrivateToPublicKeys(provingKey: ProvingKey) {\n        if (provingKey.isTransferPrivateToPublicProver()) {\n            this.cache.set(CREDITS_PROGRAM_KEYS.transfer_private_to_public.locator, [provingKey.toBytes(), VerifyingKey.transferPrivateToPublicVerifier().toBytes()]);\n        } else {\n            throw new Error(\"Attempted to insert invalid proving keys for transfer_private_to_public\");\n        }\n    }\n\n    /**\n     * Insert the proving and verifying keys for the transfer_public function into the cache. Only the proving key needs\n     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check\n     * that the keys match the expected checksum for transfer_public before inserting them into the cache.\n     *\n     * @param provingKey\n     */\n    insertTransferPublicKeys(provingKey: ProvingKey) {\n        if (provingKey.isTransferPublicProver()) {\n            this.cache.set(CREDITS_PROGRAM_KEYS.transfer_public.locator, [provingKey.toBytes(), VerifyingKey.transferPublicVerifier().toBytes()]);\n        } else {\n            throw new Error(\"Attempted to insert invalid proving keys for transfer_public\");\n        }\n    }\n\n    /**\n     * Insert the proving and verifying keys for the transfer_public_to_private function into the cache. Only the proving key needs\n     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check\n     * that the keys match the expected checksum for transfer_public_to_private before inserting them into the cache.\n     *\n     * @param provingKey\n     */\n    insertTransferPublicToPrivateKeys(provingKey: ProvingKey) {\n        if (provingKey.isTransferPublicToPrivateProver()) {\n            this.cache.set(CREDITS_PROGRAM_KEYS.transfer_public_to_private.locator, [provingKey.toBytes(), VerifyingKey.transferPublicToPrivateVerifier().toBytes()]);\n        } else {\n            throw new Error(\"Attempted to insert invalid proving keys for transfer_public_to_private\");\n        }\n    }\n\n    insertUnbondPublicKeys(provingKey: ProvingKey) {\n        if (provingKey.isUnbondPublicProver()) {\n            this.cache.set(CREDITS_PROGRAM_KEYS.unbond_public.locator, [provingKey.toBytes(), VerifyingKey.unbondPublicVerifier().toBytes()]);\n        } else {\n            throw new Error(\"Attempted to insert invalid proving keys for unbond_public\");\n        }\n    }\n}\n\n\nexport {OfflineKeyProvider, OfflineSearchParams}\n", "import { RecordPlaintext } from \"./wasm\";\nimport { logAndThrow } from \"./utils\";\nimport { Account } from \"./account\";\nimport { AleoNetworkClient } from \"./network-client\";\n\n/**\n * Interface for record search parameters. This allows for arbitrary search parameters to be passed to record provider\n * implementations.\n */\ninterface RecordSearchParams {\n    [key: string]: any; // This allows for arbitrary keys with any type values\n}\n\n/**\n * Interface for a record provider. A record provider is used to find records for use in deployment and execution\n * transactions on the Aleo Network. A default implementation is provided by the NetworkRecordProvider class. However,\n * a custom implementation can be provided (say if records are synced locally to a database from the network) by\n * implementing this interface.\n */\ninterface RecordProvider {\n    account: Account\n\n    /**\n     * Find a credits.aleo record with a given number of microcredits from the chosen provider\n     *\n     * @param {number} microcredits The number of microcredits to search for\n     * @param {boolean} unspent Whether or not the record is unspent\n     * @param {string[]} nonces Nonces of records already found so they are not found again\n     * @param {RecordSearchParams} searchParameters Additional parameters to search for\n     * @returns {Promise<RecordPlaintext>} The record if found, otherwise an error\n     *\n     * @example\n     * // A class implementing record provider can be used to find a record with a given number of microcredits\n     * const record = await recordProvider.findCreditsRecord(5000, true, []);\n     *\n     * // When a record is found but not yet used, its nonce should be added to the nonces array so that it is not\n     * // found again if a subsequent search is performed\n     * const record2 = await recordProvider.findCreditsRecord(5000, true, [record.nonce()]);\n     *\n     * // When the program manager is initialized with the record provider it will be used to find automatically find\n     * // fee records and amount records for value transfers so that they do not need to be specified manually\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * programManager.transfer(1, \"aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at\", \"public\", 0.5);\n     */\n    findCreditsRecord(microcredits: number, unspent: boolean,  nonces?: string[], searchParameters?: RecordSearchParams): Promise<RecordPlaintext>;\n\n    /**\n     * Find a list of credit.aleo records with a given number of microcredits from the chosen provider\n     *\n     * @param {number} microcreditAmounts A list of separate microcredit amounts to search for (e.g. [5000, 100000])\n     * @param {boolean} unspent Whether or not the record is unspent\n     * @param {string[]} nonces Nonces of records already found so that they are not found again\n     * @param {RecordSearchParams} searchParameters Additional parameters to search for\n     * @returns {Promise<RecordPlaintext[]>} A list of records with a value greater or equal to the amounts specified if such records exist, otherwise an error\n     *\n     * @example\n     * // A class implementing record provider can be used to find a record with a given number of microcredits\n     * const records = await recordProvider.findCreditsRecords([5000, 5000], true, []);\n     *\n     * // When a record is found but not yet used, it's nonce should be added to the nonces array so that it is not\n     * // found again if a subsequent search is performed\n     * const nonces = [];\n     * records.forEach(record => { nonces.push(record.nonce()) });\n     * const records2 = await recordProvider.findCreditsRecord(5000, true, nonces);\n     *\n     * // When the program manager is initialized with the record provider it will be used to find automatically find\n     * // fee records and amount records for value transfers so that they do not need to be specified manually\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * programManager.transfer(1, \"aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at\", \"public\", 0.5);\n     */\n    findCreditsRecords(microcreditAmounts: number[], unspent: boolean, nonces?: string[], searchParameters?: RecordSearchParams): Promise<RecordPlaintext[]>;\n\n    /**\n     * Find an arbitrary record\n     * @param {boolean} unspent Whether or not the record is unspent\n     * @param {string[]} nonces Nonces of records already found so that they are not found again\n     * @param {RecordSearchParams} searchParameters Additional parameters to search for\n     * @returns {Promise<RecordPlaintext>} The record if found, otherwise an error\n     *\n     * @example\n     * // The RecordSearchParams interface can be used to create parameters for custom record searches which can then\n     * // be passed to the record provider. An example of how this would be done for the credits.aleo program is shown\n     * // below.\n     *\n     * class CustomRecordSearch implements RecordSearchParams {\n     *     startHeight: number;\n     *     endHeight: number;\n     *     amount: number;\n     *     program: string;\n     *     recordName: string;\n     *     constructor(startHeight: number, endHeight: number, credits: number, maxRecords: number, programName: string, recordName: string) {\n     *         this.startHeight = startHeight;\n     *         this.endHeight = endHeight;\n     *         this.amount = amount;\n     *         this.program = programName;\n     *         this.recordName = recordName;\n     *     }\n     * }\n     *\n     * const params = new CustomRecordSearch(0, 100, 5000, \"credits.aleo\", \"credits\");\n     *\n     * const record = await recordProvider.findRecord(true, [], params);\n     */\n    findRecord(unspent: boolean, nonces?: string[], searchParameters?: RecordSearchParams): Promise<RecordPlaintext>;\n\n    /**\n     * Find multiple records from arbitrary programs\n     *\n     * @param {boolean} unspent Whether or not the record is unspent\n     * @param {string[]} nonces Nonces of records already found so that they are not found again\n     * @param {RecordSearchParams} searchParameters Additional parameters to search for\n     * @returns {Promise<RecordPlaintext>} The record if found, otherwise an error\n     *\n     * // The RecordSearchParams interface can be used to create parameters for custom record searches which can then\n     * // be passed to the record provider. An example of how this would be done for the credits.aleo program is shown\n     * // below.\n     *\n     * class CustomRecordSearch implements RecordSearchParams {\n     *     startHeight: number;\n     *     endHeight: number;\n     *     amount: number;\n     *     maxRecords: number;\n     *     programName: string;\n     *     recordName: string;\n     *     constructor(startHeight: number, endHeight: number, credits: number, maxRecords: number, programName: string, recordName: string) {\n     *         this.startHeight = startHeight;\n     *         this.endHeight = endHeight;\n     *         this.amount = amount;\n     *         this.maxRecords = maxRecords;\n     *         this.programName = programName;\n     *         this.recordName = recordName;\n     *     }\n     * }\n     *\n     * const params = new CustomRecordSearch(0, 100, 5000, 2, \"credits.aleo\", \"credits\");\n     * const records = await recordProvider.findRecord(true, [], params);\n     */\n    findRecords(unspent: boolean, nonces?: string[], searchParameters?: RecordSearchParams): Promise<RecordPlaintext[]>;\n}\n\n/**\n * A record provider implementation that uses the official Aleo API to find records for usage in program execution and\n * deployment, wallet functionality, and other use cases.\n */\nclass NetworkRecordProvider implements RecordProvider {\n    account: Account;\n    networkClient: AleoNetworkClient;\n    constructor(account: Account, networkClient: AleoNetworkClient) {\n        this.account = account;\n        this.networkClient = networkClient;\n    }\n\n    /**\n     * Set the account used to search for records\n     *\n     * @param {Account} account The account to use for searching for records\n     */\n    setAccount(account: Account) {\n        this.account = account;\n    }\n\n    /**\n     * Find a list of credit records with a given number of microcredits by via the official Aleo API\n     *\n     * @param {number[]} microcredits The number of microcredits to search for\n     * @param {boolean} unspent Whether or not the record is unspent\n     * @param {string[]} nonces Nonces of records already found so that they are not found again\n     * @param {RecordSearchParams} searchParameters Additional parameters to search for\n     * @returns {Promise<RecordPlaintext>} The record if found, otherwise an error\n     *\n     * @example\n     * // Create a new NetworkRecordProvider\n     * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // The record provider can be used to find records with a given number of microcredits\n     * const record = await recordProvider.findCreditsRecord(5000, true, []);\n     *\n     * // When a record is found but not yet used, it's nonce should be added to the nonces parameter so that it is not\n     * // found again if a subsequent search is performed\n     * const records = await recordProvider.findCreditsRecords(5000, true, [record.nonce()]);\n     *\n     * // When the program manager is initialized with the record provider it will be used to find automatically find\n     * // fee records and amount records for value transfers so that they do not need to be specified manually\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * programManager.transfer(1, \"aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at\", \"public\", 0.5);\n     *\n     * */\n    async findCreditsRecords(microcredits: number[], unspent: boolean, nonces?: string[], searchParameters?: RecordSearchParams): Promise<RecordPlaintext[]> {\n        let startHeight = 0;\n        let endHeight = 0;\n        let maxAmount = undefined;\n\n        if (searchParameters) {\n            if (\"startHeight\" in searchParameters && typeof searchParameters[\"startHeight\"] == \"number\") {\n                startHeight = searchParameters[\"startHeight\"];\n            }\n\n            if (\"endHeight\" in searchParameters && typeof searchParameters[\"endHeight\"] == \"number\") {\n                endHeight = searchParameters[\"endHeight\"];\n            }\n\n            if (\"amounts\" in searchParameters && Array.isArray(searchParameters[\"amounts\"]) && searchParameters[\"amount\"].every((item: any) => typeof item === 'number')) {\n                microcredits = searchParameters[\"amounts\"];\n            }\n\n            if (\"maxAmount\" in searchParameters && typeof searchParameters[\"maxAmount\"] == \"number\") {\n                maxAmount = searchParameters[\"maxAmount\"];\n            }\n\n            if (\"unspent\" in searchParameters && typeof searchParameters[\"unspent\"] == \"boolean\") {\n                unspent = searchParameters[\"unspent\"]\n            }\n        }\n\n        // If the end height is not specified, use the current block height\n        if (endHeight == 0) {\n            const end = await this.networkClient.getLatestHeight();\n            endHeight = end;\n        }\n\n        // If the start height is greater than the end height, throw an error\n        if (startHeight >= endHeight) {\n            logAndThrow(\"Start height must be less than end height\");\n        }\n\n        return await this.networkClient.findRecords(startHeight, endHeight, unspent, [\"credits.aleo\"], microcredits, maxAmount, nonces, this.account.privateKey());\n    }\n\n    /**\n     * Find a credit record with a given number of microcredits by via the official Aleo API\n     *\n     * @param {number} microcredits The number of microcredits to search for\n     * @param {boolean} unspent Whether or not the record is unspent\n     * @param {string[]} nonces Nonces of records already found so that they are not found again\n     * @param {RecordSearchParams} searchParameters Additional parameters to search for\n     * @returns {Promise<RecordPlaintext>} The record if found, otherwise an error\n     *\n     * @example\n     * // Create a new NetworkRecordProvider\n     * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // The record provider can be used to find records with a given number of microcredits\n     * const record = await recordProvider.findCreditsRecord(5000, true, []);\n     *\n     * // When a record is found but not yet used, it's nonce should be added to the nonces parameter so that it is not\n     * // found again if a subsequent search is performed\n     * const records = await recordProvider.findCreditsRecords(5000, true, [record.nonce()]);\n     *\n     * // When the program manager is initialized with the record provider it will be used to find automatically find\n     * // fee records and amount records for value transfers so that they do not need to be specified manually\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * programManager.transfer(1, \"aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at\", \"public\", 0.5);\n     */\n    async findCreditsRecord(microcredits: number, unspent: boolean, nonces?: string[], searchParameters?: RecordSearchParams): Promise<RecordPlaintext> {\n        let records = null;\n\n        try {\n            records = await this.findCreditsRecords([microcredits], unspent, nonces, searchParameters);\n        } catch (e) {\n            console.log(\"No records found with error:\", e);\n        }\n\n        if (records && records.length > 0) {\n            return records[0];\n        }\n\n        console.error(\"Record not found with error:\", records);\n        throw new Error(\"Record not found\");\n    }\n\n    /**\n     * Find an arbitrary record. WARNING: This function is not implemented yet and will throw an error.\n     */\n    async findRecord(unspent: boolean, nonces?: string[], searchParameters?: RecordSearchParams): Promise<RecordPlaintext> {\n        throw new Error(\"Not implemented\");\n    }\n\n    /**\n     * Find multiple records from a specified program.\n     */\n    async findRecords(unspent: boolean, nonces?: string[], searchParameters?: RecordSearchParams): Promise<RecordPlaintext[]> {\n        let startHeight = 0;\n        let endHeight = 0;\n        let amounts = undefined;\n        let maxAmount = undefined;\n        let programs = undefined;\n\n        if (searchParameters) {\n            if (\"startHeight\" in searchParameters && typeof searchParameters[\"startHeight\"] == \"number\") {\n                startHeight = searchParameters[\"startHeight\"];\n            }\n\n            if (\"endHeight\" in searchParameters && typeof searchParameters[\"endHeight\"] == \"number\") {\n                endHeight = searchParameters[\"endHeight\"];\n            }\n\n            if (\"amounts\" in searchParameters && Array.isArray(searchParameters[\"amounts\"]) && searchParameters[\"amounts\"].every((item: any) => typeof item === 'number')) {\n                amounts = searchParameters[\"amounts\"];\n            }\n\n            if (\"maxAmount\" in searchParameters && typeof searchParameters[\"maxAmount\"] == \"number\") {\n                maxAmount = searchParameters[\"maxAmount\"];\n            }\n\n            if (\"nonces\" in searchParameters && Array.isArray(searchParameters[\"nonces\"]) && searchParameters[\"nonces\"].every((item: any) => typeof item === \"string\")) {\n                nonces = searchParameters[\"nonces\"];\n            }\n\n            if (\"program\" in searchParameters && typeof searchParameters[\"program\"] == \"string\") {\n                programs = [searchParameters[\"program\"]];\n            }\n\n            if (\"programs\" in searchParameters && Array.isArray(searchParameters[\"programs\"]) && searchParameters[\"programs\"].every((item: any) => typeof item === \"string\")) {\n                programs = searchParameters[\"programs\"];\n            }\n\n            if (\"unspent\" in searchParameters && typeof searchParameters[\"unspent\"] == \"boolean\") {\n                unspent = searchParameters[\"unspent\"]\n            }\n        }\n\n        // If the end height is not specified, use the current block height\n        if (endHeight == 0) {\n            const end = await this.networkClient.getLatestHeight();\n            endHeight = end;\n        }\n\n        // If the start height is greater than the end height, throw an error\n        if (startHeight >= endHeight) {\n            logAndThrow(\"Start height must be less than end height\");\n        }\n\n        return await this.networkClient.findRecords(startHeight, endHeight, unspent, programs, amounts, maxAmount, nonces, this.account.privateKey());\n    }\n\n}\n\n/**\n * BlockHeightSearch is a RecordSearchParams implementation that allows for searching for records within a given\n * block height range.\n *\n * @example\n * // Create a new BlockHeightSearch\n * const params = new BlockHeightSearch(89995, 99995);\n *\n * // Create a new NetworkRecordProvider\n * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n * const keyProvider = new AleoKeyProvider();\n * const recordProvider = new NetworkRecordProvider(account, networkClient);\n *\n * // The record provider can be used to find records with a given number of microcredits and the block height search\n * // can be used to find records within a given block height range\n * const record = await recordProvider.findCreditsRecord(5000, true, [], params);\n *\n */\nclass BlockHeightSearch implements RecordSearchParams {\n    startHeight: number;\n    endHeight: number;\n    constructor(startHeight: number, endHeight: number) {\n        this.startHeight = startHeight;\n        this.endHeight = endHeight;\n    }\n}\n\nexport { BlockHeightSearch, NetworkRecordProvider, RecordProvider, RecordSearchParams};\n", "// Experimental example where SDK manages worker\n\nimport { wrap } from \"comlink\";\nimport { WorkerAPI } from './worker';\n\nlet singletonWorker: WorkerAPI | null = null;\n\nconst createAleoWorker = (): WorkerAPI => {\n    if (!singletonWorker) {\n        const worker = new Worker(new URL(\"worker.js\", import.meta.url), {\n            type: \"module\",\n        });\n        singletonWorker = wrap<WorkerAPI>(worker);\n    }\n    return singletonWorker;\n};\n\nexport { createAleoWorker };", "import \"./polyfill/shared\";\n\nimport { Account } from \"./account\";\nimport { AleoNetworkClient, ProgramImports } from \"./network-client\";\nimport { BlockJSON, Header, Metadata } from \"./models/blockJSON\";\nimport { ConfirmedTransactionJSON } from \"./models/confirmed_transaction\";\nimport { DeploymentJSON, VerifyingKeys } from \"./models/deployment/deploymentJSON\";\nimport { DeploymentObject } from \"./models/deployment/deploymentObject\";\nimport { ExecutionJSON, FeeExecutionJSON } from \"./models/execution/executionJSON\";\nimport { ExecutionObject, FeeExecutionObject } from \"./models/execution/executionObject\";\nimport { FinalizeJSON } from \"./models/finalizeJSON\";\nimport { FunctionObject } from \"./models/functionObject\";\nimport { InputJSON } from \"./models/input/inputJSON\";\nimport { InputObject } from \"./models/input/inputObject\";\nimport { OutputJSON } from \"./models/output/outputJSON\";\nimport { OutputObject } from \"./models/output/outputObject\";\nimport { OwnerJSON } from \"./models/owner/ownerJSON\";\nimport { PlaintextArray} from \"./models/plaintext/array\";\nimport { PlaintextLiteral} from \"./models/plaintext/literal\";\nimport { PlaintextObject } from \"./models/plaintext/plaintext\";\nimport { PlaintextStruct} from \"./models/plaintext/struct\";\nimport { RatificationJSON } from \"./models/ratification\";\nimport { SolutionsJSON, SolutionJSON, PartialSolutionJSON } from \"./models/solution\";\nimport { TransactionJSON } from \"./models/transaction/transactionJSON\";\nimport { TransactionObject } from \"./models/transaction/transactionObject\";\nimport { TransitionJSON } from \"./models/transition/transitionJSON\";\nimport { TransitionObject } from \"./models/transition/transitionObject\";\nimport {\n    AleoKeyProvider,\n    AleoKeyProviderParams,\n    AleoKeyProviderInitParams,\n    CachedKeyPair,\n    FunctionKeyPair,\n    FunctionKeyProvider,\n    KeySearchParams,\n} from \"./function-key-provider\";\nimport {\n    OfflineKeyProvider,\n    OfflineSearchParams\n} from \"./offline-key-provider\";\nimport {\n    BlockHeightSearch,\n    NetworkRecordProvider,\n    RecordProvider,\n    RecordSearchParams,\n} from \"./record-provider\";\n\n// @TODO: This function is no longer needed, remove it.\nasync function initializeWasm() {\n    console.warn(\"initializeWasm is deprecated, you no longer need to use it\");\n}\n\nexport { createAleoWorker } from \"./managed-worker\";\n\nexport { ProgramManager } from \"./program-manager\";\n\nexport { logAndThrow } from \"./utils\";\n\nexport {\n    Address,\n    BHP256,\n    BHP512,\n    BHP768,\n    BHP1024,\n    Ciphertext,\n    ComputeKey,\n    Execution as FunctionExecution,\n    ExecutionResponse,\n    Field,\n    Group,\n    OfflineQuery,\n    Pedersen64,\n    Pedersen128,\n    Plaintext,\n    Poseidon2,\n    Poseidon4,\n    Poseidon8,\n    PrivateKey,\n    PrivateKeyCiphertext,\n    Program,\n    ProgramManager as ProgramManagerBase,\n    ProvingKey,\n    RecordCiphertext,\n    RecordPlaintext,\n    Signature,\n    Scalar,\n    Transaction,\n    Transition,\n    VerifyingKey,\n    ViewKey,\n    initThreadPool,\n    verifyFunctionExecution,\n} from \"./wasm\";\n\nexport { initializeWasm };\n\nexport {\n    Key,\n    CREDITS_PROGRAM_KEYS,\n    KEY_STORE,\n    PRIVATE_TRANSFER,\n    PRIVATE_TO_PUBLIC_TRANSFER,\n    PRIVATE_TRANSFER_TYPES,\n    PUBLIC_TRANSFER,\n    PUBLIC_TRANSFER_AS_SIGNER,\n    PUBLIC_TO_PRIVATE_TRANSFER,\n    VALID_TRANSFER_TYPES,\n} from \"./constants\";\n\nexport {\n    Account,\n    AleoKeyProvider,\n    AleoKeyProviderParams,\n    AleoKeyProviderInitParams,\n    AleoNetworkClient,\n    BlockJSON,\n    BlockHeightSearch,\n    CachedKeyPair,\n    ConfirmedTransactionJSON,\n    DeploymentJSON,\n    DeploymentObject,\n    ExecutionJSON,\n    ExecutionObject,\n    FeeExecutionJSON,\n    FeeExecutionObject,\n    FinalizeJSON,\n    FunctionObject,\n    FunctionKeyPair,\n    FunctionKeyProvider,\n    Header,\n    InputJSON,\n    InputObject,\n    KeySearchParams,\n    Metadata,\n    NetworkRecordProvider,\n    OfflineKeyProvider,\n    OfflineSearchParams,\n    OutputJSON,\n    OutputObject,\n    OwnerJSON,\n    PartialSolutionJSON,\n    PlaintextArray,\n    PlaintextLiteral,\n    PlaintextObject,\n    PlaintextStruct,\n    ProgramImports,\n    RatificationJSON,\n    RecordProvider,\n    RecordSearchParams,\n    SolutionJSON,\n    SolutionsJSON,\n    TransactionJSON,\n    TransactionObject,\n    TransitionJSON,\n    TransitionObject,\n    VerifyingKeys,\n};\n"],
  "mappings": "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",
  "names": ["globalThis", "globalThis", "globalThis", "globalThis", "globalThis", "globalThis", "globalThis", "Symbol", "globalThis", "document", "globalThis", "globalThis", "TypeError", "get", "globalThis", "globalThis", "JSON", "Number", "SyntaxError", "error", "WasmProgramManager", "e", "Address", "PrivateKey", "RecordCiphertext", "ProvingKey", "VerifyingKey"]
}
