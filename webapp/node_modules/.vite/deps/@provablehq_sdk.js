import {
  wrap
} from "./chunk-VHJOBSMS.js";
import {
  __commonJS,
  __publicField
} from "./chunk-DC5AMYBS.js";

// ../../node_modules/core-js/internals/global-this.js
var require_global_this = __commonJS({
  "../../node_modules/core-js/internals/global-this.js"(exports, module) {
    "use strict";
    var check = function(it) {
      return it && it.Math === Math && it;
    };
    module.exports = // eslint-disable-next-line es/no-global-this -- safe
    check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
    check(typeof self == "object" && self) || check(typeof global == "object" && global) || check(typeof exports == "object" && exports) || // eslint-disable-next-line no-new-func -- fallback
    /* @__PURE__ */ function() {
      return this;
    }() || Function("return this")();
  }
});

// ../../node_modules/core-js/internals/fails.js
var require_fails = __commonJS({
  "../../node_modules/core-js/internals/fails.js"(exports, module) {
    "use strict";
    module.exports = function(exec) {
      try {
        return !!exec();
      } catch (error) {
        return true;
      }
    };
  }
});

// ../../node_modules/core-js/internals/descriptors.js
var require_descriptors = __commonJS({
  "../../node_modules/core-js/internals/descriptors.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    module.exports = !fails(function() {
      return Object.defineProperty({}, 1, { get: function() {
        return 7;
      } })[1] !== 7;
    });
  }
});

// ../../node_modules/core-js/internals/function-bind-native.js
var require_function_bind_native = __commonJS({
  "../../node_modules/core-js/internals/function-bind-native.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    module.exports = !fails(function() {
      var test = (function() {
      }).bind();
      return typeof test != "function" || test.hasOwnProperty("prototype");
    });
  }
});

// ../../node_modules/core-js/internals/function-call.js
var require_function_call = __commonJS({
  "../../node_modules/core-js/internals/function-call.js"(exports, module) {
    "use strict";
    var NATIVE_BIND = require_function_bind_native();
    var call = Function.prototype.call;
    module.exports = NATIVE_BIND ? call.bind(call) : function() {
      return call.apply(call, arguments);
    };
  }
});

// ../../node_modules/core-js/internals/object-property-is-enumerable.js
var require_object_property_is_enumerable = __commonJS({
  "../../node_modules/core-js/internals/object-property-is-enumerable.js"(exports) {
    "use strict";
    var $propertyIsEnumerable = {}.propertyIsEnumerable;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
    exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
      var descriptor = getOwnPropertyDescriptor(this, V);
      return !!descriptor && descriptor.enumerable;
    } : $propertyIsEnumerable;
  }
});

// ../../node_modules/core-js/internals/create-property-descriptor.js
var require_create_property_descriptor = __commonJS({
  "../../node_modules/core-js/internals/create-property-descriptor.js"(exports, module) {
    "use strict";
    module.exports = function(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value
      };
    };
  }
});

// ../../node_modules/core-js/internals/function-uncurry-this.js
var require_function_uncurry_this = __commonJS({
  "../../node_modules/core-js/internals/function-uncurry-this.js"(exports, module) {
    "use strict";
    var NATIVE_BIND = require_function_bind_native();
    var FunctionPrototype = Function.prototype;
    var call = FunctionPrototype.call;
    var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
    module.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
      return function() {
        return call.apply(fn, arguments);
      };
    };
  }
});

// ../../node_modules/core-js/internals/classof-raw.js
var require_classof_raw = __commonJS({
  "../../node_modules/core-js/internals/classof-raw.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toString = uncurryThis({}.toString);
    var stringSlice = uncurryThis("".slice);
    module.exports = function(it) {
      return stringSlice(toString(it), 8, -1);
    };
  }
});

// ../../node_modules/core-js/internals/indexed-object.js
var require_indexed_object = __commonJS({
  "../../node_modules/core-js/internals/indexed-object.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var classof = require_classof_raw();
    var $Object = Object;
    var split = uncurryThis("".split);
    module.exports = fails(function() {
      return !$Object("z").propertyIsEnumerable(0);
    }) ? function(it) {
      return classof(it) === "String" ? split(it, "") : $Object(it);
    } : $Object;
  }
});

// ../../node_modules/core-js/internals/is-null-or-undefined.js
var require_is_null_or_undefined = __commonJS({
  "../../node_modules/core-js/internals/is-null-or-undefined.js"(exports, module) {
    "use strict";
    module.exports = function(it) {
      return it === null || it === void 0;
    };
  }
});

// ../../node_modules/core-js/internals/require-object-coercible.js
var require_require_object_coercible = __commonJS({
  "../../node_modules/core-js/internals/require-object-coercible.js"(exports, module) {
    "use strict";
    var isNullOrUndefined = require_is_null_or_undefined();
    var $TypeError = TypeError;
    module.exports = function(it) {
      if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
      return it;
    };
  }
});

// ../../node_modules/core-js/internals/to-indexed-object.js
var require_to_indexed_object = __commonJS({
  "../../node_modules/core-js/internals/to-indexed-object.js"(exports, module) {
    "use strict";
    var IndexedObject = require_indexed_object();
    var requireObjectCoercible = require_require_object_coercible();
    module.exports = function(it) {
      return IndexedObject(requireObjectCoercible(it));
    };
  }
});

// ../../node_modules/core-js/internals/is-callable.js
var require_is_callable = __commonJS({
  "../../node_modules/core-js/internals/is-callable.js"(exports, module) {
    "use strict";
    var documentAll = typeof document == "object" && document.all;
    module.exports = typeof documentAll == "undefined" && documentAll !== void 0 ? function(argument) {
      return typeof argument == "function" || argument === documentAll;
    } : function(argument) {
      return typeof argument == "function";
    };
  }
});

// ../../node_modules/core-js/internals/is-object.js
var require_is_object = __commonJS({
  "../../node_modules/core-js/internals/is-object.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    module.exports = function(it) {
      return typeof it == "object" ? it !== null : isCallable(it);
    };
  }
});

// ../../node_modules/core-js/internals/get-built-in.js
var require_get_built_in = __commonJS({
  "../../node_modules/core-js/internals/get-built-in.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var isCallable = require_is_callable();
    var aFunction = function(argument) {
      return isCallable(argument) ? argument : void 0;
    };
    module.exports = function(namespace, method) {
      return arguments.length < 2 ? aFunction(globalThis2[namespace]) : globalThis2[namespace] && globalThis2[namespace][method];
    };
  }
});

// ../../node_modules/core-js/internals/object-is-prototype-of.js
var require_object_is_prototype_of = __commonJS({
  "../../node_modules/core-js/internals/object-is-prototype-of.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    module.exports = uncurryThis({}.isPrototypeOf);
  }
});

// ../../node_modules/core-js/internals/environment-user-agent.js
var require_environment_user_agent = __commonJS({
  "../../node_modules/core-js/internals/environment-user-agent.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var navigator = globalThis2.navigator;
    var userAgent = navigator && navigator.userAgent;
    module.exports = userAgent ? String(userAgent) : "";
  }
});

// ../../node_modules/core-js/internals/environment-v8-version.js
var require_environment_v8_version = __commonJS({
  "../../node_modules/core-js/internals/environment-v8-version.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var userAgent = require_environment_user_agent();
    var process = globalThis2.process;
    var Deno = globalThis2.Deno;
    var versions = process && process.versions || Deno && Deno.version;
    var v8 = versions && versions.v8;
    var match;
    var version;
    if (v8) {
      match = v8.split(".");
      version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
    }
    if (!version && userAgent) {
      match = userAgent.match(/Edge\/(\d+)/);
      if (!match || match[1] >= 74) {
        match = userAgent.match(/Chrome\/(\d+)/);
        if (match) version = +match[1];
      }
    }
    module.exports = version;
  }
});

// ../../node_modules/core-js/internals/symbol-constructor-detection.js
var require_symbol_constructor_detection = __commonJS({
  "../../node_modules/core-js/internals/symbol-constructor-detection.js"(exports, module) {
    "use strict";
    var V8_VERSION = require_environment_v8_version();
    var fails = require_fails();
    var globalThis2 = require_global_this();
    var $String = globalThis2.String;
    module.exports = !!Object.getOwnPropertySymbols && !fails(function() {
      var symbol = Symbol("symbol detection");
      return !$String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
      !Symbol.sham && V8_VERSION && V8_VERSION < 41;
    });
  }
});

// ../../node_modules/core-js/internals/use-symbol-as-uid.js
var require_use_symbol_as_uid = __commonJS({
  "../../node_modules/core-js/internals/use-symbol-as-uid.js"(exports, module) {
    "use strict";
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    module.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
  }
});

// ../../node_modules/core-js/internals/is-symbol.js
var require_is_symbol = __commonJS({
  "../../node_modules/core-js/internals/is-symbol.js"(exports, module) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var isCallable = require_is_callable();
    var isPrototypeOf = require_object_is_prototype_of();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var $Object = Object;
    module.exports = USE_SYMBOL_AS_UID ? function(it) {
      return typeof it == "symbol";
    } : function(it) {
      var $Symbol = getBuiltIn("Symbol");
      return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
    };
  }
});

// ../../node_modules/core-js/internals/try-to-string.js
var require_try_to_string = __commonJS({
  "../../node_modules/core-js/internals/try-to-string.js"(exports, module) {
    "use strict";
    var $String = String;
    module.exports = function(argument) {
      try {
        return $String(argument);
      } catch (error) {
        return "Object";
      }
    };
  }
});

// ../../node_modules/core-js/internals/a-callable.js
var require_a_callable = __commonJS({
  "../../node_modules/core-js/internals/a-callable.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    var tryToString = require_try_to_string();
    var $TypeError = TypeError;
    module.exports = function(argument) {
      if (isCallable(argument)) return argument;
      throw new $TypeError(tryToString(argument) + " is not a function");
    };
  }
});

// ../../node_modules/core-js/internals/get-method.js
var require_get_method = __commonJS({
  "../../node_modules/core-js/internals/get-method.js"(exports, module) {
    "use strict";
    var aCallable = require_a_callable();
    var isNullOrUndefined = require_is_null_or_undefined();
    module.exports = function(V, P) {
      var func = V[P];
      return isNullOrUndefined(func) ? void 0 : aCallable(func);
    };
  }
});

// ../../node_modules/core-js/internals/ordinary-to-primitive.js
var require_ordinary_to_primitive = __commonJS({
  "../../node_modules/core-js/internals/ordinary-to-primitive.js"(exports, module) {
    "use strict";
    var call = require_function_call();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var $TypeError = TypeError;
    module.exports = function(input, pref) {
      var fn, val;
      if (pref === "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
      if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
      if (pref !== "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
      throw new $TypeError("Can't convert object to primitive value");
    };
  }
});

// ../../node_modules/core-js/internals/is-pure.js
var require_is_pure = __commonJS({
  "../../node_modules/core-js/internals/is-pure.js"(exports, module) {
    "use strict";
    module.exports = false;
  }
});

// ../../node_modules/core-js/internals/define-global-property.js
var require_define_global_property = __commonJS({
  "../../node_modules/core-js/internals/define-global-property.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var defineProperty = Object.defineProperty;
    module.exports = function(key, value) {
      try {
        defineProperty(globalThis2, key, { value, configurable: true, writable: true });
      } catch (error) {
        globalThis2[key] = value;
      }
      return value;
    };
  }
});

// ../../node_modules/core-js/internals/shared-store.js
var require_shared_store = __commonJS({
  "../../node_modules/core-js/internals/shared-store.js"(exports, module) {
    "use strict";
    var IS_PURE = require_is_pure();
    var globalThis2 = require_global_this();
    var defineGlobalProperty = require_define_global_property();
    var SHARED = "__core-js_shared__";
    var store = module.exports = globalThis2[SHARED] || defineGlobalProperty(SHARED, {});
    (store.versions || (store.versions = [])).push({
      version: "3.41.0",
      mode: IS_PURE ? "pure" : "global",
      copyright: "Â© 2014-2025 Denis Pushkarev (zloirock.ru)",
      license: "https://github.com/zloirock/core-js/blob/v3.41.0/LICENSE",
      source: "https://github.com/zloirock/core-js"
    });
  }
});

// ../../node_modules/core-js/internals/shared.js
var require_shared = __commonJS({
  "../../node_modules/core-js/internals/shared.js"(exports, module) {
    "use strict";
    var store = require_shared_store();
    module.exports = function(key, value) {
      return store[key] || (store[key] = value || {});
    };
  }
});

// ../../node_modules/core-js/internals/to-object.js
var require_to_object = __commonJS({
  "../../node_modules/core-js/internals/to-object.js"(exports, module) {
    "use strict";
    var requireObjectCoercible = require_require_object_coercible();
    var $Object = Object;
    module.exports = function(argument) {
      return $Object(requireObjectCoercible(argument));
    };
  }
});

// ../../node_modules/core-js/internals/has-own-property.js
var require_has_own_property = __commonJS({
  "../../node_modules/core-js/internals/has-own-property.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toObject = require_to_object();
    var hasOwnProperty = uncurryThis({}.hasOwnProperty);
    module.exports = Object.hasOwn || function hasOwn(it, key) {
      return hasOwnProperty(toObject(it), key);
    };
  }
});

// ../../node_modules/core-js/internals/uid.js
var require_uid = __commonJS({
  "../../node_modules/core-js/internals/uid.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var id = 0;
    var postfix = Math.random();
    var toString = uncurryThis(1 .toString);
    module.exports = function(key) {
      return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString(++id + postfix, 36);
    };
  }
});

// ../../node_modules/core-js/internals/well-known-symbol.js
var require_well_known_symbol = __commonJS({
  "../../node_modules/core-js/internals/well-known-symbol.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var shared = require_shared();
    var hasOwn = require_has_own_property();
    var uid = require_uid();
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var Symbol2 = globalThis2.Symbol;
    var WellKnownSymbolsStore = shared("wks");
    var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2["for"] || Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
    module.exports = function(name) {
      if (!hasOwn(WellKnownSymbolsStore, name)) {
        WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol2, name) ? Symbol2[name] : createWellKnownSymbol("Symbol." + name);
      }
      return WellKnownSymbolsStore[name];
    };
  }
});

// ../../node_modules/core-js/internals/to-primitive.js
var require_to_primitive = __commonJS({
  "../../node_modules/core-js/internals/to-primitive.js"(exports, module) {
    "use strict";
    var call = require_function_call();
    var isObject = require_is_object();
    var isSymbol = require_is_symbol();
    var getMethod = require_get_method();
    var ordinaryToPrimitive = require_ordinary_to_primitive();
    var wellKnownSymbol = require_well_known_symbol();
    var $TypeError = TypeError;
    var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
    module.exports = function(input, pref) {
      if (!isObject(input) || isSymbol(input)) return input;
      var exoticToPrim = getMethod(input, TO_PRIMITIVE);
      var result;
      if (exoticToPrim) {
        if (pref === void 0) pref = "default";
        result = call(exoticToPrim, input, pref);
        if (!isObject(result) || isSymbol(result)) return result;
        throw new $TypeError("Can't convert object to primitive value");
      }
      if (pref === void 0) pref = "number";
      return ordinaryToPrimitive(input, pref);
    };
  }
});

// ../../node_modules/core-js/internals/to-property-key.js
var require_to_property_key = __commonJS({
  "../../node_modules/core-js/internals/to-property-key.js"(exports, module) {
    "use strict";
    var toPrimitive = require_to_primitive();
    var isSymbol = require_is_symbol();
    module.exports = function(argument) {
      var key = toPrimitive(argument, "string");
      return isSymbol(key) ? key : key + "";
    };
  }
});

// ../../node_modules/core-js/internals/document-create-element.js
var require_document_create_element = __commonJS({
  "../../node_modules/core-js/internals/document-create-element.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var isObject = require_is_object();
    var document2 = globalThis2.document;
    var EXISTS = isObject(document2) && isObject(document2.createElement);
    module.exports = function(it) {
      return EXISTS ? document2.createElement(it) : {};
    };
  }
});

// ../../node_modules/core-js/internals/ie8-dom-define.js
var require_ie8_dom_define = __commonJS({
  "../../node_modules/core-js/internals/ie8-dom-define.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    var createElement = require_document_create_element();
    module.exports = !DESCRIPTORS && !fails(function() {
      return Object.defineProperty(createElement("div"), "a", {
        get: function() {
          return 7;
        }
      }).a !== 7;
    });
  }
});

// ../../node_modules/core-js/internals/object-get-own-property-descriptor.js
var require_object_get_own_property_descriptor = __commonJS({
  "../../node_modules/core-js/internals/object-get-own-property-descriptor.js"(exports) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var call = require_function_call();
    var propertyIsEnumerableModule = require_object_property_is_enumerable();
    var createPropertyDescriptor = require_create_property_descriptor();
    var toIndexedObject = require_to_indexed_object();
    var toPropertyKey = require_to_property_key();
    var hasOwn = require_has_own_property();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
      O = toIndexedObject(O);
      P = toPropertyKey(P);
      if (IE8_DOM_DEFINE) try {
        return $getOwnPropertyDescriptor(O, P);
      } catch (error) {
      }
      if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
    };
  }
});

// ../../node_modules/core-js/internals/v8-prototype-define-bug.js
var require_v8_prototype_define_bug = __commonJS({
  "../../node_modules/core-js/internals/v8-prototype-define-bug.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    module.exports = DESCRIPTORS && fails(function() {
      return Object.defineProperty(function() {
      }, "prototype", {
        value: 42,
        writable: false
      }).prototype !== 42;
    });
  }
});

// ../../node_modules/core-js/internals/an-object.js
var require_an_object = __commonJS({
  "../../node_modules/core-js/internals/an-object.js"(exports, module) {
    "use strict";
    var isObject = require_is_object();
    var $String = String;
    var $TypeError = TypeError;
    module.exports = function(argument) {
      if (isObject(argument)) return argument;
      throw new $TypeError($String(argument) + " is not an object");
    };
  }
});

// ../../node_modules/core-js/internals/object-define-property.js
var require_object_define_property = __commonJS({
  "../../node_modules/core-js/internals/object-define-property.js"(exports) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
    var anObject = require_an_object();
    var toPropertyKey = require_to_property_key();
    var $TypeError = TypeError;
    var $defineProperty = Object.defineProperty;
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var ENUMERABLE = "enumerable";
    var CONFIGURABLE = "configurable";
    var WRITABLE = "writable";
    exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
      anObject(O);
      P = toPropertyKey(P);
      anObject(Attributes);
      if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
        var current = $getOwnPropertyDescriptor(O, P);
        if (current && current[WRITABLE]) {
          O[P] = Attributes.value;
          Attributes = {
            configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
            enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
            writable: false
          };
        }
      }
      return $defineProperty(O, P, Attributes);
    } : $defineProperty : function defineProperty(O, P, Attributes) {
      anObject(O);
      P = toPropertyKey(P);
      anObject(Attributes);
      if (IE8_DOM_DEFINE) try {
        return $defineProperty(O, P, Attributes);
      } catch (error) {
      }
      if ("get" in Attributes || "set" in Attributes) throw new $TypeError("Accessors not supported");
      if ("value" in Attributes) O[P] = Attributes.value;
      return O;
    };
  }
});

// ../../node_modules/core-js/internals/create-non-enumerable-property.js
var require_create_non_enumerable_property = __commonJS({
  "../../node_modules/core-js/internals/create-non-enumerable-property.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var definePropertyModule = require_object_define_property();
    var createPropertyDescriptor = require_create_property_descriptor();
    module.exports = DESCRIPTORS ? function(object, key, value) {
      return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
    } : function(object, key, value) {
      object[key] = value;
      return object;
    };
  }
});

// ../../node_modules/core-js/internals/function-name.js
var require_function_name = __commonJS({
  "../../node_modules/core-js/internals/function-name.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var hasOwn = require_has_own_property();
    var FunctionPrototype = Function.prototype;
    var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
    var EXISTS = hasOwn(FunctionPrototype, "name");
    var PROPER = EXISTS && (function something() {
    }).name === "something";
    var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
    module.exports = {
      EXISTS,
      PROPER,
      CONFIGURABLE
    };
  }
});

// ../../node_modules/core-js/internals/inspect-source.js
var require_inspect_source = __commonJS({
  "../../node_modules/core-js/internals/inspect-source.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var isCallable = require_is_callable();
    var store = require_shared_store();
    var functionToString = uncurryThis(Function.toString);
    if (!isCallable(store.inspectSource)) {
      store.inspectSource = function(it) {
        return functionToString(it);
      };
    }
    module.exports = store.inspectSource;
  }
});

// ../../node_modules/core-js/internals/weak-map-basic-detection.js
var require_weak_map_basic_detection = __commonJS({
  "../../node_modules/core-js/internals/weak-map-basic-detection.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var isCallable = require_is_callable();
    var WeakMap = globalThis2.WeakMap;
    module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));
  }
});

// ../../node_modules/core-js/internals/shared-key.js
var require_shared_key = __commonJS({
  "../../node_modules/core-js/internals/shared-key.js"(exports, module) {
    "use strict";
    var shared = require_shared();
    var uid = require_uid();
    var keys = shared("keys");
    module.exports = function(key) {
      return keys[key] || (keys[key] = uid(key));
    };
  }
});

// ../../node_modules/core-js/internals/hidden-keys.js
var require_hidden_keys = __commonJS({
  "../../node_modules/core-js/internals/hidden-keys.js"(exports, module) {
    "use strict";
    module.exports = {};
  }
});

// ../../node_modules/core-js/internals/internal-state.js
var require_internal_state = __commonJS({
  "../../node_modules/core-js/internals/internal-state.js"(exports, module) {
    "use strict";
    var NATIVE_WEAK_MAP = require_weak_map_basic_detection();
    var globalThis2 = require_global_this();
    var isObject = require_is_object();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var hasOwn = require_has_own_property();
    var shared = require_shared_store();
    var sharedKey = require_shared_key();
    var hiddenKeys = require_hidden_keys();
    var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
    var TypeError2 = globalThis2.TypeError;
    var WeakMap = globalThis2.WeakMap;
    var set;
    var get2;
    var has;
    var enforce = function(it) {
      return has(it) ? get2(it) : set(it, {});
    };
    var getterFor = function(TYPE) {
      return function(it) {
        var state;
        if (!isObject(it) || (state = get2(it)).type !== TYPE) {
          throw new TypeError2("Incompatible receiver, " + TYPE + " required");
        }
        return state;
      };
    };
    if (NATIVE_WEAK_MAP || shared.state) {
      store = shared.state || (shared.state = new WeakMap());
      store.get = store.get;
      store.has = store.has;
      store.set = store.set;
      set = function(it, metadata) {
        if (store.has(it)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        store.set(it, metadata);
        return metadata;
      };
      get2 = function(it) {
        return store.get(it) || {};
      };
      has = function(it) {
        return store.has(it);
      };
    } else {
      STATE = sharedKey("state");
      hiddenKeys[STATE] = true;
      set = function(it, metadata) {
        if (hasOwn(it, STATE)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        createNonEnumerableProperty(it, STATE, metadata);
        return metadata;
      };
      get2 = function(it) {
        return hasOwn(it, STATE) ? it[STATE] : {};
      };
      has = function(it) {
        return hasOwn(it, STATE);
      };
    }
    var store;
    var STATE;
    module.exports = {
      set,
      get: get2,
      has,
      enforce,
      getterFor
    };
  }
});

// ../../node_modules/core-js/internals/make-built-in.js
var require_make_built_in = __commonJS({
  "../../node_modules/core-js/internals/make-built-in.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var isCallable = require_is_callable();
    var hasOwn = require_has_own_property();
    var DESCRIPTORS = require_descriptors();
    var CONFIGURABLE_FUNCTION_NAME = require_function_name().CONFIGURABLE;
    var inspectSource = require_inspect_source();
    var InternalStateModule = require_internal_state();
    var enforceInternalState = InternalStateModule.enforce;
    var getInternalState = InternalStateModule.get;
    var $String = String;
    var defineProperty = Object.defineProperty;
    var stringSlice = uncurryThis("".slice);
    var replace = uncurryThis("".replace);
    var join = uncurryThis([].join);
    var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function() {
      return defineProperty(function() {
      }, "length", { value: 8 }).length !== 8;
    });
    var TEMPLATE = String(String).split("String");
    var makeBuiltIn = module.exports = function(value, name, options) {
      if (stringSlice($String(name), 0, 7) === "Symbol(") {
        name = "[" + replace($String(name), /^Symbol\(([^)]*)\).*$/, "$1") + "]";
      }
      if (options && options.getter) name = "get " + name;
      if (options && options.setter) name = "set " + name;
      if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
        if (DESCRIPTORS) defineProperty(value, "name", { value: name, configurable: true });
        else value.name = name;
      }
      if (CONFIGURABLE_LENGTH && options && hasOwn(options, "arity") && value.length !== options.arity) {
        defineProperty(value, "length", { value: options.arity });
      }
      try {
        if (options && hasOwn(options, "constructor") && options.constructor) {
          if (DESCRIPTORS) defineProperty(value, "prototype", { writable: false });
        } else if (value.prototype) value.prototype = void 0;
      } catch (error) {
      }
      var state = enforceInternalState(value);
      if (!hasOwn(state, "source")) {
        state.source = join(TEMPLATE, typeof name == "string" ? name : "");
      }
      return value;
    };
    Function.prototype.toString = makeBuiltIn(function toString() {
      return isCallable(this) && getInternalState(this).source || inspectSource(this);
    }, "toString");
  }
});

// ../../node_modules/core-js/internals/define-built-in.js
var require_define_built_in = __commonJS({
  "../../node_modules/core-js/internals/define-built-in.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    var definePropertyModule = require_object_define_property();
    var makeBuiltIn = require_make_built_in();
    var defineGlobalProperty = require_define_global_property();
    module.exports = function(O, key, value, options) {
      if (!options) options = {};
      var simple = options.enumerable;
      var name = options.name !== void 0 ? options.name : key;
      if (isCallable(value)) makeBuiltIn(value, name, options);
      if (options.global) {
        if (simple) O[key] = value;
        else defineGlobalProperty(key, value);
      } else {
        try {
          if (!options.unsafe) delete O[key];
          else if (O[key]) simple = true;
        } catch (error) {
        }
        if (simple) O[key] = value;
        else definePropertyModule.f(O, key, {
          value,
          enumerable: false,
          configurable: !options.nonConfigurable,
          writable: !options.nonWritable
        });
      }
      return O;
    };
  }
});

// ../../node_modules/core-js/internals/math-trunc.js
var require_math_trunc = __commonJS({
  "../../node_modules/core-js/internals/math-trunc.js"(exports, module) {
    "use strict";
    var ceil = Math.ceil;
    var floor = Math.floor;
    module.exports = Math.trunc || function trunc(x) {
      var n = +x;
      return (n > 0 ? floor : ceil)(n);
    };
  }
});

// ../../node_modules/core-js/internals/to-integer-or-infinity.js
var require_to_integer_or_infinity = __commonJS({
  "../../node_modules/core-js/internals/to-integer-or-infinity.js"(exports, module) {
    "use strict";
    var trunc = require_math_trunc();
    module.exports = function(argument) {
      var number = +argument;
      return number !== number || number === 0 ? 0 : trunc(number);
    };
  }
});

// ../../node_modules/core-js/internals/to-absolute-index.js
var require_to_absolute_index = __commonJS({
  "../../node_modules/core-js/internals/to-absolute-index.js"(exports, module) {
    "use strict";
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var max = Math.max;
    var min = Math.min;
    module.exports = function(index, length) {
      var integer = toIntegerOrInfinity(index);
      return integer < 0 ? max(integer + length, 0) : min(integer, length);
    };
  }
});

// ../../node_modules/core-js/internals/to-length.js
var require_to_length = __commonJS({
  "../../node_modules/core-js/internals/to-length.js"(exports, module) {
    "use strict";
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var min = Math.min;
    module.exports = function(argument) {
      var len = toIntegerOrInfinity(argument);
      return len > 0 ? min(len, 9007199254740991) : 0;
    };
  }
});

// ../../node_modules/core-js/internals/length-of-array-like.js
var require_length_of_array_like = __commonJS({
  "../../node_modules/core-js/internals/length-of-array-like.js"(exports, module) {
    "use strict";
    var toLength = require_to_length();
    module.exports = function(obj) {
      return toLength(obj.length);
    };
  }
});

// ../../node_modules/core-js/internals/array-includes.js
var require_array_includes = __commonJS({
  "../../node_modules/core-js/internals/array-includes.js"(exports, module) {
    "use strict";
    var toIndexedObject = require_to_indexed_object();
    var toAbsoluteIndex = require_to_absolute_index();
    var lengthOfArrayLike = require_length_of_array_like();
    var createMethod = function(IS_INCLUDES) {
      return function($this, el, fromIndex) {
        var O = toIndexedObject($this);
        var length = lengthOfArrayLike(O);
        if (length === 0) return !IS_INCLUDES && -1;
        var index = toAbsoluteIndex(fromIndex, length);
        var value;
        if (IS_INCLUDES && el !== el) while (length > index) {
          value = O[index++];
          if (value !== value) return true;
        }
        else for (; length > index; index++) {
          if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
        }
        return !IS_INCLUDES && -1;
      };
    };
    module.exports = {
      // `Array.prototype.includes` method
      // https://tc39.es/ecma262/#sec-array.prototype.includes
      includes: createMethod(true),
      // `Array.prototype.indexOf` method
      // https://tc39.es/ecma262/#sec-array.prototype.indexof
      indexOf: createMethod(false)
    };
  }
});

// ../../node_modules/core-js/internals/object-keys-internal.js
var require_object_keys_internal = __commonJS({
  "../../node_modules/core-js/internals/object-keys-internal.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var hasOwn = require_has_own_property();
    var toIndexedObject = require_to_indexed_object();
    var indexOf = require_array_includes().indexOf;
    var hiddenKeys = require_hidden_keys();
    var push = uncurryThis([].push);
    module.exports = function(object, names) {
      var O = toIndexedObject(object);
      var i = 0;
      var result = [];
      var key;
      for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
      while (names.length > i) if (hasOwn(O, key = names[i++])) {
        ~indexOf(result, key) || push(result, key);
      }
      return result;
    };
  }
});

// ../../node_modules/core-js/internals/enum-bug-keys.js
var require_enum_bug_keys = __commonJS({
  "../../node_modules/core-js/internals/enum-bug-keys.js"(exports, module) {
    "use strict";
    module.exports = [
      "constructor",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "toLocaleString",
      "toString",
      "valueOf"
    ];
  }
});

// ../../node_modules/core-js/internals/object-get-own-property-names.js
var require_object_get_own_property_names = __commonJS({
  "../../node_modules/core-js/internals/object-get-own-property-names.js"(exports) {
    "use strict";
    var internalObjectKeys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    var hiddenKeys = enumBugKeys.concat("length", "prototype");
    exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
      return internalObjectKeys(O, hiddenKeys);
    };
  }
});

// ../../node_modules/core-js/internals/object-get-own-property-symbols.js
var require_object_get_own_property_symbols = __commonJS({
  "../../node_modules/core-js/internals/object-get-own-property-symbols.js"(exports) {
    "use strict";
    exports.f = Object.getOwnPropertySymbols;
  }
});

// ../../node_modules/core-js/internals/own-keys.js
var require_own_keys = __commonJS({
  "../../node_modules/core-js/internals/own-keys.js"(exports, module) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var uncurryThis = require_function_uncurry_this();
    var getOwnPropertyNamesModule = require_object_get_own_property_names();
    var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
    var anObject = require_an_object();
    var concat = uncurryThis([].concat);
    module.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it) {
      var keys = getOwnPropertyNamesModule.f(anObject(it));
      var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
      return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
    };
  }
});

// ../../node_modules/core-js/internals/copy-constructor-properties.js
var require_copy_constructor_properties = __commonJS({
  "../../node_modules/core-js/internals/copy-constructor-properties.js"(exports, module) {
    "use strict";
    var hasOwn = require_has_own_property();
    var ownKeys = require_own_keys();
    var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
    var definePropertyModule = require_object_define_property();
    module.exports = function(target, source, exceptions) {
      var keys = ownKeys(source);
      var defineProperty = definePropertyModule.f;
      var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
          defineProperty(target, key, getOwnPropertyDescriptor(source, key));
        }
      }
    };
  }
});

// ../../node_modules/core-js/internals/is-forced.js
var require_is_forced = __commonJS({
  "../../node_modules/core-js/internals/is-forced.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var isCallable = require_is_callable();
    var replacement = /#|\.prototype\./;
    var isForced = function(feature, detection) {
      var value = data[normalize(feature)];
      return value === POLYFILL ? true : value === NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
    };
    var normalize = isForced.normalize = function(string) {
      return String(string).replace(replacement, ".").toLowerCase();
    };
    var data = isForced.data = {};
    var NATIVE = isForced.NATIVE = "N";
    var POLYFILL = isForced.POLYFILL = "P";
    module.exports = isForced;
  }
});

// ../../node_modules/core-js/internals/export.js
var require_export = __commonJS({
  "../../node_modules/core-js/internals/export.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var defineBuiltIn = require_define_built_in();
    var defineGlobalProperty = require_define_global_property();
    var copyConstructorProperties = require_copy_constructor_properties();
    var isForced = require_is_forced();
    module.exports = function(options, source) {
      var TARGET = options.target;
      var GLOBAL = options.global;
      var STATIC = options.stat;
      var FORCED, target, key, targetProperty, sourceProperty, descriptor;
      if (GLOBAL) {
        target = globalThis2;
      } else if (STATIC) {
        target = globalThis2[TARGET] || defineGlobalProperty(TARGET, {});
      } else {
        target = globalThis2[TARGET] && globalThis2[TARGET].prototype;
      }
      if (target) for (key in source) {
        sourceProperty = source[key];
        if (options.dontCallGetSet) {
          descriptor = getOwnPropertyDescriptor(target, key);
          targetProperty = descriptor && descriptor.value;
        } else targetProperty = target[key];
        FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
        if (!FORCED && targetProperty !== void 0) {
          if (typeof sourceProperty == typeof targetProperty) continue;
          copyConstructorProperties(sourceProperty, targetProperty);
        }
        if (options.sham || targetProperty && targetProperty.sham) {
          createNonEnumerableProperty(sourceProperty, "sham", true);
        }
        defineBuiltIn(target, key, sourceProperty, options);
      }
    };
  }
});

// ../../node_modules/core-js/internals/native-raw-json.js
var require_native_raw_json = __commonJS({
  "../../node_modules/core-js/internals/native-raw-json.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    module.exports = !fails(function() {
      var unsafeInt = "9007199254740993";
      var raw = JSON.rawJSON(unsafeInt);
      return !JSON.isRawJSON(raw) || JSON.stringify(raw) !== unsafeInt;
    });
  }
});

// ../../node_modules/core-js/internals/is-raw-json.js
var require_is_raw_json = __commonJS({
  "../../node_modules/core-js/internals/is-raw-json.js"(exports, module) {
    "use strict";
    var isObject = require_is_object();
    var getInternalState = require_internal_state().get;
    module.exports = function isRawJSON(O) {
      if (!isObject(O)) return false;
      var state = getInternalState(O);
      return !!state && state.type === "RawJSON";
    };
  }
});

// ../../node_modules/core-js/modules/esnext.json.is-raw-json.js
var require_esnext_json_is_raw_json = __commonJS({
  "../../node_modules/core-js/modules/esnext.json.is-raw-json.js"() {
    "use strict";
    var $ = require_export();
    var NATIVE_RAW_JSON = require_native_raw_json();
    var isRawJSON = require_is_raw_json();
    $({ target: "JSON", stat: true, forced: !NATIVE_RAW_JSON }, {
      isRawJSON
    });
  }
});

// ../../node_modules/core-js/internals/is-array.js
var require_is_array = __commonJS({
  "../../node_modules/core-js/internals/is-array.js"(exports, module) {
    "use strict";
    var classof = require_classof_raw();
    module.exports = Array.isArray || function isArray(argument) {
      return classof(argument) === "Array";
    };
  }
});

// ../../node_modules/core-js/internals/to-string-tag-support.js
var require_to_string_tag_support = __commonJS({
  "../../node_modules/core-js/internals/to-string-tag-support.js"(exports, module) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var test = {};
    test[TO_STRING_TAG] = "z";
    module.exports = String(test) === "[object z]";
  }
});

// ../../node_modules/core-js/internals/classof.js
var require_classof = __commonJS({
  "../../node_modules/core-js/internals/classof.js"(exports, module) {
    "use strict";
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var isCallable = require_is_callable();
    var classofRaw = require_classof_raw();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var $Object = Object;
    var CORRECT_ARGUMENTS = classofRaw(/* @__PURE__ */ function() {
      return arguments;
    }()) === "Arguments";
    var tryGet = function(it, key) {
      try {
        return it[key];
      } catch (error) {
      }
    };
    module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
      var O, tag, result;
      return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) === "Object" && isCallable(O.callee) ? "Arguments" : result;
    };
  }
});

// ../../node_modules/core-js/internals/to-string.js
var require_to_string = __commonJS({
  "../../node_modules/core-js/internals/to-string.js"(exports, module) {
    "use strict";
    var classof = require_classof();
    var $String = String;
    module.exports = function(argument) {
      if (classof(argument) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
      return $String(argument);
    };
  }
});

// ../../node_modules/core-js/internals/create-property.js
var require_create_property = __commonJS({
  "../../node_modules/core-js/internals/create-property.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var definePropertyModule = require_object_define_property();
    var createPropertyDescriptor = require_create_property_descriptor();
    module.exports = function(object, key, value) {
      if (DESCRIPTORS) definePropertyModule.f(object, key, createPropertyDescriptor(0, value));
      else object[key] = value;
    };
  }
});

// ../../node_modules/core-js/internals/parse-json-string.js
var require_parse_json_string = __commonJS({
  "../../node_modules/core-js/internals/parse-json-string.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var hasOwn = require_has_own_property();
    var $SyntaxError = SyntaxError;
    var $parseInt = parseInt;
    var fromCharCode = String.fromCharCode;
    var at = uncurryThis("".charAt);
    var slice = uncurryThis("".slice);
    var exec = uncurryThis(/./.exec);
    var codePoints = {
      '\\"': '"',
      "\\\\": "\\",
      "\\/": "/",
      "\\b": "\b",
      "\\f": "\f",
      "\\n": "\n",
      "\\r": "\r",
      "\\t": "	"
    };
    var IS_4_HEX_DIGITS = /^[\da-f]{4}$/i;
    var IS_C0_CONTROL_CODE = /^[\u0000-\u001F]$/;
    module.exports = function(source, i) {
      var unterminated = true;
      var value = "";
      while (i < source.length) {
        var chr = at(source, i);
        if (chr === "\\") {
          var twoChars = slice(source, i, i + 2);
          if (hasOwn(codePoints, twoChars)) {
            value += codePoints[twoChars];
            i += 2;
          } else if (twoChars === "\\u") {
            i += 2;
            var fourHexDigits = slice(source, i, i + 4);
            if (!exec(IS_4_HEX_DIGITS, fourHexDigits)) throw new $SyntaxError("Bad Unicode escape at: " + i);
            value += fromCharCode($parseInt(fourHexDigits, 16));
            i += 4;
          } else throw new $SyntaxError('Unknown escape sequence: "' + twoChars + '"');
        } else if (chr === '"') {
          unterminated = false;
          i++;
          break;
        } else {
          if (exec(IS_C0_CONTROL_CODE, chr)) throw new $SyntaxError("Bad control character in string literal at: " + i);
          value += chr;
          i++;
        }
      }
      if (unterminated) throw new $SyntaxError("Unterminated string at: " + i);
      return { value, end: i };
    };
  }
});

// ../../node_modules/core-js/modules/esnext.json.parse.js
var require_esnext_json_parse = __commonJS({
  "../../node_modules/core-js/modules/esnext.json.parse.js"() {
    "use strict";
    var $ = require_export();
    var DESCRIPTORS = require_descriptors();
    var globalThis2 = require_global_this();
    var getBuiltIn = require_get_built_in();
    var uncurryThis = require_function_uncurry_this();
    var call = require_function_call();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var isArray = require_is_array();
    var hasOwn = require_has_own_property();
    var toString = require_to_string();
    var lengthOfArrayLike = require_length_of_array_like();
    var createProperty = require_create_property();
    var fails = require_fails();
    var parseJSONString = require_parse_json_string();
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    var JSON2 = globalThis2.JSON;
    var Number2 = globalThis2.Number;
    var SyntaxError2 = globalThis2.SyntaxError;
    var nativeParse = JSON2 && JSON2.parse;
    var enumerableOwnProperties = getBuiltIn("Object", "keys");
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var at = uncurryThis("".charAt);
    var slice = uncurryThis("".slice);
    var exec = uncurryThis(/./.exec);
    var push = uncurryThis([].push);
    var IS_DIGIT = /^\d$/;
    var IS_NON_ZERO_DIGIT = /^[1-9]$/;
    var IS_NUMBER_START = /^[\d-]$/;
    var IS_WHITESPACE = /^[\t\n\r ]$/;
    var PRIMITIVE = 0;
    var OBJECT = 1;
    var $parse = function(source, reviver) {
      source = toString(source);
      var context = new Context(source, 0, "");
      var root = context.parse();
      var value = root.value;
      var endIndex = context.skip(IS_WHITESPACE, root.end);
      if (endIndex < source.length) {
        throw new SyntaxError2('Unexpected extra character: "' + at(source, endIndex) + '" after the parsed data at: ' + endIndex);
      }
      return isCallable(reviver) ? internalize({ "": value }, "", reviver, root) : value;
    };
    var internalize = function(holder, name, reviver, node) {
      var val = holder[name];
      var unmodified = node && val === node.value;
      var context = unmodified && typeof node.source == "string" ? { source: node.source } : {};
      var elementRecordsLen, keys, len, i, P;
      if (isObject(val)) {
        var nodeIsArray = isArray(val);
        var nodes = unmodified ? node.nodes : nodeIsArray ? [] : {};
        if (nodeIsArray) {
          elementRecordsLen = nodes.length;
          len = lengthOfArrayLike(val);
          for (i = 0; i < len; i++) {
            internalizeProperty(val, i, internalize(val, "" + i, reviver, i < elementRecordsLen ? nodes[i] : void 0));
          }
        } else {
          keys = enumerableOwnProperties(val);
          len = lengthOfArrayLike(keys);
          for (i = 0; i < len; i++) {
            P = keys[i];
            internalizeProperty(val, P, internalize(val, P, reviver, hasOwn(nodes, P) ? nodes[P] : void 0));
          }
        }
      }
      return call(reviver, holder, name, val, context);
    };
    var internalizeProperty = function(object, key, value) {
      if (DESCRIPTORS) {
        var descriptor = getOwnPropertyDescriptor(object, key);
        if (descriptor && !descriptor.configurable) return;
      }
      if (value === void 0) delete object[key];
      else createProperty(object, key, value);
    };
    var Node = function(value, end, source, nodes) {
      this.value = value;
      this.end = end;
      this.source = source;
      this.nodes = nodes;
    };
    var Context = function(source, index) {
      this.source = source;
      this.index = index;
    };
    Context.prototype = {
      fork: function(nextIndex) {
        return new Context(this.source, nextIndex);
      },
      parse: function() {
        var source = this.source;
        var i = this.skip(IS_WHITESPACE, this.index);
        var fork = this.fork(i);
        var chr = at(source, i);
        if (exec(IS_NUMBER_START, chr)) return fork.number();
        switch (chr) {
          case "{":
            return fork.object();
          case "[":
            return fork.array();
          case '"':
            return fork.string();
          case "t":
            return fork.keyword(true);
          case "f":
            return fork.keyword(false);
          case "n":
            return fork.keyword(null);
        }
        throw new SyntaxError2('Unexpected character: "' + chr + '" at: ' + i);
      },
      node: function(type, value, start, end, nodes) {
        return new Node(value, end, type ? null : slice(this.source, start, end), nodes);
      },
      object: function() {
        var source = this.source;
        var i = this.index + 1;
        var expectKeypair = false;
        var object = {};
        var nodes = {};
        while (i < source.length) {
          i = this.until(['"', "}"], i);
          if (at(source, i) === "}" && !expectKeypair) {
            i++;
            break;
          }
          var result = this.fork(i).string();
          var key = result.value;
          i = result.end;
          i = this.until([":"], i) + 1;
          i = this.skip(IS_WHITESPACE, i);
          result = this.fork(i).parse();
          createProperty(nodes, key, result);
          createProperty(object, key, result.value);
          i = this.until([",", "}"], result.end);
          var chr = at(source, i);
          if (chr === ",") {
            expectKeypair = true;
            i++;
          } else if (chr === "}") {
            i++;
            break;
          }
        }
        return this.node(OBJECT, object, this.index, i, nodes);
      },
      array: function() {
        var source = this.source;
        var i = this.index + 1;
        var expectElement = false;
        var array = [];
        var nodes = [];
        while (i < source.length) {
          i = this.skip(IS_WHITESPACE, i);
          if (at(source, i) === "]" && !expectElement) {
            i++;
            break;
          }
          var result = this.fork(i).parse();
          push(nodes, result);
          push(array, result.value);
          i = this.until([",", "]"], result.end);
          if (at(source, i) === ",") {
            expectElement = true;
            i++;
          } else if (at(source, i) === "]") {
            i++;
            break;
          }
        }
        return this.node(OBJECT, array, this.index, i, nodes);
      },
      string: function() {
        var index = this.index;
        var parsed = parseJSONString(this.source, this.index + 1);
        return this.node(PRIMITIVE, parsed.value, index, parsed.end);
      },
      number: function() {
        var source = this.source;
        var startIndex = this.index;
        var i = startIndex;
        if (at(source, i) === "-") i++;
        if (at(source, i) === "0") i++;
        else if (exec(IS_NON_ZERO_DIGIT, at(source, i))) i = this.skip(IS_DIGIT, i + 1);
        else throw new SyntaxError2("Failed to parse number at: " + i);
        if (at(source, i) === ".") i = this.skip(IS_DIGIT, i + 1);
        if (at(source, i) === "e" || at(source, i) === "E") {
          i++;
          if (at(source, i) === "+" || at(source, i) === "-") i++;
          var exponentStartIndex = i;
          i = this.skip(IS_DIGIT, i);
          if (exponentStartIndex === i) throw new SyntaxError2("Failed to parse number's exponent value at: " + i);
        }
        return this.node(PRIMITIVE, Number2(slice(source, startIndex, i)), startIndex, i);
      },
      keyword: function(value) {
        var keyword = "" + value;
        var index = this.index;
        var endIndex = index + keyword.length;
        if (slice(this.source, index, endIndex) !== keyword) throw new SyntaxError2("Failed to parse value at: " + index);
        return this.node(PRIMITIVE, value, index, endIndex);
      },
      skip: function(regex, i) {
        var source = this.source;
        for (; i < source.length; i++) if (!exec(regex, at(source, i))) break;
        return i;
      },
      until: function(array, i) {
        i = this.skip(IS_WHITESPACE, i);
        var chr = at(this.source, i);
        for (var j = 0; j < array.length; j++) if (array[j] === chr) return i;
        throw new SyntaxError2('Unexpected character: "' + chr + '" at: ' + i);
      }
    };
    var NO_SOURCE_SUPPORT = fails(function() {
      var unsafeInt = "9007199254740993";
      var source;
      nativeParse(unsafeInt, function(key, value, context) {
        source = context.source;
      });
      return source !== unsafeInt;
    });
    var PROPER_BASE_PARSE = NATIVE_SYMBOL && !fails(function() {
      return 1 / nativeParse("-0 	") !== -Infinity;
    });
    $({ target: "JSON", stat: true, forced: NO_SOURCE_SUPPORT }, {
      parse: function parse(text, reviver) {
        return PROPER_BASE_PARSE && !isCallable(reviver) ? nativeParse(text) : $parse(text, reviver);
      }
    });
  }
});

// ../../node_modules/core-js/internals/freezing.js
var require_freezing = __commonJS({
  "../../node_modules/core-js/internals/freezing.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    module.exports = !fails(function() {
      return Object.isExtensible(Object.preventExtensions({}));
    });
  }
});

// ../../node_modules/core-js/internals/get-json-replacer-function.js
var require_get_json_replacer_function = __commonJS({
  "../../node_modules/core-js/internals/get-json-replacer-function.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var isArray = require_is_array();
    var isCallable = require_is_callable();
    var classof = require_classof_raw();
    var toString = require_to_string();
    var push = uncurryThis([].push);
    module.exports = function(replacer) {
      if (isCallable(replacer)) return replacer;
      if (!isArray(replacer)) return;
      var rawLength = replacer.length;
      var keys = [];
      for (var i = 0; i < rawLength; i++) {
        var element = replacer[i];
        if (typeof element == "string") push(keys, element);
        else if (typeof element == "number" || classof(element) === "Number" || classof(element) === "String") push(keys, toString(element));
      }
      var keysLength = keys.length;
      var root = true;
      return function(key, value) {
        if (root) {
          root = false;
          return value;
        }
        if (isArray(this)) return value;
        for (var j = 0; j < keysLength; j++) if (keys[j] === key) return value;
      };
    };
  }
});

// ../../node_modules/core-js/modules/esnext.json.raw-json.js
var require_esnext_json_raw_json = __commonJS({
  "../../node_modules/core-js/modules/esnext.json.raw-json.js"() {
    "use strict";
    var $ = require_export();
    var FREEZING = require_freezing();
    var NATIVE_RAW_JSON = require_native_raw_json();
    var getBuiltIn = require_get_built_in();
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var isCallable = require_is_callable();
    var isRawJSON = require_is_raw_json();
    var toString = require_to_string();
    var createProperty = require_create_property();
    var parseJSONString = require_parse_json_string();
    var getReplacerFunction = require_get_json_replacer_function();
    var uid = require_uid();
    var setInternalState = require_internal_state().set;
    var $String = String;
    var $SyntaxError = SyntaxError;
    var parse = getBuiltIn("JSON", "parse");
    var $stringify = getBuiltIn("JSON", "stringify");
    var create = getBuiltIn("Object", "create");
    var freeze = getBuiltIn("Object", "freeze");
    var at = uncurryThis("".charAt);
    var slice = uncurryThis("".slice);
    var push = uncurryThis([].push);
    var MARK = uid();
    var MARK_LENGTH = MARK.length;
    var ERROR_MESSAGE = "Unacceptable as raw JSON";
    var isWhitespace = function(it) {
      return it === " " || it === "	" || it === "\n" || it === "\r";
    };
    $({ target: "JSON", stat: true, forced: !NATIVE_RAW_JSON }, {
      rawJSON: function rawJSON(text) {
        var jsonString = toString(text);
        if (jsonString === "" || isWhitespace(at(jsonString, 0)) || isWhitespace(at(jsonString, jsonString.length - 1))) {
          throw new $SyntaxError(ERROR_MESSAGE);
        }
        var parsed = parse(jsonString);
        if (typeof parsed == "object" && parsed !== null) throw new $SyntaxError(ERROR_MESSAGE);
        var obj = create(null);
        setInternalState(obj, { type: "RawJSON" });
        createProperty(obj, "rawJSON", jsonString);
        return FREEZING ? freeze(obj) : obj;
      }
    });
    if ($stringify) $({ target: "JSON", stat: true, arity: 3, forced: !NATIVE_RAW_JSON }, {
      stringify: function stringify(text, replacer, space) {
        var replacerFunction = getReplacerFunction(replacer);
        var rawStrings = [];
        var json = $stringify(text, function(key, value) {
          var v = isCallable(replacerFunction) ? call(replacerFunction, this, $String(key), value) : value;
          return isRawJSON(v) ? MARK + (push(rawStrings, v.rawJSON) - 1) : v;
        }, space);
        if (typeof json != "string") return json;
        var result = "";
        var length = json.length;
        for (var i = 0; i < length; i++) {
          var chr = at(json, i);
          if (chr === '"') {
            var end = parseJSONString(json, ++i).end - 1;
            var string = slice(json, i, end);
            result += slice(string, 0, MARK_LENGTH) === MARK ? rawStrings[slice(string, MARK_LENGTH)] : '"' + string + '"';
            i = end;
          } else result += chr;
        }
        return result;
      }
    });
  }
});

// ../../node_modules/core-js/proposals/json-parse-with-source.js
require_esnext_json_is_raw_json();
require_esnext_json_parse();
require_esnext_json_raw_json();

// ../node_modules/@provablehq/sdk/dist/testnet/browser.js
import { ViewKey, ComputeKey, Address as Address2, PrivateKeyCiphertext, PrivateKey as PrivateKey2, RecordCiphertext as RecordCiphertext2, ProvingKey as ProvingKey2, VerifyingKey as VerifyingKey2 } from "@provablehq/wasm/testnet.js";
import { Address as Address3, BHP1024, BHP256, BHP512, BHP768, Ciphertext, ComputeKey as ComputeKey2, ExecutionResponse, Field, Execution, Group, OfflineQuery, Pedersen128, Pedersen64, Plaintext as Plaintext2, Poseidon2, Poseidon4, Poseidon8, PrivateKey as PrivateKey3, PrivateKeyCiphertext as PrivateKeyCiphertext2, Program as Program2, ProgramManager as ProgramManager2, ProvingKey as ProvingKey3, RecordCiphertext as RecordCiphertext3, RecordPlaintext as RecordPlaintext2, Scalar, Signature, Transaction as Transaction2, Transition, VerifyingKey as VerifyingKey3, ViewKey as ViewKey2, initThreadPool, verifyFunctionExecution as verifyFunctionExecution2 } from "@provablehq/wasm/testnet.js";

// ../node_modules/@provablehq/sdk/dist/testnet/program-manager-BuK9g9xJ.js
import { PrivateKey, RecordCiphertext, Program, Plaintext, Address, Transaction, Metadata, VerifyingKey, ProvingKey, ProgramManager as ProgramManager$1, RecordPlaintext, verifyFunctionExecution } from "@provablehq/wasm/testnet.js";
function logAndThrow(message) {
  console.error(message);
  throw new Error(message);
}
function parseJSON(json) {
  function revive(key, value, context) {
    if (Number.isInteger(value)) {
      return BigInt(context.source);
    } else {
      return value;
    }
  }
  return JSON.parse(json, revive);
}
async function get(url, options) {
  const response = await fetch(url, options);
  if (!response.ok) {
    throw new Error(response.status + " could not get URL " + url);
  }
  return response;
}
async function post(url, options) {
  options.method = "POST";
  const response = await fetch(url, options);
  if (!response.ok) {
    throw new Error(response.status + " could not post URL " + url);
  }
  return response;
}
var AleoNetworkClient = class {
  constructor(host, options) {
    __publicField(this, "host");
    __publicField(this, "headers");
    __publicField(this, "account");
    this.host = host + "/testnet";
    if (options && options.headers) {
      this.headers = options.headers;
    } else {
      this.headers = {
        // This is replaced by the actual version by a Rollup plugin
        "X-Aleo-SDK-Version": "0.8.8"
      };
    }
  }
  /**
   * Set an account to use in networkClient calls
   *
   * @param {Account} account Set an account to use for record scanning functions.
   * @example
   * import { Account, AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
   *
   * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1");
   * const account = new Account();
   * networkClient.setAccount(account);
   */
  setAccount(account) {
    this.account = account;
  }
  /**
   * Return the Aleo account used in the networkClient
   *
   * @example
   * const account = networkClient.getAccount();
   */
  getAccount() {
    return this.account;
  }
  /**
   * Set a new host for the networkClient
   *
   * @param {string} host The address of a node hosting the Aleo API
   * @param host
   *
   * @example
   * import { AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a networkClient that connects to a local node.
   * const networkClient = new AleoNetworkClient("http://0.0.0.0:3030", undefined);
   *
   * // Set the host to a public node.
   * networkClient.setHost("http://api.explorer.provable.com/v1");
   */
  setHost(host) {
    this.host = host + "/testnet";
  }
  /**
   * Fetches data from the Aleo network and returns it as a JSON object.
   *
   * @param url The URL to fetch data from.
   */
  async fetchData(url = "/") {
    try {
      return parseJSON(await this.fetchRaw(url));
    } catch (error) {
      throw new Error(`Error fetching data: ${error}`);
    }
  }
  /**
   * Fetches data from the Aleo network and returns it as an unparsed string.
   *
   * This method should be used when it is desired to reconstitute data returned
   * from the network into a WASM object.
   *
   * @param url
   */
  async fetchRaw(url = "/") {
    try {
      const response = await get(this.host + url, {
        headers: this.headers
      });
      return await response.text();
    } catch (error) {
      throw new Error(`Error fetching data: ${error}`);
    }
  }
  /**
   * Attempt to find records in the Aleo blockchain.
   *
   * @param {number} startHeight - The height at which to start searching for unspent records
   * @param {number} endHeight - The height at which to stop searching for unspent records
   * @param {boolean} unspent - Whether to search for unspent records only
   * @param {string[]} programs - The program(s) to search for unspent records in
   * @param {number[]} amounts - The amounts (in microcredits) to search for (eg. [100, 200, 3000])
   * @param {number} maxMicrocredits - The maximum number of microcredits to search for
   * @param {string[]} nonces - The nonces of already found records to exclude from the search
   * @param {string | PrivateKey} privateKey - An optional private key to use to find unspent records.
   * @returns {Promise<Array<RecordPlaintext>>} An array of records belonging to the account configured in the network client.
   *
   * @example
   * import { Account, AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
   *
   * // Import an account from a ciphertext and password.
   * const account = Account.fromCiphertext(process.env.ciphertext, process.env.password);
   *
   * // Create a network client.
   * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
   * networkClient.setAccount(account);
   *
   * // Find specific amounts
   * const startHeight = 500000;
   * const amounts = [600000, 1000000];
   * const records = networkClient.findRecords(startHeight, undefined, true, ["credits.aleo"] amounts);
   *
   * // Find specific amounts with a maximum number of cumulative microcredits
   * const maxMicrocredits = 100000;
   * const records = networkClient.findRecords(startHeight, undefined, true, ["credits.aleo"] undefined, maxMicrocredits);
   */
  async findRecords(startHeight, endHeight, unspent = false, programs, amounts, maxMicrocredits, nonces, privateKey) {
    nonces = nonces || [];
    if (startHeight < 0) {
      throw new Error("Start height must be greater than or equal to 0");
    }
    const records = new Array();
    let start;
    let end;
    let resolvedPrivateKey;
    let failures = 0;
    let totalRecordValue = BigInt(0);
    let latestHeight;
    if (typeof privateKey === "undefined") {
      if (typeof this.account === "undefined") {
        throw new Error("Private key must be specified in an argument to findOwnedRecords or set in the AleoNetworkClient");
      } else {
        resolvedPrivateKey = this.account._privateKey;
      }
    } else {
      try {
        resolvedPrivateKey = privateKey instanceof PrivateKey ? privateKey : PrivateKey.from_string(privateKey);
      } catch (error) {
        throw new Error("Error parsing private key provided.");
      }
    }
    const viewKey = resolvedPrivateKey.to_view_key();
    try {
      const blockHeight = await this.getLatestHeight();
      if (typeof blockHeight === "number") {
        latestHeight = blockHeight;
      } else {
        throw new Error(`Error fetching latest block height: Expected type 'number' got '${typeof blockHeight}'`);
      }
    } catch (error) {
      throw new Error(`Error fetching latest block height: ${error}`);
    }
    if (typeof endHeight === "number" && endHeight <= latestHeight) {
      end = endHeight;
    } else {
      end = latestHeight;
    }
    if (startHeight > end) {
      throw new Error("Start height must be less than or equal to end height.");
    }
    while (end > startHeight) {
      start = end - 50;
      if (start < startHeight) {
        start = startHeight;
      }
      try {
        const blocks = await this.getBlockRange(start, end);
        end = start;
        for (let i = 0; i < blocks.length; i++) {
          const block = blocks[i];
          const transactions = block.transactions;
          if (!(typeof transactions === "undefined")) {
            for (let j = 0; j < transactions.length; j++) {
              const confirmedTransaction = transactions[j];
              if (confirmedTransaction.type == "execute") {
                const transaction = confirmedTransaction.transaction;
                if (transaction.execution && !(typeof transaction.execution.transitions == "undefined")) {
                  for (let k = 0; k < transaction.execution.transitions.length; k++) {
                    const transition = transaction.execution.transitions[k];
                    if (!(typeof programs === "undefined")) {
                      if (!programs.includes(transition.program)) {
                        continue;
                      }
                    }
                    if (!(typeof transition.outputs == "undefined")) {
                      for (let l = 0; l < transition.outputs.length; l++) {
                        const output = transition.outputs[l];
                        if (output.type === "record") {
                          try {
                            const record = RecordCiphertext.fromString(output.value);
                            if (record.isOwner(viewKey)) {
                              const recordPlaintext = record.decrypt(viewKey);
                              const nonce = recordPlaintext.nonce();
                              if (nonces.includes(nonce)) {
                                continue;
                              }
                              if (unspent) {
                                const serialNumber = recordPlaintext.serialNumberString(resolvedPrivateKey, "credits.aleo", "credits");
                                try {
                                  await this.getTransitionId(serialNumber);
                                  continue;
                                } catch (error) {
                                  console.log("Found unspent record!");
                                }
                              }
                              if (!amounts) {
                                records.push(recordPlaintext);
                                if (typeof maxMicrocredits === "number") {
                                  totalRecordValue += recordPlaintext.microcredits();
                                  if (totalRecordValue >= BigInt(maxMicrocredits)) {
                                    return records;
                                  }
                                }
                              }
                              if (!(typeof amounts === "undefined") && amounts.length > 0) {
                                let amounts_found = 0;
                                if (recordPlaintext.microcredits() > amounts[amounts_found]) {
                                  amounts_found += 1;
                                  records.push(recordPlaintext);
                                  if (typeof maxMicrocredits === "number") {
                                    totalRecordValue += recordPlaintext.microcredits();
                                    if (totalRecordValue >= BigInt(maxMicrocredits)) {
                                      return records;
                                    }
                                  }
                                  if (records.length >= amounts.length) {
                                    return records;
                                  }
                                }
                              }
                            }
                          } catch (error) {
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      } catch (error) {
        console.warn("Error fetching blocks in range: " + start.toString() + "-" + end.toString());
        console.warn("Error: ", error);
        failures += 1;
        if (failures > 10) {
          console.warn("10 failures fetching records reached. Returning records fetched so far");
          return records;
        }
      }
    }
    return records;
  }
  /**
   * Attempts to find unspent records in the Aleo blockchain.
   *
   * @param {number} startHeight - The height at which to start searching for unspent records
   * @param {number} endHeight - The height at which to stop searching for unspent records
   * @param {string[]} programs - The program(s) to search for unspent records in
   * @param {number[]} amounts - The amounts (in microcredits) to search for (eg. [100, 200, 3000])
   * @param {number} maxMicrocredits - The maximum number of microcredits to search for
   * @param {string[]} nonces - The nonces of already found records to exclude from the search
   * @param {string | PrivateKey} privateKey - An optional private key to use to find unspent records.
   * @returns {Promise<Array<RecordPlaintext>>} An array of unspent records belonging to the account configured in the network client.
   *
   * @example
   * import { Account, AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
   *
   * const account = Account.fromCiphertext(process.env.ciphertext, process.env.password);
   *
   * // Create a network client and set an account to search for records with.
   * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
   * networkClient.setAccount(account);
   *
   * // Find specific amounts
   * const startHeight = 500000;
   * const endHeight = 550000;
   * const amounts = [600000, 1000000];
   * const records = networkClient.findUnspentRecords(startHeight, endHeight, ["credits.aleo"], amounts);
   *
   * // Find specific amounts with a maximum number of cumulative microcredits
   * const maxMicrocredits = 100000;
   * const records = networkClient.findUnspentRecords(startHeight, undefined, ["credits.aleo"], undefined, maxMicrocredits);
   */
  async findUnspentRecords(startHeight, endHeight, programs, amounts, maxMicrocredits, nonces, privateKey) {
    return await this.findRecords(startHeight, endHeight, true, programs, amounts, maxMicrocredits, nonces, privateKey);
  }
  /**
   * Returns the contents of the block at the specified block height.
   *
   * @param {number} blockHeight - The height of the block to fetch
   * @returns {Promise<BlockJSON>} A javascript object containing the block at the specified height
   *
   * @example
   * const block = networkClient.getBlock(1234);
   */
  async getBlock(blockHeight) {
    try {
      const block = await this.fetchData("/block/" + blockHeight);
      return block;
    } catch (error) {
      throw new Error(`Error fetching block ${blockHeight}: ${error}`);
    }
  }
  /**
   * Returns the contents of the block with the specified hash.
   *
   * @param {string} blockHash The hash of the block to fetch.
   * @returns {Promise<BlockJSON>} A javascript object representation of the block matching the hash.
   *
   * @example
   * import { AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
   *
   * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
   * const block = networkClient.getBlockByHash("ab19dklwl9vp63zu3hwg57wyhvmqf92fx5g8x0t6dr72py8r87pxupqfne5t9");
   */
  async getBlockByHash(blockHash) {
    try {
      const block = await this.fetchData(`/block/${blockHash}`);
      return block;
    } catch (error) {
      throw new Error(`Error fetching block ${blockHash}: ${error}`);
    }
  }
  /**
   * Returns a range of blocks between the specified block heights. A maximum of 50 blocks can be fetched at a time.
   *
   * @param {number} start Starting block to fetch.
   * @param {number} end Ending block to fetch. This cannot be more than 50 blocks ahead of the start block.
   * @returns {Promise<Array<BlockJSON>>} An array of block objects
   *
   * @example
   * import { AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
   *
   * // Fetch 50 blocks.
   * const (start, end) = (2050, 2100);
   * const blockRange = networkClient.getBlockRange(start, end);
   *
   * let cursor = start;
   * blockRange.forEach((block) => {
   *   assert(block.height == cursor);
   *   cursor += 1;
   *  }
   */
  async getBlockRange(start, end) {
    try {
      return await this.fetchData("/blocks?start=" + start + "&end=" + end);
    } catch (error) {
      throw new Error(`Error fetching blocks between ${start} and ${end}: ${error}`);
    }
  }
  /**
   * Returns the deployment transaction id associated with the specified program.
   *
   * @param {Program | string} program The name of the deployed program OR a wasm Program object.
   * @returns {Promise<string>} The transaction ID of the deployment transaction.
   *
   * @example
   * import { AleoNetworkClient } from "@provablehq/sdk/testnet.js";
   *
   * // Get the transaction ID of the deployment transaction for a program.
   * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
   * const transactionId = networkClient.getDeploymentTransactionIDForProgram("hello_hello.aleo");
   *
   * // Get the transaction data for the deployment transaction.
   * const transaction = networkClient.getTransactionObject(transactionId);
   *
   * // Get the verifying keys for the functions in the deployed program.
   * const verifyingKeys = transaction.verifyingKeys();
   */
  async getDeploymentTransactionIDForProgram(program) {
    if (program instanceof Program) {
      program = program.id();
    }
    try {
      const id = await this.fetchData("/find/transactionID/deployment/" + program);
      return id.replace('"', "");
    } catch (error) {
      throw new Error(`Error fetching deployment transaction for program ${program}: ${error}`);
    }
  }
  /**
   * Returns the deployment transaction associated with a specified program as a JSON object.
   *
   * @param {Program | string} program The name of the deployed program OR a wasm Program object.
   * @returns {Promise<Transaction>} JSON representation of the deployment transaction.
   *
   * @example
   * import { AleoNetworkClient, DeploymentJSON } from "@provablehq/sdk/testnet.js";
   *
   * // Get the transaction ID of the deployment transaction for a program.
   * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
   * const transaction = networkClient.getDeploymentTransactionForProgram("hello_hello.aleo");
   *
   * // Get the verifying keys for each function in the deployment.
   * const deployment = <DeploymentJSON>transaction.deployment;
   * const verifyingKeys = deployment.verifying_keys;
   */
  async getDeploymentTransactionForProgram(program) {
    if (program instanceof Program) {
      program = program.id();
    }
    try {
      const transaction_id = await this.getDeploymentTransactionIDForProgram(program);
      return await this.getTransaction(transaction_id);
    } catch (error) {
      throw new Error(`Error fetching deployment transaction for program ${program}: ${error}`);
    }
  }
  /**
   * Returns the deployment transaction associated with a specified program as a wasm object.
   *
   * @param {Program | string} program The name of the deployed program OR a wasm Program object.
   * @returns {Promise<Transaction>} Wasm object representation of the deployment transaction.
   *
   * @example
   * import { AleoNetworkClient } from "@provablehq/sdk/testnet.js";
   *
   * // Get the transaction ID of the deployment transaction for a program.
   * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
   * const transactionId = networkClient.getDeploymentTransactionIDForProgram("hello_hello.aleo");
   *
   * // Get the transaction data for the deployment transaction.
   * const transaction = networkClient.getDeploymentTransactionObjectForProgram(transactionId);
   *
   * // Get the verifying keys for the functions in the deployed program.
   * const verifyingKeys = transaction.verifyingKeys();
   */
  async getDeploymentTransactionObjectForProgram(program) {
    try {
      const transaction_id = await this.getDeploymentTransactionIDForProgram(program);
      return await this.getTransactionObject(transaction_id);
    } catch (error) {
      throw new Error(`Error fetching deployment transaction for program ${program}: ${error}`);
    }
  }
  /**
   * Returns the contents of the latest block as JSON.
   *
   * @returns {Promise<BlockJSON>} A javascript object containing the latest block
   *
   * @example
   * import { AleoNetworkClient } from "@provablehq/sdk/testnet.js";
   *
   * // Create a network client.
   * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
   *
   * const latestHeight = networkClient.getLatestBlock();
   */
  async getLatestBlock() {
    try {
      return await this.fetchData("/block/latest");
    } catch (error) {
      throw new Error(`Error fetching latest block: ${error}`);
    }
  }
  /**
   * Returns the latest committee.
   *
   * @returns {Promise<object>} A javascript object containing the latest committee
   *
   * @example
   * import { AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a network client.
   * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
   *
   * // Create a network client and get the latest committee.
   * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
   * const latestCommittee = await networkClient.getLatestCommittee();
   */
  async getLatestCommittee() {
    try {
      return await this.fetchData("/committee/latest");
    } catch (error) {
      throw new Error(`Error fetching latest committee: ${error}`);
    }
  }
  /**
   * Returns the committee at the specified block height.
   *
   * @param {number} blockHeight - The height of the block to fetch the committee for
   * @returns {Promise<object>} A javascript object containing the committee
   *
   * @example
   * import { AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a network client.
   * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
   *
   * // Create a network client and get the committee for a specific block.
   * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
   * const committee = await networkClient.getCommitteeByBlockHeight(1234);
   */
  async getCommitteeByBlockHeight(blockHeight) {
    try {
      return await this.fetchData(`/committee/${blockHeight}`);
    } catch (error) {
      throw new Error(`Error fetching committee at height ${blockHeight}: ${error}`);
    }
  }
  /**
   * Returns the latest block height.
   *
   * @returns {Promise<number>} The latest block height.
   *
   * @example
   * import { AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a network client.
   * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
   *
   * const latestHeight = networkClient.getLatestHeight();
   */
  async getLatestHeight() {
    try {
      return Number(await this.fetchData("/block/height/latest"));
    } catch (error) {
      throw new Error(`Error fetching latest height: ${error}`);
    }
  }
  /**
   * Returns the latest block hash.
   *
   * @returns {Promise<string>} The latest block hash.
   *
   * @example
   * import { AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a network client.
   * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
   *
   * // Get the latest block hash.
   * const latestHash = networkClient.getLatestBlockHash();
   */
  async getLatestBlockHash() {
    try {
      return String(await this.fetchData("/block/hash/latest"));
    } catch (error) {
      throw new Error(`Error fetching latest hash: ${error}`);
    }
  }
  /**
   * Returns the source code of a program given a program ID.
   *
   * @param {string} programId The program ID of a program deployed to the Aleo Network
   * @returns {Promise<string>} Source code of the program
   *
   * @example
   * import { AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a network client.
   * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
   *
   * const program = networkClient.getProgram("hello_hello.aleo");
   * const expectedSource = "program hello_hello.aleo;\n\nfunction hello:\n    input r0 as u32.public;\n    input r1 as u32.private;\n    add r0 r1 into r2;\n    output r2 as u32.private;\n"
   * assert.equal(program, expectedSource);
   */
  async getProgram(programId) {
    try {
      return await this.fetchData("/program/" + programId);
    } catch (error) {
      throw new Error(`Error fetching program ${programId}: ${error}`);
    }
  }
  /**
   * Returns a program object from a program ID or program source code.
   *
   * @param {string} inputProgram The program ID or program source code of a program deployed to the Aleo Network
   * @returns {Promise<Program>} Source code of the program
   *
   * @example
   * import { AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a network client.
   * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
   *
   * const programID = "hello_hello.aleo";
   * const programSource = "program hello_hello.aleo;\n\nfunction hello:\n    input r0 as u32.public;\n    input r1 as u32.private;\n    add r0 r1 into r2;\n    output r2 as u32.private;\n"
   *
   * // Get program object from program ID or program source code
   * const programObjectFromID = await networkClient.getProgramObject(programID);
   * const programObjectFromSource = await networkClient.getProgramObject(programSource);
   *
   * // Both program objects should be equal
   * assert(programObjectFromID.to_string() === programObjectFromSource.to_string());
   */
  async getProgramObject(inputProgram) {
    try {
      return Program.fromString(inputProgram);
    } catch (error) {
      try {
        return Program.fromString(await this.getProgram(inputProgram));
      } catch (error2) {
        throw new Error(`${inputProgram} is neither a program name or a valid program: ${error2}`);
      }
    }
  }
  /**
   *  Returns an object containing the source code of a program and the source code of all programs it imports
   *
   * @param {Program | string} inputProgram The program ID or program source code of a program deployed to the Aleo Network
   * @returns {Promise<ProgramImports>} Object of the form { "program_id": "program_source", .. } containing program id & source code for all program imports
   *
   * @example
   * import { AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
   *
   * const double_test_source = "import multiply_test.aleo;\n\nprogram double_test.aleo;\n\nfunction double_it:\n    input r0 as u32.private;\n    call multiply_test.aleo/multiply 2u32 r0 into r1;\n    output r1 as u32.private;\n"
   * const double_test = Program.fromString(double_test_source);
   * const expectedImports = {
   *     "multiply_test.aleo": "program multiply_test.aleo;\n\nfunction multiply:\n    input r0 as u32.public;\n    input r1 as u32.private;\n    mul r0 r1 into r2;\n    output r2 as u32.private;\n"
   * }
   *
   * // Create a network client.
   * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
   *
   * // Imports can be fetched using the program ID, source code, or program object
   * let programImports = await networkClient.getProgramImports("double_test.aleo");
   * assert.deepStrictEqual(programImports, expectedImports);
   *
   * // Using the program source code
   * programImports = await networkClient.getProgramImports(double_test_source);
   * assert.deepStrictEqual(programImports, expectedImports);
   *
   * // Using the program object
   * programImports = await networkClient.getProgramImports(double_test);
   * assert.deepStrictEqual(programImports, expectedImports);
   */
  async getProgramImports(inputProgram) {
    try {
      const imports = {};
      const program = inputProgram instanceof Program ? inputProgram : await this.getProgramObject(inputProgram);
      const importList = program.getImports();
      for (let i = 0; i < importList.length; i++) {
        const import_id = importList[i];
        if (!imports.hasOwnProperty(import_id)) {
          const programSource = await this.getProgram(import_id);
          const nestedImports = await this.getProgramImports(import_id);
          for (const key in nestedImports) {
            if (!imports.hasOwnProperty(key)) {
              imports[key] = nestedImports[key];
            }
          }
          imports[import_id] = programSource;
        }
      }
      return imports;
    } catch (error) {
      logAndThrow("Error fetching program imports: " + error.message);
    }
  }
  /**
   * Get a list of the program names that a program imports.
   *
   * @param {Program | string} inputProgram - The program id or program source code to get the imports of
   * @returns {string[]} - The list of program names that the program imports
   *
   * @example
   * import { AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a network client.
   * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
   *
   * const programImportsNames = networkClient.getProgramImports("wrapped_credits.aleo");
   * const expectedImportsNames = ["credits.aleo"];
   * assert.deepStrictEqual(programImportsNames, expectedImportsNames);
   */
  async getProgramImportNames(inputProgram) {
    try {
      const program = inputProgram instanceof Program ? inputProgram : await this.getProgramObject(inputProgram);
      return program.getImports();
    } catch (error) {
      throw new Error(`Error fetching imports for program ${inputProgram instanceof Program ? inputProgram.id() : inputProgram}: ${error.message}`);
    }
  }
  /**
   * Returns the names of the mappings of a program.
   *
   * @param {string} programId - The program ID to get the mappings of (e.g. "credits.aleo")
   * @returns {Promise<Array<string>>} - The names of the mappings of the program.
   *
   * @example
   * import { AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a network client.
   * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
   *
   * const mappings = networkClient.getProgramMappingNames("credits.aleo");
   * const expectedMappings = [
   *   "committee",
   *   "delegated",
   *   "metadata",
   *   "bonded",
   *   "unbonding",
   *   "account",
   *   "withdraw"
   * ];
   * assert.deepStrictEqual(mappings, expectedMappings);
   */
  async getProgramMappingNames(programId) {
    try {
      return await this.fetchData(`/program/${programId}/mappings`);
    } catch (error) {
      throw new Error(`Error fetching mappings for program ${programId} - ensure the program exists on chain before trying again`);
    }
  }
  /**
   * Returns the value of a program's mapping for a specific key.
   *
   * @param {string} programId - The program ID to get the mapping value of (e.g. "credits.aleo")
   * @param {string} mappingName - The name of the mapping to get the value of (e.g. "account")
   * @param {string | Plaintext} key - The key to look up in the mapping (e.g. an address for the "account" mapping)
   * @returns {Promise<string>} String representation of the value of the mapping
   *
   * @example
   * import { AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a network client.
   * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
   *
   * // Get public balance of an account
   * const mappingValue = networkClient.getMappingValue("credits.aleo", "account", "aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px");
   * const expectedValue = "0u64";
   * assert(mappingValue === expectedValue);
   */
  async getProgramMappingValue(programId, mappingName, key) {
    try {
      const keyString = key instanceof Plaintext ? key.toString() : key;
      return await this.fetchData(`/program/${programId}/mapping/${mappingName}/${keyString}`);
    } catch (error) {
      throw new Error(`Error fetching value for key '${key}' in mapping '${mappingName}' in program '${programId}' - ensure the mapping exists and the key is correct`);
    }
  }
  /**
   * Returns the value of a mapping as a wasm Plaintext object. Returning an object in this format allows it to be converted to a Js type and for its internal members to be inspected if it's a struct or array.
   *
   * @param {string} programId - The program ID to get the mapping value of (e.g. "credits.aleo")
   * @param {string} mappingName - The name of the mapping to get the value of (e.g. "bonded")
   * @param {string | Plaintext} key - The key to look up in the mapping (e.g. an address for the "bonded" mapping)
   * @returns {Promise<Plaintext>} String representation of the value of the mapping
   *
   * @example
   * import { AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a network client.
   * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
   *
   * // Get the bond state as an account.
   * const unbondedState = networkClient.getMappingPlaintext("credits.aleo", "bonded", "aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px");
   *
   * // Get the two members of the object individually.
   * const validator = unbondedState.getMember("validator");
   * const microcredits = unbondedState.getMember("microcredits");
   *
   * // Ensure the expected values are correct.
   * assert.equal(validator, "aleo1u6940v5m0fzud859xx2c9tj2gjg6m5qrd28n636e6fdd2akvfcgqs34mfd");
   * assert.equal(microcredits, BigInt("9007199254740991"));
   *
   * // Get a JS object representation of the unbonded state.
   * const unbondedStateObject = unbondedState.toObject();
   *
   * const expectedState = {
   *     validator: "aleo1u6940v5m0fzud859xx2c9tj2gjg6m5qrd28n636e6fdd2akvfcgqs34mfd",
   *     microcredits: BigInt(9007199254740991)
   * };
   * assert.equal(unbondedState, expectedState);
   */
  async getProgramMappingPlaintext(programId, mappingName, key) {
    try {
      const keyString = key instanceof Plaintext ? key.toString() : key;
      const value = await this.fetchRaw(`/program/${programId}/mapping/${mappingName}/${keyString}`);
      return Plaintext.fromString(JSON.parse(value));
    } catch (error) {
      throw new Error("Failed to fetch mapping value." + error);
    }
  }
  /**
   * Returns the public balance of an address from the account mapping in credits.aleo
   *
   * @param {Address | string} address A string or wasm object representing an address.
   * @returns {Promise<number>} The public balance of the address in microcredits.
   *
   * @example
   * import { AleoNetworkClient, Account } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a network client.
   * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
   *
   * // Get the balance of an account from either an address object or address string.
   * const account = Account.fromCiphertext(process.env.ciphertext, process.env.password);
   * const publicBalance = await networkClient.getPublicBalance(account.address());
   * const publicBalanceFromString = await networkClient.getPublicBalance(account.address().to_string());
   * assert(publicBalance === publicBalanceFromString);
   */
  async getPublicBalance(address) {
    try {
      const addressString = address instanceof Address ? address.to_string() : address;
      const balanceStr = await this.getProgramMappingValue("credits.aleo", "account", addressString);
      return balanceStr ? parseInt(balanceStr) : 0;
    } catch (error) {
      throw new Error(`Error fetching public balance for ${address}: ${error}`);
    }
  }
  /**
   * Returns the latest state/merkle root of the Aleo blockchain.
   *
   * @returns {Promise<string>} A string representing the latest state root of the Aleo blockchain.
   *
   * @example
   * import { AleoNetworkClient, Account } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a network client.
   * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
   *
   * // Get the latest state root.
   * const stateRoot = networkClient.getStateRoot();
   */
  async getStateRoot() {
    try {
      return await this.fetchData("/stateRoot/latest");
    } catch (error) {
      throw new Error(`Error fetching latest state root: ${error}`);
    }
  }
  /**
   * Returns a transaction by its unique identifier.
   *
   * @param {string} transactionId The transaction ID to fetch.
   * @returns {Promise<TransactionJSON>} A json representation of the transaction.
   *
   * @example
   * import { AleoNetworkClient, Account } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a network client.
   * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
   *
   * const transaction = networkClient.getTransaction("at1handz9xjrqeynjrr0xay4pcsgtnczdksz3e584vfsgaz0dh0lyxq43a4wj");
   */
  async getTransaction(transactionId) {
    try {
      return await this.fetchData("/transaction/" + transactionId);
    } catch (error) {
      throw new Error(`Error fetching transaction ${transactionId}: ${error}`);
    }
  }
  /**
   * Returns a confirmed transaction by its unique identifier.
   *
   * @param {string} transactionId The transaction ID to fetch.
   * @returns {Promise<ConfirmedTransactionJSON>} A json object containing the confirmed transaction.
   *
   * @example
   * import { AleoNetworkClient, Account } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a network client.
   * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
   *
   * const transaction = networkClient.getConfirmedTransaction("at1handz9xjrqeynjrr0xay4pcsgtnczdksz3e584vfsgaz0dh0lyxq43a4wj");
   * assert.equal(transaction.status, "confirmed");
   */
  async getConfirmedTransaction(transactionId) {
    try {
      return await this.fetchData(`/transaction/confirmed/${transactionId}`);
    } catch (error) {
      throw new Error(`Error fetching confirmed transaction ${transactionId}: ${error}`);
    }
  }
  /**
   * Returns a transaction as a wasm object. Getting a transaction of this type will allow the ability for the inputs,
   * outputs, and records to be searched for and displayed.
   *
   * @param {string} transactionId - The unique identifier of the transaction to fetch
   * @returns {Promise<Transaction>} A wasm object representation of the transaction.
   *
   * @example
   * const transactionObject = networkClient.getTransaction("at1handz9xjrqeynjrr0xay4pcsgtnczdksz3e584vfsgaz0dh0lyxq43a4wj");
   * // Get the transaction inputs as a JS array.
   * const transactionInputs = transactionObject.inputs(true);
   *
   * // Get the transaction outputs as a JS object.
   * const transactionOutputs = transactionObject.outputs(true);
   *
   * // Get any records generated in transitions in the transaction as a JS object.
   * const records = transactionObject.records();
   *
   * // Get the transaction type.
   * const transactionType = transactionObject.transactionType();
   * assert.equal(transactionType, "Execute");
   *
   * // Get a JS representation of all inputs, outputs, and transaction metadata.
   * const transactionSummary = transactionObject.summary();
   */
  async getTransactionObject(transactionId) {
    try {
      const transaction = await this.fetchRaw("/transaction/" + transactionId);
      return Transaction.fromString(transaction);
    } catch (error) {
      throw new Error(`Error fetching transaction object ${transactionId}: ${error}`);
    }
  }
  /**
   * Returns the transactions present at the specified block height.
   *
   * @param {number} blockHeight The block height to fetch the confirmed transactions at.
   * @returns {Promise<Array<ConfirmedTransactionJSON>>} An array of confirmed transactions (in JSON format) for the block height.
   *
   * @example
   * import { AleoNetworkClient, Account } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a network client.
   * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
   *
   * const transactions = networkClient.getTransactions(654);
   */
  async getTransactions(blockHeight) {
    try {
      return await this.fetchData("/block/" + blockHeight.toString() + "/transactions");
    } catch (error) {
      throw new Error(`Error fetching transactions: ${error}`);
    }
  }
  /**
   * Returns the confirmed transactions present in the block with the specified block hash.
   *
   * @param {string} blockHash The block hash to fetch the confirmed transactions at.
   * @returns {Promise<Array<ConfirmedTransactionJSON>>} An array of confirmed transactions (in JSON format) for the block hash.
   *
   * @example
   * import { AleoNetworkClient, Account } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a network client.
   * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
   *
   * const transactions = networkClient.getTransactionsByBlockHash("ab19dklwl9vp63zu3hwg57wyhvmqf92fx5g8x0t6dr72py8r87pxupqfne5t9");
   */
  async getTransactionsByBlockHash(blockHash) {
    try {
      const block = await this.fetchData(`/block/${blockHash}`);
      const height = block.header.metadata.height;
      return await this.getTransactions(Number(height));
    } catch (error) {
      throw new Error(`Error fetching transactions for block ${blockHash}: ${error}`);
    }
  }
  /**
   * Returns the transactions in the memory pool. This method requires access to a validator's REST API.
   *
   * @returns {Promise<Array<TransactionJSON>>} An array of transactions (in JSON format) currently in the mempool.
   *
   * @example
   * import { AleoNetworkClient, Account } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a network client.
   * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
   *
   * // Get the current transactions in the mempool.
   * const transactions = networkClient.getTransactionsInMempool();
   */
  async getTransactionsInMempool() {
    try {
      return await this.fetchData("/memoryPool/transactions");
    } catch (error) {
      throw new Error(`Error fetching transactions from mempool: ${error}`);
    }
  }
  /**
   * Returns the transition ID of the transition corresponding to the ID of the input or output.
   * @param {string} inputOrOutputID - The unique identifier of the input or output to find the transition ID for
   * @returns {Promise<string>} - The transition ID of the input or output ID.
   *
   * @example
   * const transitionId = networkClient.getTransitionId("2429232855236830926144356377868449890830704336664550203176918782554219952323field");
   */
  async getTransitionId(inputOrOutputID) {
    try {
      return await this.fetchData("/find/transitionID/" + inputOrOutputID);
    } catch (error) {
      throw new Error(`Error fetching transition ID for input/output ${inputOrOutputID}: ${error}`);
    }
  }
  /**
   * Submit an execute or deployment transaction to the Aleo network.
   *
   * @param {Transaction | string} transaction - The transaction to submit, either as a Transaction object or string representation
   * @returns {Promise<string>} - The transaction id of the submitted transaction or the resulting error
   */
  async submitTransaction(transaction) {
    const transaction_string = transaction instanceof Transaction ? transaction.toString() : transaction;
    try {
      const response = await post(this.host + "/transaction/broadcast", {
        body: transaction_string,
        headers: Object.assign({}, this.headers, {
          "Content-Type": "application/json"
        })
      });
      try {
        const text = await response.text();
        return parseJSON(text);
      } catch (error) {
        throw new Error(`Error posting transaction. Aleo network response: ${error.message}`);
      }
    } catch (error) {
      throw new Error(`Error posting transaction: No response received: ${error.message}`);
    }
  }
  /**
   * Submit a solution to the Aleo network.
   *
   * @param {string} solution - The string representation of the solution to submit
   * @returns {Promise<string>} The solution id of the submitted solution or the resulting error.
   */
  async submitSolution(solution) {
    try {
      const response = await post(this.host + "/solution/broadcast", {
        body: solution,
        headers: Object.assign({}, this.headers, {
          "Content-Type": "application/json"
        })
      });
      try {
        const text = await response.text();
        return parseJSON(text);
      } catch (error) {
        throw new Error(`Error posting transaction. Aleo network response: ${error.message}`);
      }
    } catch (error) {
      throw new Error(`Error posting transaction: No response received: ${error.message}`);
    }
  }
  /**
   * Await a submitted transaction to be confirmed or rejected on the Aleo network.
   *
   * @param {string} transactionId - The transaction ID to wait for confirmation
   * @param {number} checkInterval - The interval in milliseconds to check for confirmation (default: 2000)
   * @param {number} timeout - The maximum time in milliseconds to wait for confirmation (default: 45000)
   * @returns {Promise<Transaction>} The confirmed transaction object that returns if the transaction is confirmed.
   *
   * @example
   * import { AleoNetworkClient, Account, ProgramManager } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a network client and program manager.
   * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
   * const programManager = new ProgramManager(networkClient);
   *
   * // Set the account for the program manager.
   * programManager.setAccount(Account.fromCiphertext(process.env.ciphertext, process.env.password));
   *
   * // Build a transfer transaction.
   * const tx = await programManager.buildTransferPublicTransaction(100, "aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px", 0);
   *
   * // Submit the transaction to the network.
   * const transactionId = await networkClient.submitTransaction(tx);
   *
   * // Wait for the transaction to be confirmed.
   * const transaction = await networkClient.waitForTransactionConfirmation(transactionId);
   */
  async waitForTransactionConfirmation(transactionId, checkInterval = 2e3, timeout = 45e3) {
    const startTime = Date.now();
    return new Promise((resolve, reject) => {
      const interval = setInterval(async () => {
        try {
          const transaction = await this.getTransactionObject(transactionId);
          resolve(transaction);
          if (Date.now() - startTime > timeout) {
            clearInterval(interval);
            reject(new Error("Transaction confirmation timed out"));
          }
        } catch (error) {
          console.error("Error checking transaction:", error);
        }
      }, checkInterval);
    });
  }
};
var KEY_STORE = Metadata.baseUrl();
function convert(metadata) {
  const verifyingKey = VerifyingKey[metadata.verifyingKey];
  if (!verifyingKey) {
    throw new Error("Invalid method name: " + metadata.verifyingKey);
  }
  return {
    name: metadata.name,
    locator: metadata.locator,
    prover: metadata.prover,
    verifier: metadata.verifier,
    verifyingKey
  };
}
var CREDITS_PROGRAM_KEYS = {
  bond_public: convert(Metadata.bond_public()),
  bond_validator: convert(Metadata.bond_validator()),
  claim_unbond_public: convert(Metadata.claim_unbond_public()),
  fee_private: convert(Metadata.fee_private()),
  fee_public: convert(Metadata.fee_public()),
  inclusion: convert(Metadata.inclusion()),
  join: convert(Metadata.join()),
  set_validator_state: convert(Metadata.set_validator_state()),
  split: convert(Metadata.split()),
  transfer_private: convert(Metadata.transfer_private()),
  transfer_private_to_public: convert(Metadata.transfer_private_to_public()),
  transfer_public: convert(Metadata.transfer_public()),
  transfer_public_as_signer: convert(Metadata.transfer_public_as_signer()),
  transfer_public_to_private: convert(Metadata.transfer_public_to_private()),
  unbond_public: convert(Metadata.unbond_public()),
  getKey: function(key) {
    if (this.hasOwnProperty(key)) {
      return this[key];
    } else {
      throw new Error(`Key "${key}" not found.`);
    }
  }
};
var PRIVATE_TRANSFER_TYPES = /* @__PURE__ */ new Set([
  "transfer_private",
  "private",
  "transferPrivate",
  "transfer_private_to_public",
  "privateToPublic",
  "transferPrivateToPublic"
]);
var VALID_TRANSFER_TYPES = /* @__PURE__ */ new Set([
  "transfer_private",
  "private",
  "transferPrivate",
  "transfer_private_to_public",
  "privateToPublic",
  "transferPrivateToPublic",
  "transfer_public",
  "transfer_public_as_signer",
  "public",
  "public_as_signer",
  "transferPublic",
  "transferPublicAsSigner",
  "transfer_public_to_private",
  "publicToPrivate",
  "publicAsSigner",
  "transferPublicToPrivate"
]);
var PRIVATE_TRANSFER = /* @__PURE__ */ new Set([
  "private",
  "transfer_private",
  "transferPrivate"
]);
var PRIVATE_TO_PUBLIC_TRANSFER = /* @__PURE__ */ new Set([
  "private_to_public",
  "privateToPublic",
  "transfer_private_to_public",
  "transferPrivateToPublic"
]);
var PUBLIC_TRANSFER = /* @__PURE__ */ new Set([
  "public",
  "transfer_public",
  "transferPublic"
]);
var PUBLIC_TRANSFER_AS_SIGNER = /* @__PURE__ */ new Set([
  "public_as_signer",
  "transfer_public_as_signer",
  "transferPublicAsSigner"
]);
var PUBLIC_TO_PRIVATE_TRANSFER = /* @__PURE__ */ new Set([
  "public_to_private",
  "publicToPrivate",
  "transfer_public_to_private",
  "transferPublicToPrivate"
]);
var AleoKeyProviderParams = class {
  /**
   * Create a new AleoKeyProviderParams object which implements the KeySearchParams interface. Users can optionally
   * specify a url for the proverUri & verifierUri to fetch keys via HTTP from a remote resource as well as a unique
   * cacheKey to store the keys in memory for future use. If no proverUri or verifierUri is specified, a cachekey must
   * be provided.
   *
   * @param { AleoKeyProviderInitParams } params - Optional search parameters
   */
  constructor(params) {
    __publicField(this, "name");
    __publicField(this, "proverUri");
    __publicField(this, "verifierUri");
    __publicField(this, "cacheKey");
    this.proverUri = params.proverUri;
    this.verifierUri = params.verifierUri;
    this.cacheKey = params.cacheKey;
    this.name = params.name;
  }
};
var AleoKeyProvider = class {
  constructor() {
    __publicField(this, "cache");
    __publicField(this, "cacheOption");
    __publicField(this, "keyUris");
    this.keyUris = KEY_STORE;
    this.cache = /* @__PURE__ */ new Map();
    this.cacheOption = false;
  }
  async fetchBytes(url = "/") {
    try {
      const response = await get(url);
      const data = await response.arrayBuffer();
      return new Uint8Array(data);
    } catch (error) {
      throw new Error("Error fetching data." + error.message);
    }
  }
  /**
   * Use local memory to store keys
   *
   * @param {boolean} useCache whether to store keys in local memory
   */
  useCache(useCache) {
    this.cacheOption = useCache;
  }
  /**
   * Clear the key cache
   */
  clearCache() {
    this.cache.clear();
  }
  /**
   * Cache a set of keys. This will overwrite any existing keys with the same keyId. The user can check if a keyId
   * exists in the cache using the containsKeys method prior to calling this method if overwriting is not desired.
   *
   * @param {string} keyId access key for the cache
   * @param {FunctionKeyPair} keys keys to cache
   */
  cacheKeys(keyId, keys) {
    const [provingKey, verifyingKey] = keys;
    this.cache.set(keyId, [provingKey.toBytes(), verifyingKey.toBytes()]);
  }
  /**
   * Determine if a keyId exists in the cache
   *
   * @param {string} keyId keyId of a proving and verifying key pair
   * @returns {boolean} true if the keyId exists in the cache, false otherwise
   */
  containsKeys(keyId) {
    return this.cache.has(keyId);
  }
  /**
   * Delete a set of keys from the cache
   *
   * @param {string} keyId keyId of a proving and verifying key pair to delete from memory
   * @returns {boolean} true if the keyId exists in the cache and was deleted, false if the key did not exist
   */
  deleteKeys(keyId) {
    return this.cache.delete(keyId);
  }
  /**
   * Get a set of keys from the cache
   * @param keyId keyId of a proving and verifying key pair
   *
   * @returns {FunctionKeyPair} Proving and verifying keys for the specified program
   */
  getKeys(keyId) {
    console.debug(`Checking if key exists in cache. KeyId: ${keyId}`);
    if (this.cache.has(keyId)) {
      const [provingKeyBytes, verifyingKeyBytes] = this.cache.get(keyId);
      return [ProvingKey.fromBytes(provingKeyBytes), VerifyingKey.fromBytes(verifyingKeyBytes)];
    } else {
      throw new Error("Key not found in cache.");
    }
  }
  /**
   * Get arbitrary function keys from a provider
   *
   * @param {KeySearchParams} params parameters for the key search in form of: {proverUri: string, verifierUri: string, cacheKey: string}
   * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the specified program
   *
   * @example
   * // Create a new object which implements the KeyProvider interface
   * const networkClient = new AleoNetworkClient("https://api.explorer.provable.com/v1");
   * const keyProvider = new AleoKeyProvider();
   * const recordProvider = new NetworkRecordProvider(account, networkClient);
   *
   * // Initialize a program manager with the key provider to automatically fetch keys for value transfers
   * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
   * programManager.transfer(1, "aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at", "public", 0.5);
   *
   * // Keys can also be fetched manually using the key provider
   * const keySearchParams = { "cacheKey": "myProgram:myFunction" };
   * const [transferPrivateProvingKey, transferPrivateVerifyingKey] = await keyProvider.functionKeys(keySearchParams);
   */
  async functionKeys(params) {
    if (params) {
      let proverUrl;
      let verifierUrl;
      let cacheKey;
      if ("name" in params && typeof params["name"] == "string") {
        let key = CREDITS_PROGRAM_KEYS.getKey(params["name"]);
        return this.fetchCreditsKeys(key);
      }
      if ("proverUri" in params && typeof params["proverUri"] == "string") {
        proverUrl = params["proverUri"];
      }
      if ("verifierUri" in params && typeof params["verifierUri"] == "string") {
        verifierUrl = params["verifierUri"];
      }
      if ("cacheKey" in params && typeof params["cacheKey"] == "string") {
        cacheKey = params["cacheKey"];
      }
      if (proverUrl && verifierUrl) {
        return await this.fetchRemoteKeys(proverUrl, verifierUrl, cacheKey);
      }
      if (cacheKey) {
        return this.getKeys(cacheKey);
      }
    }
    throw new Error("Invalid parameters provided, must provide either a cacheKey and/or a proverUrl and a verifierUrl");
  }
  /**
   * Returns the proving and verifying keys for a specified program from a specified url.
   *
   * @param {string} verifierUrl Url of the proving key
   * @param {string} proverUrl Url the verifying key
   * @param {string} cacheKey Key to store the keys in the cache
   *
   * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the specified program
   *
   * @example
   * // Create a new AleoKeyProvider object
   * const networkClient = new AleoNetworkClient("https://api.explorer.provable.com/v1");
   * const keyProvider = new AleoKeyProvider();
   * const recordProvider = new NetworkRecordProvider(account, networkClient);
   *
   * // Initialize a program manager with the key provider to automatically fetch keys for value transfers
   * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
   * programManager.transfer(1, "aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at", "public", 0.5);
   *
   * // Keys can also be fetched manually
   * const [transferPrivateProvingKey, transferPrivateVerifyingKey] = await keyProvider.fetchKeys(
   *     CREDITS_PROGRAM_KEYS.transfer_private.prover,
   *     CREDITS_PROGRAM_KEYS.transfer_private.verifier,
   * );
   */
  async fetchRemoteKeys(proverUrl, verifierUrl, cacheKey) {
    try {
      if (this.cacheOption) {
        if (!cacheKey) {
          cacheKey = proverUrl;
        }
        const value = this.cache.get(cacheKey);
        if (typeof value !== "undefined") {
          return [ProvingKey.fromBytes(value[0]), VerifyingKey.fromBytes(value[1])];
        } else {
          console.debug("Fetching proving keys from url " + proverUrl);
          const provingKey = ProvingKey.fromBytes(await this.fetchBytes(proverUrl));
          console.debug("Fetching verifying keys " + verifierUrl);
          const verifyingKey = await this.getVerifyingKey(verifierUrl);
          this.cache.set(cacheKey, [provingKey.toBytes(), verifyingKey.toBytes()]);
          return [provingKey, verifyingKey];
        }
      } else {
        const provingKey = ProvingKey.fromBytes(await this.fetchBytes(proverUrl));
        const verifyingKey = await this.getVerifyingKey(verifierUrl);
        return [provingKey, verifyingKey];
      }
    } catch (error) {
      throw new Error(`Error: ${error.message} fetching fee proving and verifying keys from ${proverUrl} and ${verifierUrl}.`);
    }
  }
  /***
   * Fetches the proving key from a remote source.
   *
   * @param proverUrl
   * @param cacheKey
   *
   * @returns {Promise<ProvingKey>} Proving key for the specified program
   */
  async fetchProvingKey(proverUrl, cacheKey) {
    try {
      if (this.cacheOption) {
        if (!cacheKey) {
          cacheKey = proverUrl;
        }
        const value = this.cache.get(cacheKey);
        if (typeof value !== "undefined") {
          return ProvingKey.fromBytes(value[0]);
        } else {
          console.debug("Fetching proving keys from url " + proverUrl);
          const provingKey = ProvingKey.fromBytes(await this.fetchBytes(proverUrl));
          return provingKey;
        }
      } else {
        const provingKey = ProvingKey.fromBytes(await this.fetchBytes(proverUrl));
        return provingKey;
      }
    } catch (error) {
      throw new Error(`Error: ${error.message} fetching fee proving keys from ${proverUrl}`);
    }
  }
  async fetchCreditsKeys(key) {
    try {
      if (!this.cache.has(key.locator) || !this.cacheOption) {
        const verifying_key = key.verifyingKey();
        const proving_key = await this.fetchProvingKey(key.prover, key.locator);
        if (this.cacheOption) {
          this.cache.set(CREDITS_PROGRAM_KEYS.bond_public.locator, [proving_key.toBytes(), verifying_key.toBytes()]);
        }
        return [proving_key, verifying_key];
      } else {
        const keyPair = this.cache.get(key.locator);
        return [ProvingKey.fromBytes(keyPair[0]), VerifyingKey.fromBytes(keyPair[1])];
      }
    } catch (error) {
      throw new Error(`Error: fetching credits.aleo keys: ${error.message}`);
    }
  }
  async bondPublicKeys() {
    return this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.bond_public);
  }
  bondValidatorKeys() {
    return this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.bond_validator);
  }
  claimUnbondPublicKeys() {
    return this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.claim_unbond_public);
  }
  /**
   * Returns the proving and verifying keys for the transfer functions in the credits.aleo program
   * @param {string} visibility Visibility of the transfer function
   * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the transfer functions
   *
   * @example
   * // Create a new AleoKeyProvider
   * const networkClient = new AleoNetworkClient("https://api.explorer.provable.com/v1");
   * const keyProvider = new AleoKeyProvider();
   * const recordProvider = new NetworkRecordProvider(account, networkClient);
   *
   * // Initialize a program manager with the key provider to automatically fetch keys for value transfers
   * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
   * programManager.transfer(1, "aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at", "public", 0.5);
   *
   * // Keys can also be fetched manually
   * const [transferPublicProvingKey, transferPublicVerifyingKey] = await keyProvider.transferKeys("public");
   */
  async transferKeys(visibility) {
    if (PRIVATE_TRANSFER.has(visibility)) {
      return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.transfer_private);
    } else if (PRIVATE_TO_PUBLIC_TRANSFER.has(visibility)) {
      return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.transfer_private_to_public);
    } else if (PUBLIC_TRANSFER.has(visibility)) {
      return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.transfer_public);
    } else if (PUBLIC_TRANSFER_AS_SIGNER.has(visibility)) {
      return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.transfer_public_as_signer);
    } else if (PUBLIC_TO_PRIVATE_TRANSFER.has(visibility)) {
      return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.transfer_public_to_private);
    } else {
      throw new Error("Invalid visibility type");
    }
  }
  /**
   * Returns the proving and verifying keys for the join function in the credits.aleo program
   *
   * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function
   */
  async joinKeys() {
    return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.join);
  }
  /**
   * Returns the proving and verifying keys for the split function in the credits.aleo program
   *
   * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the split function
   * */
  async splitKeys() {
    return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.split);
  }
  /**
   * Returns the proving and verifying keys for the fee_private function in the credits.aleo program
   *
   * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the fee function
   */
  async feePrivateKeys() {
    return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.fee_private);
  }
  /**
   * Returns the proving and verifying keys for the fee_public function in the credits.aleo program
   *
   * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the fee function
   */
  async feePublicKeys() {
    return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.fee_public);
  }
  /**
   * Gets a verifying key. If the verifying key is for a credits.aleo function, get it from the wasm cache otherwise
   *
   * @returns {Promise<VerifyingKey>} Verifying key for the function
   */
  // attempt to fetch it from the network
  async getVerifyingKey(verifierUri) {
    switch (verifierUri) {
      case CREDITS_PROGRAM_KEYS.bond_public.verifier:
        return CREDITS_PROGRAM_KEYS.bond_public.verifyingKey();
      case CREDITS_PROGRAM_KEYS.bond_validator.verifier:
        return CREDITS_PROGRAM_KEYS.bond_validator.verifyingKey();
      case CREDITS_PROGRAM_KEYS.claim_unbond_public.verifier:
        return CREDITS_PROGRAM_KEYS.claim_unbond_public.verifyingKey();
      case CREDITS_PROGRAM_KEYS.fee_private.verifier:
        return CREDITS_PROGRAM_KEYS.fee_private.verifyingKey();
      case CREDITS_PROGRAM_KEYS.fee_public.verifier:
        return CREDITS_PROGRAM_KEYS.fee_public.verifyingKey();
      case CREDITS_PROGRAM_KEYS.inclusion.verifier:
        return CREDITS_PROGRAM_KEYS.inclusion.verifyingKey();
      case CREDITS_PROGRAM_KEYS.join.verifier:
        return CREDITS_PROGRAM_KEYS.join.verifyingKey();
      case CREDITS_PROGRAM_KEYS.set_validator_state.verifier:
        return CREDITS_PROGRAM_KEYS.set_validator_state.verifyingKey();
      case CREDITS_PROGRAM_KEYS.split.verifier:
        return CREDITS_PROGRAM_KEYS.split.verifyingKey();
      case CREDITS_PROGRAM_KEYS.transfer_private.verifier:
        return CREDITS_PROGRAM_KEYS.transfer_private.verifyingKey();
      case CREDITS_PROGRAM_KEYS.transfer_private_to_public.verifier:
        return CREDITS_PROGRAM_KEYS.transfer_private_to_public.verifyingKey();
      case CREDITS_PROGRAM_KEYS.transfer_public.verifier:
        return CREDITS_PROGRAM_KEYS.transfer_public.verifyingKey();
      case CREDITS_PROGRAM_KEYS.transfer_public_as_signer.verifier:
        return CREDITS_PROGRAM_KEYS.transfer_public_as_signer.verifyingKey();
      case CREDITS_PROGRAM_KEYS.transfer_public_to_private.verifier:
        return CREDITS_PROGRAM_KEYS.transfer_public_to_private.verifyingKey();
      case CREDITS_PROGRAM_KEYS.unbond_public.verifier:
        return CREDITS_PROGRAM_KEYS.unbond_public.verifyingKey();
      default:
        try {
          const response = await get(verifierUri);
          const text = await response.text();
          return VerifyingKey.fromString(text);
        } catch (e) {
          try {
            return VerifyingKey.fromBytes(await this.fetchBytes(verifierUri));
          } catch (inner) {
            throw new Error("Invalid verifying key. Error: " + inner.message);
          }
        }
    }
  }
  unBondPublicKeys() {
    return this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.unbond_public);
  }
};
var ProgramManager = class {
  /** Create a new instance of the ProgramManager
   *
   * @param { string | undefined } host A host uri running the official Aleo API
   * @param { FunctionKeyProvider | undefined } keyProvider A key provider that implements {@link FunctionKeyProvider} interface
   * @param { RecordProvider | undefined } recordProvider A record provider that implements {@link RecordProvider} interface
   */
  constructor(host, keyProvider, recordProvider) {
    __publicField(this, "account");
    __publicField(this, "keyProvider");
    __publicField(this, "host");
    __publicField(this, "networkClient");
    __publicField(this, "recordProvider");
    this.host = host ? host : "https://api.explorer.provable.com/v1";
    this.networkClient = new AleoNetworkClient(this.host);
    this.keyProvider = keyProvider ? keyProvider : new AleoKeyProvider();
    this.recordProvider = recordProvider;
  }
  /**
   * Check if the fee is sufficient to pay for the transaction
   */
  async checkFee(address, feeAmount) {
    const balance = BigInt(await this.networkClient.getPublicBalance(address));
    if (feeAmount > balance) {
      throw Error(`The desired execution requires a fee of ${feeAmount} microcredits, but the account paying the fee has ${balance} microcredits available.`);
    }
  }
  /**
   * Set the account to use for transaction submission to the Aleo network
   *
   * @param {Account} account Account to use for transaction submission
   */
  setAccount(account) {
    this.account = account;
  }
  /**
   * Set the key provider that provides the proving and verifying keys for programs
   *
   * @param {FunctionKeyProvider} keyProvider
   */
  setKeyProvider(keyProvider) {
    this.keyProvider = keyProvider;
  }
  /**
   * Set the host peer to use for transaction submission to the Aleo network
   *
   * @param host {string} Peer url to use for transaction submission
   */
  setHost(host) {
    this.host = host;
    this.networkClient.setHost(host);
  }
  /**
   * Set the record provider that provides records for transactions
   *
   * @param {RecordProvider} recordProvider
   */
  setRecordProvider(recordProvider) {
    this.recordProvider = recordProvider;
  }
  /**
   * Builds a deployment transaction for submission to the Aleo network.
   *
   * @param {string} program Program source code
   * @param {number} priorityFee The optional priority fee to be paid for that transaction.
   * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance
   * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for searching for a record to use pay the deployment fee
   * @param {string | RecordPlaintext | undefined} feeRecord Optional Fee record to use for the transaction
   * @param {PrivateKey | undefined} privateKey Optional private key to use for the transaction
   * @returns {string} The transaction id of the deployed program or a failure message from the network
   *
   * @example
   * /// Import the mainnet version of the sdk.
   * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a new NetworkClient, KeyProvider, and RecordProvider
   * const keyProvider = new AleoKeyProvider();
   * const recordProvider = new NetworkRecordProvider(account, networkClient);
   * keyProvider.useCache = true;
   *
   * // Initialize a program manager with the key provider to automatically fetch keys for deployments
   * const program = "program hello_hello.aleo;\n\nfunction hello:\n    input r0 as u32.public;\n    input r1 as u32.private;\n    add r0 r1 into r2;\n    output r2 as u32.private;\n";
   * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
   * programManager.setAccount(Account);
   *
   * // Define a fee in credits
   * const priorityFee = 0.0;
   *
   * // Create the deployment transaction.
   * const tx = await programManager.buildDeploymentTransaction(program, fee, false);
   * await programManager.networkClient.submitTransaction(tx);
   *
   * // Verify the transaction was successful
   * setTimeout(async () => {
   *  const transaction = await programManager.networkClient.getTransaction(tx.id());
   *  assert(transaction.id() === tx.id());
   * }, 20000);
   */
  async buildDeploymentTransaction(program, priorityFee, privateFee, recordSearchParams, feeRecord, privateKey) {
    let programObject;
    try {
      programObject = Program.fromString(program);
    } catch (e) {
      logAndThrow(`Error parsing program: '${e.message}'. Please ensure the program is valid.`);
    }
    try {
      let programSource;
      try {
        programSource = await this.networkClient.getProgram(programObject.id());
      } catch (e) {
        console.log(`Program ${programObject.id()} does not exist on the network, deploying...`);
      }
      if (typeof programSource === "string") {
        throw Error(`Program ${programObject.id()} already exists on the network, please rename your program`);
      }
    } catch (e) {
      logAndThrow(`Error validating program: ${e.message}`);
    }
    let deploymentPrivateKey = privateKey;
    if (typeof privateKey === "undefined" && typeof this.account !== "undefined") {
      deploymentPrivateKey = this.account.privateKey();
    }
    if (typeof deploymentPrivateKey === "undefined") {
      throw "No private key provided and no private key set in the ProgramManager";
    }
    try {
      feeRecord = privateFee ? await this.getCreditsRecord(priorityFee, [], feeRecord, recordSearchParams) : void 0;
    } catch (e) {
      logAndThrow(`Error finding fee record. Record finder response: '${e.message}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`);
    }
    let feeKeys;
    try {
      feeKeys = privateFee ? await this.keyProvider.feePrivateKeys() : await this.keyProvider.feePublicKeys();
    } catch (e) {
      logAndThrow(`Error finding fee keys. Key finder response: '${e.message}'. Please ensure your key provider is configured correctly.`);
    }
    const [feeProvingKey, feeVerifyingKey] = feeKeys;
    let imports;
    try {
      imports = await this.networkClient.getProgramImports(program);
    } catch (e) {
      logAndThrow(`Error finding program imports. Network response: '${e.message}'. Please ensure you're connected to a valid Aleo network and the program is deployed to the network.`);
    }
    return await ProgramManager$1.buildDeploymentTransaction(deploymentPrivateKey, program, priorityFee, feeRecord, this.host, imports, feeProvingKey, feeVerifyingKey);
  }
  /**
   * Deploy an Aleo program to the Aleo network
   *
   * @param {string} program Program source code
   * @param {number} priorityFee The optional fee to be paid for the transaction
   * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance
   * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for searching for a record to used pay the deployment fee
   * @param {string | RecordPlaintext | undefined} feeRecord Optional Fee record to use for the transaction
   * @param {PrivateKey | undefined} privateKey Optional private key to use for the transaction
   * @returns {string} The transaction id of the deployed program or a failure message from the network
   *
   * @example
   * /// Import the mainnet version of the sdk.
   * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a new NetworkClient, KeyProvider, and RecordProvider
   * const keyProvider = new AleoKeyProvider();
   * const recordProvider = new NetworkRecordProvider(account, networkClient);
   * keyProvider.useCache = true;
   *
   * // Initialize a program manager with the key provider to automatically fetch keys for deployments
   * const program = "program hello_hello.aleo;\n\nfunction hello:\n    input r0 as u32.public;\n    input r1 as u32.private;\n    add r0 r1 into r2;\n    output r2 as u32.private;\n";
   * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
   *
   * // Define a fee in credits
   * const priorityFee = 0.0;
   *
   * // Deploy the program
   * const tx_id = await programManager.deploy(program, fee, false);
   *
   * // Verify the transaction was successful
   * setTimeout(async () => {
   *  const transaction = await programManager.networkClient.getTransaction(tx_id);
   *  assert(transaction.id() === tx_id);
   * }, 20000);
   */
  async deploy(program, priorityFee, privateFee, recordSearchParams, feeRecord, privateKey) {
    var _a;
    const tx = await this.buildDeploymentTransaction(program, priorityFee, privateFee, recordSearchParams, feeRecord, privateKey);
    let feeAddress;
    if (typeof privateKey !== "undefined") {
      feeAddress = Address.from_private_key(privateKey);
    } else if (this.account !== void 0) {
      feeAddress = (_a = this.account) == null ? void 0 : _a.address();
    } else {
      throw Error("No private key provided and no private key set in the ProgramManager. Please set an account or provide a private key.");
    }
    await this.checkFee(feeAddress.to_string(), tx.feeAmount());
    return await this.networkClient.submitTransaction(tx);
  }
  /**
   * Builds an execution transaction for submission to the Aleo network.
   *
   * @param {ExecuteOptions} options - The options for the execution transaction.
   * @returns {Promise<Transaction>} - A promise that resolves to the transaction or an error.
   *
   * @example
   * /// Import the mainnet version of the sdk.
   * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a new NetworkClient, KeyProvider, and RecordProvider using official Aleo record, key, and network providers
   * const keyProvider = new AleoKeyProvider();
   * const recordProvider = new NetworkRecordProvider(account, networkClient);
   * keyProvider.useCache = true;
   *
   * // Initialize a program manager with the key provider to automatically fetch keys for executions
   * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
   *
   * // Build and execute the transaction
   * const tx = await programManager.buildExecutionTransaction({
   *   programName: "hello_hello.aleo",
   *   functionName: "hello_hello",
   *   priorityFee: 0.0,
   *   privateFee: false,
   *   inputs: ["5u32", "5u32"],
   *   keySearchParams: { "cacheKey": "hello_hello:hello" }
   * });
   *
   * // Submit the transaction to the network
   * await programManager.networkClient.submitTransaction(tx.toString());
   *
   * // Verify the transaction was successful
   * setTimeout(async () => {
   *  const transaction = await programManager.networkClient.getTransaction(tx.id());
   *  assert(transaction.id() === tx.id());
   * }, 10000);
   */
  async buildExecutionTransaction(options) {
    const { programName, functionName, priorityFee, privateFee, inputs, recordSearchParams, keySearchParams, privateKey, offlineQuery } = options;
    let feeRecord = options.feeRecord;
    let provingKey = options.provingKey;
    let verifyingKey = options.verifyingKey;
    let program = options.program;
    let imports = options.imports;
    if (program === void 0) {
      try {
        program = await this.networkClient.getProgram(programName);
      } catch (e) {
        logAndThrow(`Error finding ${programName}. Network response: '${e.message}'. Please ensure you're connected to a valid Aleo network the program is deployed to the network.`);
      }
    } else if (program instanceof Program) {
      program = program.toString();
    }
    let executionPrivateKey = privateKey;
    if (typeof privateKey === "undefined" && typeof this.account !== "undefined") {
      executionPrivateKey = this.account.privateKey();
    }
    if (typeof executionPrivateKey === "undefined") {
      throw "No private key provided and no private key set in the ProgramManager";
    }
    try {
      feeRecord = privateFee ? await this.getCreditsRecord(priorityFee, [], feeRecord, recordSearchParams) : void 0;
    } catch (e) {
      logAndThrow(`Error finding fee record. Record finder response: '${e.message}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`);
    }
    let feeKeys;
    try {
      feeKeys = privateFee ? await this.keyProvider.feePrivateKeys() : await this.keyProvider.feePublicKeys();
    } catch (e) {
      logAndThrow(`Error finding fee keys. Key finder response: '${e.message}'. Please ensure your key provider is configured correctly.`);
    }
    const [feeProvingKey, feeVerifyingKey] = feeKeys;
    if (!provingKey || !verifyingKey) {
      try {
        [provingKey, verifyingKey] = await this.keyProvider.functionKeys(keySearchParams);
      } catch (e) {
        console.log(`Function keys not found. Key finder response: '${e}'. The function keys will be synthesized`);
      }
    }
    const numberOfImports = Program.fromString(program).getImports().length;
    if (numberOfImports > 0 && !imports) {
      try {
        imports = await this.networkClient.getProgramImports(programName);
      } catch (e) {
        logAndThrow(`Error finding program imports. Network response: '${e.message}'. Please ensure you're connected to a valid Aleo network and the program is deployed to the network.`);
      }
    }
    return await ProgramManager$1.buildExecutionTransaction(executionPrivateKey, program, functionName, inputs, priorityFee, feeRecord, this.host, imports, provingKey, verifyingKey, feeProvingKey, feeVerifyingKey, offlineQuery);
  }
  /**
   * Builds an execution transaction for submission to the Aleo network.
   *
   * @param {ExecuteOptions} options - The options for the execution transaction.
   * @returns {Promise<string>} - The transaction id
   *
   * @example
   * /// Import the mainnet version of the sdk.
   * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a new NetworkClient, KeyProvider, and RecordProvider using official Aleo record, key, and network providers
   * const keyProvider = new AleoKeyProvider();
   * const recordProvider = new NetworkRecordProvider(account, networkClient);
   * keyProvider.useCache = true;
   *
   * // Initialize a program manager with the key provider to automatically fetch keys for executions
   * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
   *
   * // Build and execute the transaction
   * const tx_id = await programManager.execute({
   *   programName: "hello_hello.aleo",
   *   functionName: "hello_hello",
   *   priorityFee: 0.0,
   *   privateFee: false,
   *   inputs: ["5u32", "5u32"],
   *   keySearchParams: { "cacheKey": "hello_hello:hello" }
   * });
   *
   * // Verify the transaction was successful
   * setTimeout(async () => {
   *  const transaction = await programManager.networkClient.getTransaction(tx_id);
   *  assert(transaction.id() === tx_id);
   * }, 10000);
   */
  async execute(options) {
    var _a;
    const tx = await this.buildExecutionTransaction(options);
    let feeAddress;
    if (typeof options.privateKey !== "undefined") {
      feeAddress = Address.from_private_key(options.privateKey);
    } else if (this.account !== void 0) {
      feeAddress = (_a = this.account) == null ? void 0 : _a.address();
    } else {
      throw Error("No private key provided and no private key set in the ProgramManager. Please set an account or provide a private key.");
    }
    await this.checkFee(feeAddress.to_string(), tx.feeAmount());
    return await this.networkClient.submitTransaction(tx);
  }
  /**
   * Run an Aleo program in offline mode
   *
   * @param {string} program Program source code containing the function to be executed
   * @param {string} function_name Function name to execute
   * @param {string[]} inputs Inputs to the function
   * @param {number} proveExecution Whether to prove the execution of the function and return an execution transcript that contains the proof.
   * @param {string[] | undefined} imports Optional imports to the program
   * @param {KeySearchParams | undefined} keySearchParams Optional parameters for finding the matching proving & verifying keys for the function
   * @param {ProvingKey | undefined} provingKey Optional proving key to use for the transaction
   * @param {VerifyingKey | undefined} verifyingKey Optional verifying key to use for the transaction
   * @param {PrivateKey | undefined} privateKey Optional private key to use for the transaction
   * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment
   * @returns {Promise<ExecutionResponse>} The execution response containing the outputs of the function and the proof if the program is proved.
   *
   * @example
   * /// Import the mainnet version of the sdk used to build executions.
   * import { Account, ProgramManager } from "@provablehq/sdk/mainnet.js";
   *
   * /// Create the source for the "helloworld" program
   * const program = "program helloworld.aleo;\n\nfunction hello:\n    input r0 as u32.public;\n    input r1 as u32.private;\n    add r0 r1 into r2;\n    output r2 as u32.private;\n";
   * const programManager = new ProgramManager(undefined, undefined, undefined);
   *
   * /// Create a temporary account for the execution of the program
   * const account = new Account();
   * programManager.setAccount(account);
   *
   * /// Get the response and ensure that the program executed correctly
   * const executionResponse = await programManager.run(program, "hello", ["5u32", "5u32"]);
   * const result = executionResponse.getOutputs();
   * assert(result === ["10u32"]);
   */
  async run(program, function_name, inputs, proveExecution, imports, keySearchParams, provingKey, verifyingKey, privateKey, offlineQuery) {
    let executionPrivateKey = privateKey;
    if (typeof privateKey === "undefined" && typeof this.account !== "undefined") {
      executionPrivateKey = this.account.privateKey();
    }
    if (typeof executionPrivateKey === "undefined") {
      throw "No private key provided and no private key set in the ProgramManager";
    }
    if (!provingKey || !verifyingKey) {
      try {
        [provingKey, verifyingKey] = await this.keyProvider.functionKeys(keySearchParams);
      } catch (e) {
        console.log(`Function keys not found. Key finder response: '${e}'. The function keys will be synthesized`);
      }
    }
    console.log("Running program offline");
    console.log("Proving key: ", provingKey);
    console.log("Verifying key: ", verifyingKey);
    return ProgramManager$1.executeFunctionOffline(executionPrivateKey, program, function_name, inputs, proveExecution, false, imports, provingKey, verifyingKey, this.host, offlineQuery);
  }
  /**
   * Join two credits records into a single credits record
   *
   * @param {RecordPlaintext | string} recordOne First credits record to join
   * @param {RecordPlaintext | string} recordTwo Second credits record to join
   * @param {number} priorityFee The optional priority fee to be paid for the transaction
   * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance
   * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for finding the fee record to use to pay the fee for the join transaction
   * @param {RecordPlaintext | string | undefined} feeRecord Fee record to use for the join transaction
   * @param {PrivateKey | undefined} privateKey Private key to use for the join transaction
   * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment
   * @returns {Promise<string>} The transaction id
   *
   * @example
   * /// Import the mainnet version of the sdk.
   * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a new NetworkClient, KeyProvider, and RecordProvider
   * const keyProvider = new AleoKeyProvider();
   * const recordProvider = new NetworkRecordProvider(account, networkClient);
   * keyProvider.useCache = true;
   *
   * // Initialize a program manager with the key provider to automatically fetch keys for executions
   * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
   * const record_1 = "{  owner: aleo184vuwr5u7u0ha5f5k44067dd2uaqewxx6pe5ltha5pv99wvhfqxqv339h4.private,  microcredits: 45000000u64.private,  _nonce: 4106205762862305308495708971985748592380064201230396559307556388725936304984group.public}"
   * const record_2 = "{  owner: aleo184vuwr5u7u0ha5f5k44067dd2uaqewxx6pe5ltha5pv99wvhfqxqv339h4.private,  microcredits: 45000000u64.private,  _nonce: 1540945439182663264862696551825005342995406165131907382295858612069623286213group.public}"
   * const tx_id = await programManager.join(record_1, record_2, 0.05, false);
   *
   * // Verify the transaction was successful
   * setTimeout(async () => {
   *  const transaction = await programManager.networkClient.getTransaction(tx_id);
   *  assert(transaction.id() === tx_id);
   * }, 10000);
   */
  async join(recordOne, recordTwo, priorityFee, privateFee, recordSearchParams, feeRecord, privateKey, offlineQuery) {
    var _a;
    let executionPrivateKey = privateKey;
    let feeAddress;
    if (typeof privateKey === "undefined" && typeof this.account !== "undefined") {
      executionPrivateKey = this.account.privateKey();
      feeAddress = (_a = this.account) == null ? void 0 : _a.address();
    } else if (typeof executionPrivateKey === "undefined") {
      throw "No private key provided and no private key set in the ProgramManager";
    } else {
      feeAddress = Address.from_private_key(executionPrivateKey);
    }
    let feeKeys;
    let joinKeys;
    try {
      feeKeys = privateFee ? await this.keyProvider.feePrivateKeys() : await this.keyProvider.feePublicKeys();
      joinKeys = await this.keyProvider.joinKeys();
    } catch (e) {
      logAndThrow(`Error finding fee keys. Key finder response: '${e.message}'. Please ensure your key provider is configured correctly.`);
    }
    const [feeProvingKey, feeVerifyingKey] = feeKeys;
    const [joinProvingKey, joinVerifyingKey] = joinKeys;
    try {
      feeRecord = privateFee ? await this.getCreditsRecord(priorityFee, [], feeRecord, recordSearchParams) : void 0;
    } catch (e) {
      logAndThrow(`Error finding fee record. Record finder response: '${e.message}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`);
    }
    try {
      recordOne = recordOne instanceof RecordPlaintext ? recordOne : RecordPlaintext.fromString(recordOne);
      recordTwo = recordTwo instanceof RecordPlaintext ? recordTwo : RecordPlaintext.fromString(recordTwo);
    } catch (e) {
      logAndThrow("Records provided are not valid. Please ensure they are valid plaintext records.");
    }
    const tx = await ProgramManager$1.buildJoinTransaction(executionPrivateKey, recordOne, recordTwo, priorityFee, feeRecord, this.host, joinProvingKey, joinVerifyingKey, feeProvingKey, feeVerifyingKey, offlineQuery);
    await this.checkFee(feeAddress.to_string(), tx.feeAmount());
    return await this.networkClient.submitTransaction(tx);
  }
  /**
   * Split credits into two new credits records
   *
   * @param {number} splitAmount Amount in microcredits to split from the original credits record
   * @param {RecordPlaintext | string} amountRecord Amount record to use for the split transaction
   * @param {PrivateKey | undefined} privateKey Optional private key to use for the split transaction
   * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment
   * @returns {Promise<string>} The transaction id
   *
   * @example
   * /// Import the mainnet version of the sdk.
   * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a new NetworkClient, KeyProvider, and RecordProvider
   * const keyProvider = new AleoKeyProvider();
   * const recordProvider = new NetworkRecordProvider(account, networkClient);
   * keyProvider.useCache = true;
   *
   * // Initialize a program manager with the key provider to automatically fetch keys for executions
   * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
   * const record = "{  owner: aleo184vuwr5u7u0ha5f5k44067dd2uaqewxx6pe5ltha5pv99wvhfqxqv339h4.private,  microcredits: 45000000u64.private,  _nonce: 4106205762862305308495708971985748592380064201230396559307556388725936304984group.public}"
   * const tx_id = await programManager.split(25000000, record);
   *
   * // Verify the transaction was successful
   * setTimeout(async () => {
   *  const transaction = await programManager.networkClient.getTransaction(tx_id);
   *  assert(transaction.id() === tx_id);
   * }, 10000);
   */
  async split(splitAmount, amountRecord, privateKey, offlineQuery) {
    let executionPrivateKey = privateKey;
    if (typeof privateKey === "undefined" && typeof this.account !== "undefined") {
      executionPrivateKey = this.account.privateKey();
    }
    if (typeof executionPrivateKey === "undefined") {
      throw "No private key provided and no private key set in the ProgramManager";
    }
    let splitKeys;
    try {
      splitKeys = await this.keyProvider.splitKeys();
    } catch (e) {
      logAndThrow(`Error finding fee keys. Key finder response: '${e.message}'. Please ensure your key provider is configured correctly.`);
    }
    const [splitProvingKey, splitVerifyingKey] = splitKeys;
    try {
      amountRecord = amountRecord instanceof RecordPlaintext ? amountRecord : RecordPlaintext.fromString(amountRecord);
    } catch (e) {
      logAndThrow("Record provided is not valid. Please ensure it is a valid plaintext record.");
    }
    const tx = await ProgramManager$1.buildSplitTransaction(executionPrivateKey, splitAmount, amountRecord, this.host, splitProvingKey, splitVerifyingKey, offlineQuery);
    return await this.networkClient.submitTransaction(tx);
  }
  /**
   * Pre-synthesize proving and verifying keys for a program
   *
   * @param program {string} The program source code to synthesize keys for
   * @param function_id {string} The function id to synthesize keys for
   * @param inputs {Array<string>}  Sample inputs to the function
   * @param privateKey {PrivateKey | undefined} Optional private key to use for the key synthesis
   *
   * @returns {Promise<FunctionKeyPair>}
   */
  async synthesizeKeys(program, function_id, inputs, privateKey) {
    let imports;
    let executionPrivateKey = privateKey;
    if (typeof executionPrivateKey === "undefined") {
      if (typeof this.account !== "undefined") {
        executionPrivateKey = this.account.privateKey();
      } else {
        executionPrivateKey = new PrivateKey();
      }
    }
    try {
      imports = await this.networkClient.getProgramImports(program);
      const keyPair = await ProgramManager$1.synthesizeKeyPair(executionPrivateKey, program, function_id, inputs, imports);
      return [
        keyPair.provingKey(),
        keyPair.verifyingKey()
      ];
    } catch (e) {
      logAndThrow(`Could not synthesize keys - error ${e.message}. Please ensure the program is valid and the inputs are correct.`);
    }
  }
  /**
   * Build a transaction to transfer credits to another account for later submission to the Aleo network
   *
   * @param {number} amount The amount of credits to transfer
   * @param {string} recipient The recipient of the transfer
   * @param {string} transferType The type of transfer to perform - options: 'private', 'privateToPublic', 'public', 'publicToPrivate'
   * @param {number} priorityFee The optional priority fee to be paid for the transaction
   * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance
   * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for finding the amount and fee records for the transfer transaction
   * @param {RecordPlaintext | string} amountRecord Optional amount record to use for the transfer
   * @param {RecordPlaintext | string} feeRecord Optional fee record to use for the transfer
   * @param {PrivateKey | undefined} privateKey Optional private key to use for the transfer transaction
   * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment
   * @returns {Promise<Transaction>} The transaction object
   *
   * @example
   * /// Import the mainnet version of the sdk.
   * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a new NetworkClient, KeyProvider, and RecordProvider
   * const keyProvider = new AleoKeyProvider();
   * const recordProvider = new NetworkRecordProvider(account, networkClient);
   * keyProvider.useCache = true;
   *
   * // Initialize a program manager with the key provider to automatically fetch keys for executions
   * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
   * const tx = await programManager.buildTransferTransaction(1, "aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px", "public", 0.2, false);
   * await programManager.networkClient.submitTransaction(tx.toString());
   *
   * // Verify the transaction was successful
   * setTimeout(async () => {
   *  const transaction = await programManager.networkClient.getTransaction(tx.id());
   *  assert(transaction.id() === tx.id());
   * }, 10000);
   */
  async buildTransferTransaction(amount, recipient, transferType, priorityFee, privateFee, recordSearchParams, amountRecord, feeRecord, privateKey, offlineQuery) {
    transferType = validateTransferType(transferType);
    let executionPrivateKey = privateKey;
    if (typeof executionPrivateKey === "undefined" && typeof this.account !== "undefined") {
      executionPrivateKey = this.account.privateKey();
    }
    if (typeof executionPrivateKey === "undefined") {
      throw "No private key provided and no private key set in the ProgramManager";
    }
    let feeKeys;
    let transferKeys;
    try {
      feeKeys = privateFee ? await this.keyProvider.feePrivateKeys() : await this.keyProvider.feePublicKeys();
      transferKeys = await this.keyProvider.transferKeys(transferType);
    } catch (e) {
      logAndThrow(`Error finding fee keys. Key finder response: '${e.message}'. Please ensure your key provider is configured correctly.`);
    }
    const [feeProvingKey, feeVerifyingKey] = feeKeys;
    const [transferProvingKey, transferVerifyingKey] = transferKeys;
    try {
      const nonces = [];
      if (requiresAmountRecord(transferType)) {
        amountRecord = await this.getCreditsRecord(priorityFee, [], amountRecord, recordSearchParams);
        nonces.push(amountRecord.nonce());
      } else {
        amountRecord = void 0;
      }
      feeRecord = privateFee ? await this.getCreditsRecord(priorityFee, nonces, feeRecord, recordSearchParams) : void 0;
    } catch (e) {
      logAndThrow(`Error finding fee record. Record finder response: '${e.message}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`);
    }
    return await ProgramManager$1.buildTransferTransaction(executionPrivateKey, amount, recipient, transferType, amountRecord, priorityFee, feeRecord, this.host, transferProvingKey, transferVerifyingKey, feeProvingKey, feeVerifyingKey, offlineQuery);
  }
  /**
   * Build a transfer_public transaction to transfer credits to another account for later submission to the Aleo network
   *
   * @param {number} amount The amount of credits to transfer
   * @param {string} recipient The recipient of the transfer
   * @param {number} priorityFee The optional priority fee to be paid for the transfer
   * @param {PrivateKey | undefined} privateKey Optional private key to use for the transfer transaction
   * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment
   * @returns {Promise<Transaction>} The transaction object
   *
   * @example
   * /// Import the mainnet version of the sdk.
   * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a new NetworkClient, KeyProvider, and RecordProvider
   * const keyProvider = new AleoKeyProvider();
   * const recordProvider = new NetworkRecordProvider(account, networkClient);
   * keyProvider.useCache = true;
   *
   * // Initialize a program manager with the key provider to automatically fetch keys for executions
   * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
   * const tx = await programManager.buildTransferPublicTransaction(1, "aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px", 0.2);
   * await programManager.networkClient.submitTransaction(tx.toString());
   *
   * // Verify the transaction was successful
   * setTimeout(async () => {
   *  const transaction = await programManager.networkClient.getTransaction(tx.id());
   *  assert(transaction.id() === tx.id());
   * }, 10000);
   */
  async buildTransferPublicTransaction(amount, recipient, priorityFee, privateKey, offlineQuery) {
    return this.buildTransferTransaction(amount, recipient, "public", priorityFee, false, void 0, void 0, void 0, privateKey, offlineQuery);
  }
  /**
   * Build a transfer_public_as_signer transaction to transfer credits to another account for later submission to the Aleo network
   *
   * @param {number} amount The amount of credits to transfer
   * @param {string} recipient The recipient of the transfer
   * @param {number} priorityFee The optional priority fee to be paid for the transfer
   * @param {PrivateKey | undefined} privateKey Optional private key to use for the transfer transaction
   * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment
   * @returns {Promise<Transaction>} The transaction object
   *
   * @example
   * /// Import the mainnet version of the sdk.
   * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a new NetworkClient, KeyProvider, and RecordProvider
   * const keyProvider = new AleoKeyProvider();
   * const recordProvider = new NetworkRecordProvider(account, networkClient);
   * keyProvider.useCache = true;
   *
   * // Initialize a program manager with the key provider to automatically fetch keys for executions
   * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
   * const tx = await programManager.buildTransferPublicAsSignerTransaction(1, "aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px", 0.2);
   * await programManager.networkClient.submitTransaction(tx.toString());
   *
   * // Verify the transaction was successful
   * setTimeout(async () => {
   *  const transaction = await programManager.networkClient.getTransaction(tx.id());
   *  assert(transaction.id() === tx.id());
   * }, 10000);
   */
  async buildTransferPublicAsSignerTransaction(amount, recipient, priorityFee, privateKey, offlineQuery) {
    return this.buildTransferTransaction(amount, recipient, "public", priorityFee, false, void 0, void 0, void 0, privateKey, offlineQuery);
  }
  /**
   * Transfer credits to another account
   *
   * @param {number} amount The amount of credits to transfer
   * @param {string} recipient The recipient of the transfer
   * @param {string} transferType The type of transfer to perform - options: 'private', 'privateToPublic', 'public', 'publicToPrivate'
   * @param {number} priorityFee The optional priority fee to be paid for the transfer
   * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance
   * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for finding the amount and fee records for the transfer transaction
   * @param {RecordPlaintext | string} amountRecord Optional amount record to use for the transfer
   * @param {RecordPlaintext | string} feeRecord Optional fee record to use for the transfer
   * @param {PrivateKey | undefined} privateKey Optional private key to use for the transfer transaction
   * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment
   * @returns {Promise<string>} The transaction id
   *
   * @example
   * /// Import the mainnet version of the sdk.
   * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a new NetworkClient, KeyProvider, and RecordProvider
   * const keyProvider = new AleoKeyProvider();
   * const recordProvider = new NetworkRecordProvider(account, networkClient);
   * keyProvider.useCache = true;
   *
   * // Initialize a program manager with the key provider to automatically fetch keys for executions
   * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
   * const tx_id = await programManager.transfer(1, "aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px", "public", 0.2, false);
   *
   * // Verify the transaction was successful
   * setTimeout(async () => {
   *  const transaction = await programManager.networkClient.getTransaction(tx_id);
   *  assert(transaction.id() === tx_id);
   * }, 10000);
   */
  async transfer(amount, recipient, transferType, priorityFee, privateFee, recordSearchParams, amountRecord, feeRecord, privateKey, offlineQuery) {
    var _a;
    const tx = await this.buildTransferTransaction(amount, recipient, transferType, priorityFee, privateFee, recordSearchParams, amountRecord, feeRecord, privateKey, offlineQuery);
    let feeAddress;
    if (typeof privateKey !== "undefined") {
      feeAddress = Address.from_private_key(privateKey);
    } else if (this.account !== void 0) {
      feeAddress = (_a = this.account) == null ? void 0 : _a.address();
    } else {
      throw Error("No private key provided and no private key set in the ProgramManager. Please set an account or provide a private key.");
    }
    await this.checkFee(feeAddress.to_string(), tx.feeAmount());
    return await this.networkClient.submitTransaction(tx);
  }
  /**
   * Build transaction to bond credits to a validator for later submission to the Aleo Network
   *
   * @param {string} validator_address Address of the validator to bond to, if this address is the same as the staker (i.e. the executor of this function), it will attempt to bond the credits as a validator. Bonding as a validator currently requires a minimum of 10,000,000 credits to bond (subject to change). If the address is specified is an existing validator and is different from the address of the executor of this function, it will bond the credits to that validator's staking committee as a delegator. A minimum of 10 credits is required to bond as a delegator.
   * @param {string} withdrawal_address Address to withdraw the staked credits to when unbond_public is called.
   * @param {number} amount The amount of credits to bond
   * @param {Partial<ExecuteOptions>} options - Override default execution options.
   * @returns {Promise<Transaction>} The transaction object
   *
   * @example
   * // Import the mainnet version of the sdk.
   * import { AleoKeyProvider, ProgramManager } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a keyProvider to handle key management
   * const keyProvider = new AleoKeyProvider();
   * keyProvider.useCache = true;
   *
   * // Create a new ProgramManager with the key that will be used to bond credits
   * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, undefined);
   * programManager.setAccount(new Account("YourPrivateKey"));
   *
   * // Create the bonding transaction object for later submission
   * const tx = await programManager.buildBondPublicTransaction("aleo1jx8s4dvjepculny4wfrzwyhs3tlyv65r58ns3g6q2gm2esh7ps8sqy9s5j", "aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px", "aleo1feya8sjy9k2zflvl2dx39pdsq5tju28elnp2ektnn588uu9ghv8s84msv9", 2000000);
   *
   * // The transaction can be later submitted to the network using the network client.
   * await programManager.networkClient.submitTransaction(tx.toString());
   *
   * // Verify the transaction was successful
   * setTimeout(async () => {
   *  const transaction = await programManager.networkClient.getTransaction(tx.id());
   *  assert(transaction.id() === tx.id());
   * }, 10000);
   */
  async buildBondPublicTransaction(validator_address, withdrawal_address, amount, options = {}) {
    const scaledAmount = Math.trunc(amount * 1e6);
    const { programName = "credits.aleo", functionName = "bond_public", priorityFee = options.priorityFee || 0, privateFee = false, inputs = [
      validator_address,
      withdrawal_address,
      `${scaledAmount.toString()}u64`
    ], keySearchParams = new AleoKeyProviderParams({
      proverUri: CREDITS_PROGRAM_KEYS.bond_public.prover,
      verifierUri: CREDITS_PROGRAM_KEYS.bond_public.verifier,
      cacheKey: "credits.aleo/bond_public"
    }), program = this.creditsProgram(), ...additionalOptions } = options;
    const executeOptions = {
      programName,
      functionName,
      priorityFee,
      privateFee,
      inputs,
      keySearchParams,
      ...additionalOptions
    };
    return await this.buildExecutionTransaction(executeOptions);
  }
  /**
   * Bond credits to validator.
   *
   * @param {string} validator_address Address of the validator to bond to, if this address is the same as the signer (i.e. the executor of this function), it will attempt to bond the credits as a validator. Bonding as a validator currently requires a minimum of 1,000,000 credits to bond (subject to change). If the address is specified is an existing validator and is different from the address of the executor of this function, it will bond the credits to that validator's staking committee as a delegator. A minimum of 10 credits is required to bond as a delegator.
   * @param {string} withdrawal_address Address to withdraw the staked credits to when unbond_public is called.
   * @param {number} amount The amount of credits to bond
   * @param {Options} options Options for the execution
   * @returns {Promise<string>} The transaction id
   *
   * @example
   * // Import the mainnet version of the sdk.
   * import { AleoKeyProvider, ProgramManager } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a keyProvider to handle key management
   * const keyProvider = new AleoKeyProvider();
   * keyProvider.useCache = true;
   *
   * // Create a new ProgramManager with the key that will be used to bond credits
   * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, undefined);
   *
   * // Create the bonding transaction
   * tx_id = await programManager.bondPublic("aleo1jx8s4dvjepculny4wfrzwyhs3tlyv65r58ns3g6q2gm2esh7ps8sqy9s5j", "aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px", "aleo1feya8sjy9k2zflvl2dx39pdsq5tju28elnp2ektnn588uu9ghv8s84msv9", 2000000);
   *
   * // Verify the transaction was successful
   * setTimeout(async () => {
   *  const transaction = await programManager.networkClient.getTransaction(tx_id);
   *  assert(transaction.id() === tx_id);
   * }, 10000);
   */
  async bondPublic(validator_address, withdrawal_address, amount, options = {}) {
    var _a;
    const tx = await this.buildBondPublicTransaction(validator_address, withdrawal_address, amount, options);
    let feeAddress;
    if (typeof options.privateKey !== "undefined") {
      feeAddress = Address.from_private_key(options.privateKey);
    } else if (this.account !== void 0) {
      feeAddress = (_a = this.account) == null ? void 0 : _a.address();
    } else {
      throw Error("No private key provided and no private key set in the ProgramManager. Please set an account or provide a private key.");
    }
    await this.checkFee(feeAddress.to_string(), tx.feeAmount());
    return await this.networkClient.submitTransaction(tx);
  }
  /**
   * Build a bond_validator transaction for later submission to the Aleo Network.
   *
   * @param {string} validator_address Address of the validator to bond to, if this address is the same as the staker (i.e. the executor of this function), it will attempt to bond the credits as a validator. If the address is specified is an existing validator and is different from the address of the executor of this function, it will bond the credits to that validator's staking committee as a delegator.
   * @param {string} withdrawal_address Address to withdraw the staked credits to when unbond_public is called.
   * @param {number} amount The amount of credits to bond. A minimum of 10000 credits is required to bond as a delegator.
   * @param {number} commission The commission rate for the validator (must be between 0 and 100 - an error will be thrown if it is not)
   * @param {Partial<ExecuteOptions>} options - Override default execution options.
   * @returns {Promise<Transaction>} The transaction object
   *
   * @example
   * // Import the mainnet version of the sdk.
   * import { AleoKeyProvider, ProgramManager } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a keyProvider to handle key management
   * const keyProvider = new AleoKeyProvider();
   * keyProvider.useCache = true;
   *
   * // Create a new ProgramManager with the key that will be used to bond credits
   * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, undefined);
   * programManager.setAccount(new Account("YourPrivateKey"));
   *
   * // Create the bond validator transaction object for later use.
   * const tx = await programManager.buildBondValidatorTransaction("aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px", "aleo1feya8sjy9k2zflvl2dx39pdsq5tju28elnp2ektnn588uu9ghv8s84msv9", 2000000);
   *
   * // The transaction can later be submitted to the network using the network client.
   * const tx_id = await programManager.networkClient.submitTransaction(tx.toString());
   *
   * // Verify the transaction was successful
   * setTimeout(async () => {
   *  const transaction = await programManager.networkClient.getTransaction(tx_id);
   *  assert(transaction.id() === tx_id);
   * }, 10000);
   */
  async buildBondValidatorTransaction(validator_address, withdrawal_address, amount, commission, options = {}) {
    const scaledAmount = Math.trunc(amount * 1e6);
    const adjustedCommission = Math.trunc(commission);
    const { programName = "credits.aleo", functionName = "bond_validator", priorityFee = options.priorityFee || 0, privateFee = false, inputs = [
      validator_address,
      withdrawal_address,
      `${scaledAmount.toString()}u64`,
      `${adjustedCommission.toString()}u8`
    ], keySearchParams = new AleoKeyProviderParams({
      proverUri: CREDITS_PROGRAM_KEYS.bond_validator.prover,
      verifierUri: CREDITS_PROGRAM_KEYS.bond_validator.verifier,
      cacheKey: "credits.aleo/bond_validator"
    }), program = this.creditsProgram(), ...additionalOptions } = options;
    const executeOptions = {
      programName,
      functionName,
      priorityFee,
      privateFee,
      inputs,
      keySearchParams,
      ...additionalOptions
    };
    return await this.buildExecutionTransaction(executeOptions);
  }
  /**
   * Build transaction to bond a validator.
   *
   * @param {string} validator_address Address of the validator to bond to, if this address is the same as the staker (i.e. the executor of this function), it will attempt to bond the credits as a validator. Bonding as a validator currently requires a minimum of 10,000,000 credits to bond (subject to change). If the address is specified is an existing validator and is different from the address of the executor of this function, it will bond the credits to that validator's staking committee as a delegator. A minimum of 10 credits is required to bond as a delegator.
   * @param {string} withdrawal_address Address to withdraw the staked credits to when unbond_public is called.
   * @param {number} amount The amount of credits to bond
   * @param {number} commission The commission rate for the validator (must be between 0 and 100 - an error will be thrown if it is not)
   * @param {Partial<ExecuteOptions>} options - Override default execution options.
   * @returns {Promise<string>} The transaction id
   *
   * @example
   * // Import the mainnet version of the sdk.
   * import { AleoKeyProvider, ProgramManager } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a keyProvider to handle key management
   * const keyProvider = new AleoKeyProvider();
   * keyProvider.useCache = true;
   *
   * // Create a new ProgramManager with the key that will be used to bond credits
   * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, undefined);
   * programManager.setAccount(new Account("YourPrivateKey"));
   *
   * // Create the bonding transaction
   * const tx_id = await programManager.bondValidator("aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px", "aleo1feya8sjy9k2zflvl2dx39pdsq5tju28elnp2ektnn588uu9ghv8s84msv9", 2000000);
   *
   * // Verify the transaction was successful
   * setTimeout(async () => {
   *  const transaction = await programManager.networkClient.getTransaction(tx_id);
   *  assert(transaction.id() === tx_id);
   * }, 10000);
   */
  async bondValidator(validator_address, withdrawal_address, amount, commission, options = {}) {
    var _a;
    const tx = await this.buildBondValidatorTransaction(validator_address, withdrawal_address, amount, commission, options);
    let feeAddress;
    if (typeof options.privateKey !== "undefined") {
      feeAddress = Address.from_private_key(options.privateKey);
    } else if (this.account !== void 0) {
      feeAddress = (_a = this.account) == null ? void 0 : _a.address();
    } else {
      throw Error("No private key provided and no private key set in the ProgramManager. Please set an account or provide a private key.");
    }
    await this.checkFee(feeAddress.to_string(), tx.feeAmount());
    return await this.networkClient.submitTransaction(tx);
  }
  /**
   * Build an unbond_public execution transaction to unbond credits from a validator in the Aleo network.
   *
   * @param {string} staker_address - The address of the staker who is unbonding the credits.
   * @param {number} amount - The amount of credits to unbond (scaled by 1,000,000).
   * @param {Partial<ExecuteOptions>} options - Override default execution options.
   * @returns {Promise<Transaction>} - A promise that resolves to the transaction or an error message.
   *
   * @example
   * // Import the mainnet version of the sdk.
   * import { AleoKeyProvider, ProgramManager } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a keyProvider to handle key management.
   * const keyProvider = new AleoKeyProvider();
   * keyProvider.useCache = true;
   *
   * // Create a new ProgramManager with the key that will be used to unbond credits.
   * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, undefined);
   * const tx = await programManager.buildUnbondPublicTransaction("aleo1jx8s4dvjepculny4wfrzwyhs3tlyv65r58ns3g6q2gm2esh7ps8sqy9s5j", 2000000);
   *
   * // The transaction can be submitted later to the network using the network client.
   * programManager.networkClient.submitTransaction(tx.toString());
   *
   * // Verify the transaction was successful
   * setTimeout(async () => {
   *  const transaction = await programManager.networkClient.getTransaction(tx.id());
   *  assert(transaction.id() === tx.id());
   * }, 10000);
   */
  async buildUnbondPublicTransaction(staker_address, amount, options = {}) {
    const scaledAmount = Math.trunc(amount * 1e6);
    const { programName = "credits.aleo", functionName = "unbond_public", priorityFee = options.priorityFee || 0, privateFee = false, inputs = [staker_address, `${scaledAmount.toString()}u64`], keySearchParams = new AleoKeyProviderParams({
      proverUri: CREDITS_PROGRAM_KEYS.unbond_public.prover,
      verifierUri: CREDITS_PROGRAM_KEYS.unbond_public.verifier,
      cacheKey: "credits.aleo/unbond_public"
    }), program = this.creditsProgram(), ...additionalOptions } = options;
    const executeOptions = {
      programName,
      functionName,
      priorityFee,
      privateFee,
      inputs,
      keySearchParams,
      ...additionalOptions
    };
    return this.buildExecutionTransaction(executeOptions);
  }
  /**
   * Unbond a specified amount of staked credits. If the address of the executor of this function is an existing
   * validator, it will subtract this amount of credits from the validator's staked credits. If there are less than
   * 1,000,000 credits staked pool after the unbond, the validator will be removed from the validator set. If the
   * address of the executor of this function is not a validator and has credits bonded as a delegator, it will
   * subtract this amount of credits from the delegator's staked credits. If there are less than 10 credits bonded
   * after the unbond operation, the delegator will be removed from the validator's staking pool.
   *
   * @param {string} staker_address Address of the staker who is unbonding the credits
   * @param {number} amount Amount of credits to unbond.
   * @param {ExecuteOptions} options Options for the execution
   * @returns {Promise<string>} The transaction id
   *
   * @example
   * // Import the mainnet version of the sdk.
   * import { AleoKeyProvider, ProgramManager } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a keyProvider to handle key management
   * const keyProvider = new AleoKeyProvider();
   * keyProvider.useCache = true;
   *
   * // Create a new ProgramManager with the key that will be used to bond credits
   * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, undefined);
   * programManager.setAccount(new Account("YourPrivateKey"));
   *
   * // Create the unbond_public transaction and send it to the network
   * const tx_id = await programManager.unbondPublic("aleo1jx8s4dvjepculny4wfrzwyhs3tlyv65r58ns3g6q2gm2esh7ps8sqy9s5j", 10);
   *
   * // Verify the transaction was successful
   * setTimeout(async () => {
   *  const transaction = await programManager.networkClient.getTransaction(tx_id);
   *  assert(transaction.id() === tx_id);
   * }, 10000);
   */
  async unbondPublic(staker_address, amount, options = {}) {
    var _a;
    const tx = await this.buildUnbondPublicTransaction(staker_address, amount, options);
    let feeAddress;
    if (typeof options.privateKey !== "undefined") {
      feeAddress = Address.from_private_key(options.privateKey);
    } else if (this.account !== void 0) {
      feeAddress = (_a = this.account) == null ? void 0 : _a.address();
    } else {
      throw Error("No private key provided and no private key set in the ProgramManager. Please set an account or provide a private key.");
    }
    await this.checkFee(feeAddress.to_string(), tx.feeAmount());
    return await this.networkClient.submitTransaction(tx);
  }
  /**
   * Build a transaction to claim unbonded public credits in the Aleo network.
   *
   * @param {string} staker_address - The address of the staker who is claiming the credits.
   * @param {Partial<ExecuteOptions>} options - Override default execution options.
   * @returns {Promise<Transaction>} - A promise that resolves to the transaction or an error message.
   *
   * @example
   * // Import the mainnet version of the sdk.
   * import { AleoKeyProvider, ProgramManager } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a keyProvider to handle key management
   * const keyProvider = new AleoKeyProvider();
   * keyProvider.useCache = true;
   *
   * // Create a new ProgramManager with the key that will be used to claim unbonded credits.
   * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, undefined);
   *
   * // Create the claim_unbond_public transaction object for later use.
   * const tx = await programManager.buildClaimUnbondPublicTransaction("aleo1jx8s4dvjepculny4wfrzwyhs3tlyv65r58ns3g6q2gm2esh7ps8sqy9s5j");
   *
   * // The transaction can be submitted later to the network using the network client.
   * programManager.networkClient.submitTransaction(tx.toString());
   *
   * // Verify the transaction was successful
   * setTimeout(async () => {
   *  const transaction = await programManager.networkClient.getTransaction(tx.id());
   *  assert(transaction.id() === tx.id());
   * }, 10000);
   */
  async buildClaimUnbondPublicTransaction(staker_address, options = {}) {
    const { programName = "credits.aleo", functionName = "claim_unbond_public", priorityFee = options.priorityFee || 0, privateFee = false, inputs = [staker_address], keySearchParams = new AleoKeyProviderParams({
      proverUri: CREDITS_PROGRAM_KEYS.claim_unbond_public.prover,
      verifierUri: CREDITS_PROGRAM_KEYS.claim_unbond_public.verifier,
      cacheKey: "credits.aleo/claim_unbond_public"
    }), program = this.creditsProgram(), ...additionalOptions } = options;
    const executeOptions = {
      programName,
      functionName,
      priorityFee,
      privateFee,
      inputs,
      keySearchParams,
      ...additionalOptions
    };
    return await this.buildExecutionTransaction(executeOptions);
  }
  /**
   * Claim unbonded credits. If credits have been unbonded by the account executing this function, this method will
   * claim them and add them to the public balance of the account.
   *
   * @param {string} staker_address Address of the staker who is claiming the credits
   * @param {ExecuteOptions} options
   * @returns {Promise<string>} The transaction id
   *
   * @example
   * // Import the mainnet version of the sdk.
   * import { AleoKeyProvider, ProgramManager } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a keyProvider to handle key management
   * const keyProvider = new AleoKeyProvider();
   * keyProvider.useCache = true;
   *
   * // Create a new ProgramManager with the key that will be used to bond credits
   * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, undefined);
   * programManager.setAccount(new Account("YourPrivateKey"));
   *
   * // Create the claim_unbond_public transaction
   * const tx_id = await programManager.claimUnbondPublic("aleo1jx8s4dvjepculny4wfrzwyhs3tlyv65r58ns3g6q2gm2esh7ps8sqy9s5j");
   *
   * // Verify the transaction was successful
   * setTimeout(async () => {
   *  const transaction = await programManager.networkClient.getTransaction(tx_id);
   *  assert(transaction.id() === tx_id);
   * }, 10000);
   */
  async claimUnbondPublic(staker_address, options = {}) {
    var _a;
    const tx = await this.buildClaimUnbondPublicTransaction(staker_address, options);
    let feeAddress;
    if (typeof options.privateKey !== "undefined") {
      feeAddress = Address.from_private_key(options.privateKey);
    } else if (this.account !== void 0) {
      feeAddress = (_a = this.account) == null ? void 0 : _a.address();
    } else {
      throw Error("No private key provided and no private key set in the ProgramManager. Please set an account or provide a private key.");
    }
    await this.checkFee(feeAddress.to_string(), tx.feeAmount());
    return await this.networkClient.submitTransaction(tx);
  }
  /**
   * Build a set_validator_state transaction for later usage.
   *
   * This function allows a validator to set their state to be either opened or closed to new stakers.
   * When the validator is open to new stakers, any staker (including the validator) can bond or unbond from the validator.
   * When the validator is closed to new stakers, existing stakers can still bond or unbond from the validator, but new stakers cannot bond.
   *
   * This function serves two primary purposes:
   * 1. Allow a validator to leave the committee, by closing themselves to stakers and then unbonding all of their stakers.
   * 2. Allow a validator to maintain their % of stake, by closing themselves to allowing more stakers to bond to them.
   *
   * @param {boolean} validator_state
   * @param {Partial<ExecuteOptions>} options - Override default execution options
   * @returns {Promise<Transaction>} The transaction object
   *
   * @example
   * // Import the mainnet version of the sdk.
   * import { AleoKeyProvider, ProgramManager } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a keyProvider to handle key management
   * const keyProvider = new AleoKeyProvider();
   * keyProvider.useCache = true;
   *
   * // Create a new ProgramManager with the key that will be used to bond credits
   * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, undefined);
   *
   * // Create the set_validator_state transaction
   * const tx = await programManager.buildSetValidatorStateTransaction(true);
   *
   * // The transaction can be submitted later to the network using the network client.
   * programManager.networkClient.submitTransaction(tx.toString());
   *
   * // Verify the transaction was successful
   * setTimeout(async () => {
   *  const transaction = await programManager.networkClient.getTransaction(tx.id());
   *  assert(transaction.id() === tx.id());
   * }, 10000);
   */
  async buildSetValidatorStateTransaction(validator_state, options = {}) {
    const { programName = "credits.aleo", functionName = "set_validator_state", priorityFee = 0, privateFee = false, inputs = [validator_state.toString()], keySearchParams = new AleoKeyProviderParams({
      proverUri: CREDITS_PROGRAM_KEYS.set_validator_state.prover,
      verifierUri: CREDITS_PROGRAM_KEYS.set_validator_state.verifier,
      cacheKey: "credits.aleo/set_validator_state"
    }), ...additionalOptions } = options;
    const executeOptions = {
      programName,
      functionName,
      priorityFee,
      privateFee,
      inputs,
      keySearchParams,
      ...additionalOptions
    };
    return await this.buildExecutionTransaction(executeOptions);
  }
  /**
   * Submit a set_validator_state transaction to the Aleo Network.
   *
   * This function allows a validator to set their state to be either opened or closed to new stakers.
   * When the validator is open to new stakers, any staker (including the validator) can bond or unbond from the validator.
   * When the validator is closed to new stakers, existing stakers can still bond or unbond from the validator, but new stakers cannot bond.
   *
   * This function serves two primary purposes:
   * 1. Allow a validator to leave the committee, by closing themselves to stakers and then unbonding all of their stakers.
   * 2. Allow a validator to maintain their % of stake, by closing themselves to allowing more stakers to bond to them.
   *
   * @param {boolean} validator_state
   * @param {Partial<ExecuteOptions>} options - Override default execution options
   * @returns {Promise<string>} The transaction id
   *
   * @example
   * // Import the mainnet version of the sdk.
   * import { AleoKeyProvider, ProgramManager } from "@provablehq/sdk/mainnet.js";
   *
   * // Create a keyProvider to handle key management
   * const keyProvider = new AleoKeyProvider();
   * keyProvider.useCache = true;
   *
   * // Create a new ProgramManager with the key that will be used to bond credits
   * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, undefined);
   *
   * // Create the set_validator_state transaction
   * const tx_id = await programManager.setValidatorState(true);
   *
   * // Verify the transaction was successful
   * setTimeout(async () => {
   *  const transaction = await programManager.networkClient.getTransaction(tx_id);
   *  assert(transaction.id() === tx_id);
   * }, 10000);
   */
  async setValidatorState(validator_state, options = {}) {
    var _a;
    const tx = await this.buildSetValidatorStateTransaction(validator_state, options);
    let feeAddress;
    if (typeof options.privateKey !== "undefined") {
      feeAddress = Address.from_private_key(options.privateKey);
    } else if (this.account !== void 0) {
      feeAddress = (_a = this.account) == null ? void 0 : _a.address();
    } else {
      throw Error("No private key provided and no private key set in the ProgramManager. Please set an account or provide a private key.");
    }
    await this.checkFee(feeAddress.to_string(), tx.feeAmount());
    return this.networkClient.submitTransaction(tx);
  }
  /**
   * Verify a proof of execution from an offline execution
   *
   * @param {executionResponse} executionResponse
   * @returns {boolean} True if the proof is valid, false otherwise
   */
  verifyExecution(executionResponse) {
    try {
      const execution = executionResponse.getExecution();
      const function_id = executionResponse.getFunctionId();
      const program = executionResponse.getProgram();
      const verifyingKey = executionResponse.getVerifyingKey();
      return verifyFunctionExecution(execution, verifyingKey, program, function_id);
    } catch (e) {
      console.warn("The execution was not found in the response, cannot verify the execution");
      return false;
    }
  }
  /**
   * Create a program object from a program's source code
   *
   * @param {string} program Program source code
   * @returns {Program} The program object
   */
  createProgramFromSource(program) {
    return Program.fromString(program);
  }
  /**
   * Get the credits program object
   *
   * @returns {Program} The credits program object
   */
  creditsProgram() {
    return Program.getCreditsProgram();
  }
  /**
   * Verify a program is valid
   *
   * @param {string} program The program source code
   */
  verifyProgram(program) {
    try {
      Program.fromString(program);
      return true;
    } catch (e) {
      return false;
    }
  }
  // Internal utility function for getting a credits.aleo record
  async getCreditsRecord(amount, nonces, record, params) {
    try {
      return record instanceof RecordPlaintext ? record : RecordPlaintext.fromString(record);
    } catch (e) {
      try {
        const recordProvider = this.recordProvider;
        return await recordProvider.findCreditsRecord(amount, true, nonces, params);
      } catch (e2) {
        logAndThrow(`Error finding fee record. Record finder response: '${e2.message}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`);
      }
    }
  }
};
function requiresAmountRecord(transferType) {
  return PRIVATE_TRANSFER_TYPES.has(transferType);
}
function validateTransferType(transferType) {
  return VALID_TRANSFER_TYPES.has(transferType) ? transferType : logAndThrow(`Invalid transfer type '${transferType}'. Valid transfer types are 'private', 'privateToPublic', 'public', and 'publicToPrivate'.`);
}

// ../node_modules/@provablehq/sdk/dist/testnet/browser.js
var Account = class _Account {
  constructor(params = {}) {
    __publicField(this, "_privateKey");
    __publicField(this, "_viewKey");
    __publicField(this, "_computeKey");
    __publicField(this, "_address");
    try {
      this._privateKey = this.privateKeyFromParams(params);
    } catch (e) {
      console.error("Wrong parameter", e);
      throw new Error("Wrong Parameter");
    }
    this._viewKey = ViewKey.from_private_key(this._privateKey);
    this._computeKey = ComputeKey.from_private_key(this._privateKey);
    this._address = Address2.from_private_key(this._privateKey);
  }
  /**
   * Attempts to create an account from a private key ciphertext
   * @param {PrivateKeyCiphertext | string} ciphertext The encrypted private key ciphertext or its string representation
   * @param {string} password The password used to decrypt the private key ciphertext
   * @returns {Account} A new Account instance created from the decrypted private key
   *
   * @example
   * import { Account } from "@provablehq/sdk/testnet.js";
   *
   * // Create an account object from a previously encrypted ciphertext and password.
   * const account = Account.fromCiphertext(process.env.ciphertext, process.env.password);
   */
  static fromCiphertext(ciphertext, password) {
    try {
      ciphertext = typeof ciphertext === "string" ? PrivateKeyCiphertext.fromString(ciphertext) : ciphertext;
      const _privateKey = PrivateKey2.fromPrivateKeyCiphertext(ciphertext, password);
      return new _Account({ privateKey: _privateKey.to_string() });
    } catch (e) {
      throw new Error("Wrong password or invalid ciphertext");
    }
  }
  /**
   * Creates a PrivateKey from the provided parameters.
   * @param {AccountParam} params The parameters containing either a private key string or a seed
   * @returns {PrivateKey} A PrivateKey instance derived from the provided parameters
   */
  privateKeyFromParams(params) {
    if (params.seed) {
      return PrivateKey2.from_seed_unchecked(params.seed);
    }
    if (params.privateKey) {
      return PrivateKey2.from_string(params.privateKey);
    }
    return new PrivateKey2();
  }
  /**
   * Returns the PrivateKey associated with the account.
   * @returns {PrivateKey} The private key of the account
   *
   * @example
   * import { Account } from "@provablehq/sdk/testnet.js";
   *
   * const account = new Account();
   * const privateKey = account.privateKey();
   */
  privateKey() {
    return this._privateKey;
  }
  /**
   * Returns the ViewKey associated with the account.
   * @returns {ViewKey} The view key of the account
   *
   * @example
   * import { Account } from "@provablehq/sdk/testnet.js";
   *
   * const account = new Account();
   * const viewKey = account.viewKey();
   */
  viewKey() {
    return this._viewKey;
  }
  /**
   * Returns the ComputeKey associated with the account.
   * @returns {ComputeKey} The compute key of the account
   *
   * @example
   * import { Account } from "@provablehq/sdk/testnet.js";
   *
   * const account = new Account();
   * const computeKey = account.computeKey();
   */
  computeKey() {
    return this._computeKey;
  }
  /**
   * Returns the Aleo address associated with the account.
   * @returns {Address} The public address of the account
   *
   * @example
   * import { Account } from "@provablehq/sdk/testnet.js";
   *
   * const account = new Account();
   * const address = account.address();
   */
  address() {
    return this._address;
  }
  /**
   * Deep clones the Account.
   * @returns {Account} A new Account instance with the same private key
   *
   * @example
   * import { Account } from "@provablehq/sdk/testnet.js";
   *
   * const account = new Account();
   * const clonedAccount = account.clone();
   */
  clone() {
    return new _Account({ privateKey: this._privateKey.to_string() });
  }
  /**
   * Returns the address of the account in a string representation.
   *
   * @returns {string} The string representation of the account address
   */
  toString() {
    return this.address().to_string();
  }
  /**
   * Encrypts the account's private key with a password.
   *
   * @param {string} password Password to encrypt the private key.
   * @returns {PrivateKeyCiphertext} The encrypted private key ciphertext
   *
   * @example
   * import { Account } from "@provablehq/sdk/testnet.js";
   *
   * const account = new Account();
   * const ciphertext = account.encryptAccount("password");
   * process.env.ciphertext = ciphertext.toString();
   */
  encryptAccount(password) {
    return this._privateKey.toCiphertext(password);
  }
  /**
   * Decrypts an encrypted record string into a plaintext record object.
   *
   * @param {string} ciphertext A string representing the ciphertext of a record.
   * @returns {RecordPlaintext} The decrypted record plaintext
   *
   * @example
   * // Import the AleoNetworkClient and Account classes
   * import { AleoNetworkClient, Account } from "@provablehq/sdk/testnet.js";
   *
   * // Create a connection to the Aleo network and an account
   * const networkClient = new AleoNetworkClient("https://api.explorer.provable.com/v1");
   * const account = Account.fromCiphertext(process.env.ciphertext!, process.env.password!);
   *
   * // Get the record ciphertexts from a transaction.
   * const transaction = await networkClient.getTransactionObject("at1fjy6s9md2v4rgcn3j3q4qndtfaa2zvg58a4uha0rujvrn4cumu9qfazxdd");
   * const records = transaction.records();
   *
   * // Decrypt any records the account owns.
   * const decryptedRecords = [];
   * for (const record of records) {
   *    if (account.decryptRecord(record)) {
   *      decryptedRecords.push(record);
   *    }
   * }
   */
  decryptRecord(ciphertext) {
    return this._viewKey.decrypt(ciphertext);
  }
  /**
   * Decrypts an array of Record ciphertext strings into an array of record plaintext objects.
   *
   * @param {string[]} ciphertexts An array of strings representing the ciphertexts of records.
   * @returns {RecordPlaintext[]} An array of decrypted record plaintexts
   *
   * @example
   * // Import the AleoNetworkClient and Account classes
   * import { AleoNetworkClient, Account } from "@provablehq/sdk/testnet.js";
   *
   * // Create a connection to the Aleo network and an account
   * const networkClient = new AleoNetworkClient("https://api.explorer.provable.com/v1");
   * const account = Account.fromCiphertext(process.env.ciphertext!, process.env.password!);
   *
   * // Get the record ciphertexts from a transaction.
   * const transaction = await networkClient.getTransactionObject("at1fjy6s9md2v4rgcn3j3q4qndtfaa2zvg58a4uha0rujvrn4cumu9qfazxdd");
   * const records = transaction.records();
   *
   * // Decrypt any records the account owns. If the account owns no records, the array will be empty.
   * const decryptedRecords = account.decryptRecords(records);
   */
  decryptRecords(ciphertexts) {
    return ciphertexts.map((ciphertext) => this._viewKey.decrypt(ciphertext));
  }
  /**
   * Determines whether the account owns a ciphertext record.
   * @param {RecordCiphertext | string} ciphertext The record ciphertext to check ownership of
   * @returns {boolean} True if the account owns the record, false otherwise
   *
   * @example
   * // Import the AleoNetworkClient and Account classes
   * import { AleoNetworkClient, Account } from "@provablehq/sdk/testnet.js";
   *
   * // Create a connection to the Aleo network and an account
   * const networkClient = new AleoNetworkClient("https://api.explorer.provable.com/v1");
   * const account = Account.fromCiphertext(process.env.ciphertext!, process.env.password!);
   *
   * // Get the record ciphertexts from a transaction and check ownership of them.
   * const transaction = await networkClient.getTransactionObject("at1fjy6s9md2v4rgcn3j3q4qndtfaa2zvg58a4uha0rujvrn4cumu9qfazxdd");
   * const records = transaction.records();
   *
   * // Check if the account owns any of the record ciphertexts present in the transaction.
   * const ownedRecords = [];
   * for (const record of records) {
   *    if (account.ownsRecordCiphertext(record)) {
   *      ownedRecords.push(record);
   *    }
   * }
   */
  ownsRecordCiphertext(ciphertext) {
    if (typeof ciphertext === "string") {
      try {
        const ciphertextObject = RecordCiphertext2.fromString(ciphertext);
        return ciphertextObject.isOwner(this._viewKey);
      } catch (e) {
        return false;
      }
    } else {
      return ciphertext.isOwner(this._viewKey);
    }
  }
  /**
   * Signs a message with the account's private key.
   * Returns a Signature.
   *
   * @param {Uint8Array} message Message to be signed.
   * @returns {Signature} Signature over the message in bytes.
   *
   * @example
   * // Import the Account class
   * import { Account } from "@provablehq/sdk/testnet.js";
   *
   * // Create a connection to the Aleo network and an account
   * const account = Account.fromCiphertext(process.env.ciphertext, process.env.password);
   *
   * // Create an account and a message to sign.
   * const account = new Account();
   * const message = Uint8Array.from([104, 101, 108, 108, 111 119, 111, 114, 108, 100])
   * const signature = account.sign(message);
   *
   * // Verify the signature.
   * assert(account.verify(message, signature));
   */
  sign(message) {
    return this._privateKey.sign(message);
  }
  /**
   * Verifies the Signature on a message.
   *
   * @param {Uint8Array} message Message in bytes to be signed.
   * @param {Signature} signature Signature to be verified.
   * @returns {boolean} True if the signature is valid, false otherwise.
   *
   * @example
   * // Import the Account class
   * import { Account } from "@provablehq/sdk/testnet.js";
   *
   * // Create a connection to the Aleo network and an account
   * const account = Account.fromCiphertext(process.env.ciphertext, process.env.password);
   *
   * // Sign a message.
   * const message = Uint8Array.from([104, 101, 108, 108, 111 119, 111, 114, 108, 100])
   * const signature = account.sign(message);
   *
   * // Verify the signature.
   * assert(account.verify(message, signature));
   */
  verify(message, signature) {
    return this._address.verify(message, signature);
  }
};
var OfflineSearchParams = class _OfflineSearchParams {
  /**
   * Create a new OfflineSearchParams instance.
   *
   * @param {string} cacheKey - Key used to store the local function proving & verifying keys. This should be stored
   * under the naming convention "programName/functionName" (i.e. "myprogram.aleo/myfunction")
   * @param {boolean} verifyCreditsKeys - Whether to verify the keys against the credits.aleo program,
   * defaults to false, but should be set to true if using keys from the credits.aleo program
   */
  constructor(cacheKey, verifyCreditsKeys = false) {
    __publicField(this, "cacheKey");
    __publicField(this, "verifyCreditsKeys");
    this.cacheKey = cacheKey;
    this.verifyCreditsKeys = verifyCreditsKeys;
  }
  /**
   * Create a new OfflineSearchParams instance for the bond_public function of the credits.aleo program.
   */
  static bondPublicKeyParams() {
    return new _OfflineSearchParams(CREDITS_PROGRAM_KEYS.bond_public.locator, true);
  }
  /**
   * Create a new OfflineSearchParams instance for the bond_validator function of the credits.aleo program.
   */
  static bondValidatorKeyParams() {
    return new _OfflineSearchParams(CREDITS_PROGRAM_KEYS.bond_validator.locator, true);
  }
  /**
   * Create a new OfflineSearchParams instance for the claim_unbond_public function of the
   */
  static claimUnbondPublicKeyParams() {
    return new _OfflineSearchParams(CREDITS_PROGRAM_KEYS.claim_unbond_public.locator, true);
  }
  /**
   * Create a new OfflineSearchParams instance for the fee_private function of the credits.aleo program.
   */
  static feePrivateKeyParams() {
    return new _OfflineSearchParams(CREDITS_PROGRAM_KEYS.fee_private.locator, true);
  }
  /**
   * Create a new OfflineSearchParams instance for the fee_public function of the credits.aleo program.
   */
  static feePublicKeyParams() {
    return new _OfflineSearchParams(CREDITS_PROGRAM_KEYS.fee_public.locator, true);
  }
  /**
   * Create a new OfflineSearchParams instance for the inclusion prover function.
   */
  static inclusionKeyParams() {
    return new _OfflineSearchParams(CREDITS_PROGRAM_KEYS.inclusion.locator, true);
  }
  /**
   * Create a new OfflineSearchParams instance for the join function of the credits.aleo program.
   */
  static joinKeyParams() {
    return new _OfflineSearchParams(CREDITS_PROGRAM_KEYS.join.locator, true);
  }
  /**
   * Create a new OfflineSearchParams instance for the set_validator_state function of the credits.aleo program.
   */
  static setValidatorStateKeyParams() {
    return new _OfflineSearchParams(CREDITS_PROGRAM_KEYS.set_validator_state.locator, true);
  }
  /**
   * Create a new OfflineSearchParams instance for the split function of the credits.aleo program.
   */
  static splitKeyParams() {
    return new _OfflineSearchParams(CREDITS_PROGRAM_KEYS.split.locator, true);
  }
  /**
   * Create a new OfflineSearchParams instance for the transfer_private function of the credits.aleo program.
   */
  static transferPrivateKeyParams() {
    return new _OfflineSearchParams(CREDITS_PROGRAM_KEYS.transfer_private.locator, true);
  }
  /**
   * Create a new OfflineSearchParams instance for the transfer_private_to_public function of the credits.aleo program.
   */
  static transferPrivateToPublicKeyParams() {
    return new _OfflineSearchParams(CREDITS_PROGRAM_KEYS.transfer_private_to_public.locator, true);
  }
  /**
   * Create a new OfflineSearchParams instance for the transfer_public function of the credits.aleo program.
   */
  static transferPublicKeyParams() {
    return new _OfflineSearchParams(CREDITS_PROGRAM_KEYS.transfer_public.locator, true);
  }
  /**
   * Create a new OfflineSearchParams instance for the transfer_public_as_signer function of the credits.aleo program.
   */
  static transferPublicAsSignerKeyParams() {
    return new _OfflineSearchParams(CREDITS_PROGRAM_KEYS.transfer_public_as_signer.locator, true);
  }
  /**
   * Create a new OfflineSearchParams instance for the transfer_public_to_private function of the credits.aleo program.
   */
  static transferPublicToPrivateKeyParams() {
    return new _OfflineSearchParams(CREDITS_PROGRAM_KEYS.transfer_public_to_private.locator, true);
  }
  /**
   * Create a new OfflineSearchParams instance for the unbond_public function of the credits.aleo program.
   */
  static unbondPublicKeyParams() {
    return new _OfflineSearchParams(CREDITS_PROGRAM_KEYS.unbond_public.locator, true);
  }
};
var OfflineKeyProvider = class {
  constructor() {
    __publicField(this, "cache");
    this.cache = /* @__PURE__ */ new Map();
  }
  /**
   * Get bond_public function keys from the credits.aleo program. The keys must be cached prior to calling this
   * method for it to work.
   *
   * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the bond_public function
   */
  bondPublicKeys() {
    return this.functionKeys(OfflineSearchParams.bondPublicKeyParams());
  }
  /**
   * Get bond_validator function keys from the credits.aleo program. The keys must be cached prior to calling this
   * method for it to work.
   *
   * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the bond_public function
   */
  bondValidatorKeys() {
    return this.functionKeys(OfflineSearchParams.bondValidatorKeyParams());
  }
  /**
   * Cache a set of keys. This will overwrite any existing keys with the same keyId. The user can check if a keyId
   * exists in the cache using the containsKeys method prior to calling this method if overwriting is not desired.
   *
   * @param {string} keyId access key for the cache
   * @param {FunctionKeyPair} keys keys to cache
   */
  cacheKeys(keyId, keys) {
    const [provingKey, verifyingKey] = keys;
    this.cache.set(keyId, [provingKey.toBytes(), verifyingKey.toBytes()]);
  }
  /**
   * Get unbond_public function keys from the credits.aleo program. The keys must be cached prior to calling this
   * method for it to work.
   *
   * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the unbond_public function
   */
  claimUnbondPublicKeys() {
    return this.functionKeys(OfflineSearchParams.claimUnbondPublicKeyParams());
  }
  /**
   * Get arbitrary function key from the offline key provider cache.
   *
   * @param {KeySearchParams | undefined} params - Optional search parameters for the key provider
   * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the specified program
   *
   * @example
   * /// First cache the keys from local offline resources
   * const offlineKeyProvider = new OfflineKeyProvider();
   * const myFunctionVerifyingKey = VerifyingKey.fromString("verifier...");
   * const myFunctionProvingKeyBytes = await readBinaryFile('./resources/myfunction.prover');
   * const myFunctionProvingKey = ProvingKey.fromBytes(myFunctionProvingKeyBytes);
   *
   * /// Cache the keys for future use with a memorable locator
   * offlineKeyProvider.cacheKeys("myprogram.aleo/myfunction", [myFunctionProvingKey, myFunctionVerifyingKey]);
   *
   * /// When they're needed, retrieve the keys from the cache
   *
   * /// First create a search parameter object with the same locator used to cache the keys
   * const keyParams = new OfflineSearchParams("myprogram.aleo/myfunction");
   *
   * /// Then retrieve the keys
   * const [myFunctionProver, myFunctionVerifier] = await offlineKeyProvider.functionKeys(keyParams);
   */
  functionKeys(params) {
    return new Promise((resolve, reject) => {
      if (params === void 0) {
        reject(new Error("No search parameters provided, cannot retrieve keys"));
      } else {
        const keyId = params.cacheKey;
        const verifyCreditsKeys = params.verifyCreditsKeys;
        if (this.cache.has(keyId)) {
          const [provingKeyBytes, verifyingKeyBytes] = this.cache.get(keyId);
          const provingKey = ProvingKey2.fromBytes(provingKeyBytes);
          const verifyingKey = VerifyingKey2.fromBytes(verifyingKeyBytes);
          if (verifyCreditsKeys) {
            const keysMatchExpected = this.verifyCreditsKeys(keyId, provingKey, verifyingKey);
            if (!keysMatchExpected) {
              reject(new Error(`Cached keys do not match expected keys for ${keyId}`));
            }
          }
          resolve([provingKey, verifyingKey]);
        } else {
          reject(new Error("Keys not found in cache for " + keyId));
        }
      }
    });
  }
  /**
   * Determines if the keys for a given credits function match the expected keys.
   *
   * @returns {boolean} Whether the keys match the expected keys
   */
  verifyCreditsKeys(locator, provingKey, verifyingKey) {
    switch (locator) {
      case CREDITS_PROGRAM_KEYS.bond_public.locator:
        return provingKey.isBondPublicProver() && verifyingKey.isBondPublicVerifier();
      case CREDITS_PROGRAM_KEYS.claim_unbond_public.locator:
        return provingKey.isClaimUnbondPublicProver() && verifyingKey.isClaimUnbondPublicVerifier();
      case CREDITS_PROGRAM_KEYS.fee_private.locator:
        return provingKey.isFeePrivateProver() && verifyingKey.isFeePrivateVerifier();
      case CREDITS_PROGRAM_KEYS.fee_public.locator:
        return provingKey.isFeePublicProver() && verifyingKey.isFeePublicVerifier();
      case CREDITS_PROGRAM_KEYS.inclusion.locator:
        return provingKey.isInclusionProver() && verifyingKey.isInclusionVerifier();
      case CREDITS_PROGRAM_KEYS.join.locator:
        return provingKey.isJoinProver() && verifyingKey.isJoinVerifier();
      case CREDITS_PROGRAM_KEYS.set_validator_state.locator:
        return provingKey.isSetValidatorStateProver() && verifyingKey.isSetValidatorStateVerifier();
      case CREDITS_PROGRAM_KEYS.split.locator:
        return provingKey.isSplitProver() && verifyingKey.isSplitVerifier();
      case CREDITS_PROGRAM_KEYS.transfer_private.locator:
        return provingKey.isTransferPrivateProver() && verifyingKey.isTransferPrivateVerifier();
      case CREDITS_PROGRAM_KEYS.transfer_private_to_public.locator:
        return provingKey.isTransferPrivateToPublicProver() && verifyingKey.isTransferPrivateToPublicVerifier();
      case CREDITS_PROGRAM_KEYS.transfer_public.locator:
        return provingKey.isTransferPublicProver() && verifyingKey.isTransferPublicVerifier();
      case CREDITS_PROGRAM_KEYS.transfer_public_to_private.locator:
        return provingKey.isTransferPublicToPrivateProver() && verifyingKey.isTransferPublicToPrivateVerifier();
      case CREDITS_PROGRAM_KEYS.unbond_public.locator:
        return provingKey.isUnbondPublicProver() && verifyingKey.isUnbondPublicVerifier();
      default:
        return false;
    }
  }
  /**
   * Get fee_private function keys from the credits.aleo program. The keys must be cached prior to calling this
   * method for it to work.
   *
   * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function
   */
  feePrivateKeys() {
    return this.functionKeys(OfflineSearchParams.feePrivateKeyParams());
  }
  /**
   * Get fee_public function keys from the credits.aleo program. The keys must be cached prior to calling this
   * method for it to work.
   *
   * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function
   */
  feePublicKeys() {
    return this.functionKeys(OfflineSearchParams.feePublicKeyParams());
  }
  /**
   * Get join function keys from the credits.aleo program. The keys must be cached prior to calling this
   * method for it to work.
   *
   * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function
   */
  joinKeys() {
    return this.functionKeys(OfflineSearchParams.joinKeyParams());
  }
  /**
   * Get split function keys from the credits.aleo program. The keys must be cached prior to calling this
   * method for it to work.
   *
   * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function
   */
  splitKeys() {
    return this.functionKeys(OfflineSearchParams.splitKeyParams());
  }
  /**
   * Get keys for a variant of the transfer function from the credits.aleo program.
   *
   *
   * @param {string} visibility Visibility of the transfer function (private, public, privateToPublic, publicToPrivate)
   * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the specified transfer function
   *
   * @example
   * // Create a new OfflineKeyProvider
   * const offlineKeyProvider = new OfflineKeyProvider();
   *
   * // Cache the keys for future use with the official locator
   * const transferPublicProvingKeyBytes = await readBinaryFile('./resources/transfer_public.prover.a74565e');
   * const transferPublicProvingKey = ProvingKey.fromBytes(transferPublicProvingKeyBytes);
   *
   * // Cache the transfer_public keys for future use with the OfflinKeyProvider's convenience method for
   * // transfer_public (the verifying key will be cached automatically)
   * offlineKeyProvider.insertTransferPublicKeys(transferPublicProvingKey);
   *
   * /// When they're needed, retrieve the keys from the cache
   * const [transferPublicProvingKey, transferPublicVerifyingKey] = await keyProvider.transferKeys("public");
   */
  transferKeys(visibility) {
    if (PRIVATE_TRANSFER.has(visibility)) {
      return this.functionKeys(OfflineSearchParams.transferPrivateKeyParams());
    } else if (PRIVATE_TO_PUBLIC_TRANSFER.has(visibility)) {
      return this.functionKeys(OfflineSearchParams.transferPrivateToPublicKeyParams());
    } else if (PUBLIC_TRANSFER.has(visibility)) {
      return this.functionKeys(OfflineSearchParams.transferPublicKeyParams());
    } else if (PUBLIC_TRANSFER_AS_SIGNER.has(visibility)) {
      return this.functionKeys(OfflineSearchParams.transferPublicAsSignerKeyParams());
    } else if (PUBLIC_TO_PRIVATE_TRANSFER.has(visibility)) {
      return this.functionKeys(OfflineSearchParams.transferPublicToPrivateKeyParams());
    } else {
      throw new Error("Invalid visibility type");
    }
  }
  /**
   * Get unbond_public function keys from the credits.aleo program
   *
   * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function
   */
  async unBondPublicKeys() {
    return this.functionKeys(OfflineSearchParams.unbondPublicKeyParams());
  }
  /**
   * Insert the proving and verifying keys for the bond_public function into the cache. Only the proving key needs
   * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check
   * that the keys match the expected checksum for bond_public before inserting them into the cache.
   *
   * @param provingKey
   */
  insertBondPublicKeys(provingKey) {
    if (provingKey.isBondPublicProver()) {
      this.cache.set(CREDITS_PROGRAM_KEYS.bond_public.locator, [provingKey.toBytes(), VerifyingKey2.bondPublicVerifier().toBytes()]);
    } else {
      throw new Error("Attempted to insert invalid proving keys for bond_public");
    }
  }
  /**
   * Insert the proving and verifying keys for the claim_unbond_public function into the cache. Only the proving key needs
   * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check
   * that the keys match the expected checksum for claim_unbond_public before inserting them into the cache.
   *
   * @param provingKey
   */
  insertClaimUnbondPublicKeys(provingKey) {
    if (provingKey.isClaimUnbondPublicProver()) {
      this.cache.set(CREDITS_PROGRAM_KEYS.claim_unbond_public.locator, [provingKey.toBytes(), VerifyingKey2.claimUnbondPublicVerifier().toBytes()]);
    } else {
      throw new Error("Attempted to insert invalid proving keys for claim_unbond_public");
    }
  }
  /**
   * Insert the proving and verifying keys for the fee_private function into the cache. Only the proving key needs
   * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check
   * that the keys match the expected checksum for fee_private before inserting them into the cache.
   *
   * @param provingKey
   */
  insertFeePrivateKeys(provingKey) {
    if (provingKey.isFeePrivateProver()) {
      this.cache.set(CREDITS_PROGRAM_KEYS.fee_private.locator, [provingKey.toBytes(), VerifyingKey2.feePrivateVerifier().toBytes()]);
    } else {
      throw new Error("Attempted to insert invalid proving keys for fee_private");
    }
  }
  /**
   * Insert the proving and verifying keys for the fee_public function into the cache. Only the proving key needs
   * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check
   * that the keys match the expected checksum for fee_public before inserting them into the cache.
   *
   * @param provingKey
   */
  insertFeePublicKeys(provingKey) {
    if (provingKey.isFeePublicProver()) {
      this.cache.set(CREDITS_PROGRAM_KEYS.fee_public.locator, [provingKey.toBytes(), VerifyingKey2.feePublicVerifier().toBytes()]);
    } else {
      throw new Error("Attempted to insert invalid proving keys for fee_public");
    }
  }
  /**
   * Insert the proving and verifying keys for the join function into the cache. Only the proving key needs
   * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check
   * that the keys match the expected checksum for join before inserting them into the cache.
   *
   * @param provingKey
   */
  insertJoinKeys(provingKey) {
    if (provingKey.isJoinProver()) {
      this.cache.set(CREDITS_PROGRAM_KEYS.join.locator, [provingKey.toBytes(), VerifyingKey2.joinVerifier().toBytes()]);
    } else {
      throw new Error("Attempted to insert invalid proving keys for join");
    }
  }
  /**
   * Insert the proving and verifying keys for the set_validator_state function into the cache. Only the proving key needs
   * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check
   * that the keys match the expected checksum for set_validator_state before inserting them into the cache.
   *
   * @param provingKey
   */
  insertSetValidatorStateKeys(provingKey) {
    if (provingKey.isSetValidatorStateProver()) {
      this.cache.set(CREDITS_PROGRAM_KEYS.set_validator_state.locator, [provingKey.toBytes(), VerifyingKey2.setValidatorStateVerifier().toBytes()]);
    } else {
      throw new Error("Attempted to insert invalid proving keys for set_validator_state");
    }
  }
  /**
   * Insert the proving and verifying keys for the split function into the cache. Only the proving key needs
   * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check
   * that the keys match the expected checksum for split before inserting them into the cache.
   *
   * @param provingKey
   */
  insertSplitKeys(provingKey) {
    if (provingKey.isSplitProver()) {
      this.cache.set(CREDITS_PROGRAM_KEYS.split.locator, [provingKey.toBytes(), VerifyingKey2.splitVerifier().toBytes()]);
    } else {
      throw new Error("Attempted to insert invalid proving keys for split");
    }
  }
  /**
   * Insert the proving and verifying keys for the transfer_private function into the cache. Only the proving key needs
   * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check
   * that the keys match the expected checksum for transfer_private before inserting them into the cache.
   *
   * @param provingKey
   */
  insertTransferPrivateKeys(provingKey) {
    if (provingKey.isTransferPrivateProver()) {
      this.cache.set(CREDITS_PROGRAM_KEYS.transfer_private.locator, [provingKey.toBytes(), VerifyingKey2.transferPrivateVerifier().toBytes()]);
    } else {
      throw new Error("Attempted to insert invalid proving keys for transfer_private");
    }
  }
  /**
   * Insert the proving and verifying keys for the transfer_private_to_public function into the cache. Only the proving key needs
   * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check
   * that the keys match the expected checksum for transfer_private_to_public before inserting them into the cache.
   *
   * @param provingKey
   */
  insertTransferPrivateToPublicKeys(provingKey) {
    if (provingKey.isTransferPrivateToPublicProver()) {
      this.cache.set(CREDITS_PROGRAM_KEYS.transfer_private_to_public.locator, [provingKey.toBytes(), VerifyingKey2.transferPrivateToPublicVerifier().toBytes()]);
    } else {
      throw new Error("Attempted to insert invalid proving keys for transfer_private_to_public");
    }
  }
  /**
   * Insert the proving and verifying keys for the transfer_public function into the cache. Only the proving key needs
   * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check
   * that the keys match the expected checksum for transfer_public before inserting them into the cache.
   *
   * @param provingKey
   */
  insertTransferPublicKeys(provingKey) {
    if (provingKey.isTransferPublicProver()) {
      this.cache.set(CREDITS_PROGRAM_KEYS.transfer_public.locator, [provingKey.toBytes(), VerifyingKey2.transferPublicVerifier().toBytes()]);
    } else {
      throw new Error("Attempted to insert invalid proving keys for transfer_public");
    }
  }
  /**
   * Insert the proving and verifying keys for the transfer_public_to_private function into the cache. Only the proving key needs
   * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check
   * that the keys match the expected checksum for transfer_public_to_private before inserting them into the cache.
   *
   * @param provingKey
   */
  insertTransferPublicToPrivateKeys(provingKey) {
    if (provingKey.isTransferPublicToPrivateProver()) {
      this.cache.set(CREDITS_PROGRAM_KEYS.transfer_public_to_private.locator, [provingKey.toBytes(), VerifyingKey2.transferPublicToPrivateVerifier().toBytes()]);
    } else {
      throw new Error("Attempted to insert invalid proving keys for transfer_public_to_private");
    }
  }
  insertUnbondPublicKeys(provingKey) {
    if (provingKey.isUnbondPublicProver()) {
      this.cache.set(CREDITS_PROGRAM_KEYS.unbond_public.locator, [provingKey.toBytes(), VerifyingKey2.unbondPublicVerifier().toBytes()]);
    } else {
      throw new Error("Attempted to insert invalid proving keys for unbond_public");
    }
  }
};
var NetworkRecordProvider = class {
  constructor(account, networkClient) {
    __publicField(this, "account");
    __publicField(this, "networkClient");
    this.account = account;
    this.networkClient = networkClient;
  }
  /**
   * Set the account used to search for records
   *
   * @param {Account} account The account to use for searching for records
   */
  setAccount(account) {
    this.account = account;
  }
  /**
   * Find a list of credit records with a given number of microcredits by via the official Aleo API
   *
   * @param {number[]} microcredits The number of microcredits to search for
   * @param {boolean} unspent Whether or not the record is unspent
   * @param {string[]} nonces Nonces of records already found so that they are not found again
   * @param {RecordSearchParams} searchParameters Additional parameters to search for
   * @returns {Promise<RecordPlaintext>} The record if found, otherwise an error
   *
   * @example
   * // Create a new NetworkRecordProvider
   * const networkClient = new AleoNetworkClient("https://api.explorer.provable.com/v1");
   * const keyProvider = new AleoKeyProvider();
   * const recordProvider = new NetworkRecordProvider(account, networkClient);
   *
   * // The record provider can be used to find records with a given number of microcredits
   * const record = await recordProvider.findCreditsRecord(5000, true, []);
   *
   * // When a record is found but not yet used, it's nonce should be added to the nonces parameter so that it is not
   * // found again if a subsequent search is performed
   * const records = await recordProvider.findCreditsRecords(5000, true, [record.nonce()]);
   *
   * // When the program manager is initialized with the record provider it will be used to find automatically find
   * // fee records and amount records for value transfers so that they do not need to be specified manually
   * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
   * programManager.transfer(1, "aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at", "public", 0.5);
   *
   * */
  async findCreditsRecords(microcredits, unspent, nonces, searchParameters) {
    let startHeight = 0;
    let endHeight = 0;
    let maxAmount = void 0;
    if (searchParameters) {
      if ("startHeight" in searchParameters && typeof searchParameters["startHeight"] == "number") {
        startHeight = searchParameters["startHeight"];
      }
      if ("endHeight" in searchParameters && typeof searchParameters["endHeight"] == "number") {
        endHeight = searchParameters["endHeight"];
      }
      if ("amounts" in searchParameters && Array.isArray(searchParameters["amounts"]) && searchParameters["amount"].every((item) => typeof item === "number")) {
        microcredits = searchParameters["amounts"];
      }
      if ("maxAmount" in searchParameters && typeof searchParameters["maxAmount"] == "number") {
        maxAmount = searchParameters["maxAmount"];
      }
      if ("unspent" in searchParameters && typeof searchParameters["unspent"] == "boolean") {
        unspent = searchParameters["unspent"];
      }
    }
    if (endHeight == 0) {
      const end = await this.networkClient.getLatestHeight();
      endHeight = end;
    }
    if (startHeight >= endHeight) {
      logAndThrow("Start height must be less than end height");
    }
    return await this.networkClient.findRecords(startHeight, endHeight, unspent, ["credits.aleo"], microcredits, maxAmount, nonces, this.account.privateKey());
  }
  /**
   * Find a credit record with a given number of microcredits by via the official Aleo API
   *
   * @param {number} microcredits The number of microcredits to search for
   * @param {boolean} unspent Whether or not the record is unspent
   * @param {string[]} nonces Nonces of records already found so that they are not found again
   * @param {RecordSearchParams} searchParameters Additional parameters to search for
   * @returns {Promise<RecordPlaintext>} The record if found, otherwise an error
   *
   * @example
   * // Create a new NetworkRecordProvider
   * const networkClient = new AleoNetworkClient("https://api.explorer.provable.com/v1");
   * const keyProvider = new AleoKeyProvider();
   * const recordProvider = new NetworkRecordProvider(account, networkClient);
   *
   * // The record provider can be used to find records with a given number of microcredits
   * const record = await recordProvider.findCreditsRecord(5000, true, []);
   *
   * // When a record is found but not yet used, it's nonce should be added to the nonces parameter so that it is not
   * // found again if a subsequent search is performed
   * const records = await recordProvider.findCreditsRecords(5000, true, [record.nonce()]);
   *
   * // When the program manager is initialized with the record provider it will be used to find automatically find
   * // fee records and amount records for value transfers so that they do not need to be specified manually
   * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
   * programManager.transfer(1, "aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at", "public", 0.5);
   */
  async findCreditsRecord(microcredits, unspent, nonces, searchParameters) {
    let records = null;
    try {
      records = await this.findCreditsRecords([microcredits], unspent, nonces, searchParameters);
    } catch (e) {
      console.log("No records found with error:", e);
    }
    if (records && records.length > 0) {
      return records[0];
    }
    console.error("Record not found with error:", records);
    throw new Error("Record not found");
  }
  /**
   * Find an arbitrary record. WARNING: This function is not implemented yet and will throw an error.
   */
  async findRecord(unspent, nonces, searchParameters) {
    throw new Error("Not implemented");
  }
  /**
   * Find multiple records from a specified program.
   */
  async findRecords(unspent, nonces, searchParameters) {
    let startHeight = 0;
    let endHeight = 0;
    let amounts = void 0;
    let maxAmount = void 0;
    let programs = void 0;
    if (searchParameters) {
      if ("startHeight" in searchParameters && typeof searchParameters["startHeight"] == "number") {
        startHeight = searchParameters["startHeight"];
      }
      if ("endHeight" in searchParameters && typeof searchParameters["endHeight"] == "number") {
        endHeight = searchParameters["endHeight"];
      }
      if ("amounts" in searchParameters && Array.isArray(searchParameters["amounts"]) && searchParameters["amounts"].every((item) => typeof item === "number")) {
        amounts = searchParameters["amounts"];
      }
      if ("maxAmount" in searchParameters && typeof searchParameters["maxAmount"] == "number") {
        maxAmount = searchParameters["maxAmount"];
      }
      if ("nonces" in searchParameters && Array.isArray(searchParameters["nonces"]) && searchParameters["nonces"].every((item) => typeof item === "string")) {
        nonces = searchParameters["nonces"];
      }
      if ("program" in searchParameters && typeof searchParameters["program"] == "string") {
        programs = [searchParameters["program"]];
      }
      if ("programs" in searchParameters && Array.isArray(searchParameters["programs"]) && searchParameters["programs"].every((item) => typeof item === "string")) {
        programs = searchParameters["programs"];
      }
      if ("unspent" in searchParameters && typeof searchParameters["unspent"] == "boolean") {
        unspent = searchParameters["unspent"];
      }
    }
    if (endHeight == 0) {
      const end = await this.networkClient.getLatestHeight();
      endHeight = end;
    }
    if (startHeight >= endHeight) {
      logAndThrow("Start height must be less than end height");
    }
    return await this.networkClient.findRecords(startHeight, endHeight, unspent, programs, amounts, maxAmount, nonces, this.account.privateKey());
  }
};
var BlockHeightSearch = class {
  constructor(startHeight, endHeight) {
    __publicField(this, "startHeight");
    __publicField(this, "endHeight");
    this.startHeight = startHeight;
    this.endHeight = endHeight;
  }
};
var singletonWorker = null;
var createAleoWorker = () => {
  if (!singletonWorker) {
    const worker = new Worker(new URL("worker.js", import.meta.url), {
      type: "module"
    });
    singletonWorker = wrap(worker);
  }
  return singletonWorker;
};
async function initializeWasm() {
  console.warn("initializeWasm is deprecated, you no longer need to use it");
}
export {
  Account,
  Address3 as Address,
  AleoKeyProvider,
  AleoKeyProviderParams,
  AleoNetworkClient,
  BHP1024,
  BHP256,
  BHP512,
  BHP768,
  BlockHeightSearch,
  CREDITS_PROGRAM_KEYS,
  Ciphertext,
  ComputeKey2 as ComputeKey,
  ExecutionResponse,
  Field,
  Execution as FunctionExecution,
  Group,
  KEY_STORE,
  NetworkRecordProvider,
  OfflineKeyProvider,
  OfflineQuery,
  OfflineSearchParams,
  PRIVATE_TO_PUBLIC_TRANSFER,
  PRIVATE_TRANSFER,
  PRIVATE_TRANSFER_TYPES,
  PUBLIC_TO_PRIVATE_TRANSFER,
  PUBLIC_TRANSFER,
  PUBLIC_TRANSFER_AS_SIGNER,
  Pedersen128,
  Pedersen64,
  Plaintext2 as Plaintext,
  Poseidon2,
  Poseidon4,
  Poseidon8,
  PrivateKey3 as PrivateKey,
  PrivateKeyCiphertext2 as PrivateKeyCiphertext,
  Program2 as Program,
  ProgramManager,
  ProgramManager2 as ProgramManagerBase,
  ProvingKey3 as ProvingKey,
  RecordCiphertext3 as RecordCiphertext,
  RecordPlaintext2 as RecordPlaintext,
  Scalar,
  Signature,
  Transaction2 as Transaction,
  Transition,
  VALID_TRANSFER_TYPES,
  VerifyingKey3 as VerifyingKey,
  ViewKey2 as ViewKey,
  createAleoWorker,
  initThreadPool,
  initializeWasm,
  logAndThrow,
  verifyFunctionExecution2 as verifyFunctionExecution
};
//# sourceMappingURL=@provablehq_sdk.js.map
